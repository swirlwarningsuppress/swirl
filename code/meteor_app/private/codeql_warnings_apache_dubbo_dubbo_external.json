[
    {
        "url": "apache/dubbo/blob/main/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java#L128",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.cluster.directory;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.cluster.RouterChain;\nimport org.apache.dubbo.rpc.cluster.SingleRouterChain;\nimport org.apache.dubbo.rpc.cluster.router.state.BitList;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.CLUSTER_FAILED_SITE_SELECTION;\nimport static org.apache.dubbo.common.constants.RegistryConstants.REGISTER_MODE_KEY;\nimport static org.apache.dubbo.common.constants.RegistryConstants.REGISTRY_KEY;\n\n/**\n * StaticDirectory\n */\npublic class StaticDirectory<T> extends AbstractDirectory<T> {\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(StaticDirectory.class);\n    private final Class<T> interfaceClass;\n\n    public StaticDirectory(List<Invoker<T>> invokers) {\n        this(null, invokers, null);\n    }\n\n    public StaticDirectory(List<Invoker<T>> invokers, RouterChain<T> routerChain) {\n        this(null, invokers, routerChain);\n    }\n\n    public StaticDirectory(URL url, List<Invoker<T>> invokers) {\n        this(url, invokers, null);\n    }\n\n    public StaticDirectory(URL url, List<Invoker<T>> invokers, RouterChain<T> routerChain) {\n        super(\n                url == null && CollectionUtils.isNotEmpty(invokers)\n                        ? invokers.get(0).getUrl()\n                        : url,\n                routerChain,\n                false);\n        if (CollectionUtils.isEmpty(invokers)) {\n            throw new IllegalArgumentException(\"invokers == null\");\n        }\n        this.setInvokers(new BitList<>(invokers));\n        this.interfaceClass = invokers.get(0).getInterface();\n    }\n\n    @Override\n    public Class<T> getInterface() {\n        return interfaceClass;\n    }\n\n    @Override\n    public List<Invoker<T>> getAllInvokers() {\n        return getInvokers();\n    }\n\n    @Override\n    public boolean isAvailable() {\n        if (isDestroyed()) {\n            return false;\n        }\n        for (Invoker<T> invoker : getValidInvokers()) {\n            if (invoker.isAvailable()) {\n                return true;\n            } else {\n                addInvalidateInvoker(invoker);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void destroy() {\n        if (isDestroyed()) {\n            return;\n        }\n        for (Invoker<T> invoker : getInvokers()) {\n            invoker.destroy();\n        }\n        super.destroy();\n    }\n\n    public void buildRouterChain() {\n        RouterChain<T> routerChain = RouterChain.buildChain(getInterface(), getUrl());\n        routerChain.setInvokers(getInvokers(), () -> {});\n        this.setRouterChain(routerChain);\n    }\n\n    public void notify(List<Invoker<T>> invokers) {\n        BitList<Invoker<T>> bitList = new BitList<>(invokers);\n        if (routerChain != null) {\n            refreshRouter(bitList.clone(), () -> this.setInvokers(bitList));\n        } else {\n            this.setInvokers(bitList);\n        }\n    }\n\n    @Override\n    protected List<Invoker<T>> doList(\n            SingleRouterChain<T> singleRouterChain, BitList<Invoker<T>> invokers, Invocation invocation)\n            throws RpcException {\n        if (singleRouterChain != null) {\n            try {\n                List<Invoker<T>> finalInvokers = singleRouterChain.route(getConsumerUrl(), invokers, invocation);\n                return finalInvokers == null ? BitList.emptyList() : finalInvokers;\n            } catch (Throwable t) {\n                logger.error(\n                        CLUSTER_FAILED_SITE_SELECTION,\n                        \"Failed to execute router\",\n                        \"\",\n                        \"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(),\n                        t);\n                return BitList.emptyList();\n            }\n        }\n        return invokers;\n    }\n\n    @Override\n    protected Map<String, String> getDirectoryMeta() {\n        Map<String, String> metas = new HashMap<>();\n        metas.put(REGISTRY_KEY, \"static\");\n        metas.put(REGISTER_MODE_KEY, \"static\");\n        return metas;\n    }\n}\n",
        "methodName": null,
        "exampleID": 2,
        "dataset": "codeql",
        "filepath": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/directory/StaticDirectory.java",
        "line": 128,
        "sink": "org.apache.dubbo.rpc.cluster.SingleRouterChain<T>.route",
        "source": "-",
        "sourceLine": 128,
        "qualifier": "Call to org.apache.dubbo.rpc.cluster.SingleRouterChain<T>.route with untrusted data from [msg : Object](1).\nCall to org.apache.dubbo.rpc.cluster.SingleRouterChain<T>.route with untrusted data from [msg : Object](2).\nCall to org.apache.dubbo.rpc.cluster.SingleRouterChain<T>.route with untrusted data from [msg : Object](3).",
        "line_number": 128,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 3
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 3
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 3
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 3
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java#L63",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.cluster.loadbalance;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.io.Bytes;\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.support.RpcUtils;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;\n\n/**\n * ConsistentHashLoadBalance\n */\npublic class ConsistentHashLoadBalance extends AbstractLoadBalance {\n    public static final String NAME = \"consistenthash\";\n\n    /**\n     * Hash nodes name\n     */\n    public static final String HASH_NODES = \"hash.nodes\";\n\n    /**\n     * Hash arguments name\n     */\n    public static final String HASH_ARGUMENTS = \"hash.arguments\";\n\n    private final ConcurrentMap<String, ConsistentHashSelector<?>> selectors = new ConcurrentHashMap<>();\n\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected <T> Invoker<T> doSelect(List<Invoker<T>> invokers, URL url, Invocation invocation) {\n        String methodName = RpcUtils.getMethodName(invocation);\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + methodName;\n        // using the hashcode of list to compute the hash only pay attention to the elements in the list\n        int invokersHashCode = invokers.hashCode();\n        ConsistentHashSelector<T> selector = (ConsistentHashSelector<T>) selectors.get(key);\n        if (selector == null || selector.identityHashCode != invokersHashCode) {\n            selectors.put(key, new ConsistentHashSelector<T>(invokers, methodName, invokersHashCode));\n            selector = (ConsistentHashSelector<T>) selectors.get(key);\n        }\n        return selector.select(invocation);\n    }\n\n    private static final class ConsistentHashSelector<T> {\n\n        private final TreeMap<Long, Invoker<T>> virtualInvokers;\n\n        private final int replicaNumber;\n\n        private final int identityHashCode;\n\n        private final int[] argumentIndex;\n\n        ConsistentHashSelector(List<Invoker<T>> invokers, String methodName, int identityHashCode) {\n            this.virtualInvokers = new TreeMap<>();\n            this.identityHashCode = identityHashCode;\n            URL url = invokers.get(0).getUrl();\n            this.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, 160);\n            String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, \"0\"));\n            argumentIndex = new int[index.length];\n            for (int i = 0; i < index.length; i++) {\n                argumentIndex[i] = Integer.parseInt(index[i]);\n            }\n            for (Invoker<T> invoker : invokers) {\n                String address = invoker.getUrl().getAddress();\n                for (int i = 0; i < replicaNumber / 4; i++) {\n                    byte[] digest = Bytes.getMD5(address + i);\n                    for (int h = 0; h < 4; h++) {\n                        long m = hash(digest, h);\n                        virtualInvokers.put(m, invoker);\n                    }\n                }\n            }\n        }\n\n        public Invoker<T> select(Invocation invocation) {\n            String key = toKey(RpcUtils.getArguments(invocation));\n\n            byte[] digest = Bytes.getMD5(key);\n            return selectForKey(hash(digest, 0));\n        }\n\n        private String toKey(Object[] args) {\n            StringBuilder buf = new StringBuilder();\n            for (int i : argumentIndex) {\n                if (i >= 0 && args != null && i < args.length) {\n                    buf.append(args[i]);\n                }\n            }\n            return buf.toString();\n        }\n\n        private Invoker<T> selectForKey(long hash) {\n            Map.Entry<Long, Invoker<T>> entry = virtualInvokers.ceilingEntry(hash);\n            if (entry == null) {\n                entry = virtualInvokers.firstEntry();\n            }\n            return entry.getValue();\n        }\n\n        private long hash(byte[] digest, int number) {\n            return (((long) (digest[3 + number * 4] & 0xFF) << 24)\n                            | ((long) (digest[2 + number * 4] & 0xFF) << 16)\n                            | ((long) (digest[1 + number * 4] & 0xFF) << 8)\n                            | (digest[number * 4] & 0xFF))\n                    & 0xFFFFFFFFL;\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 4,
        "dataset": "codeql",
        "filepath": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/ConsistentHashLoadBalance.java",
        "line": 63,
        "sink": "org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance$ConsistentHashSelector<T>.select",
        "source": "-",
        "sourceLine": 63,
        "qualifier": "Call to org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance$ConsistentHashSelector<T>.select with untrusted data from [msg : Object](1).\nCall to org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance$ConsistentHashSelector<T>.select with untrusted data from [msg : Object](2).\nCall to org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance$ConsistentHashSelector<T>.select with untrusted data from [msg : Object](3).",
        "line_number": 63,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 5
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 5
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 5
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 5
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/script/config/AppScriptStateRouter.java#L78",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.cluster.router.script.config;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.config.configcenter.ConfigChangeType;\nimport org.apache.dubbo.common.config.configcenter.ConfigChangedEvent;\nimport org.apache.dubbo.common.config.configcenter.ConfigurationListener;\nimport org.apache.dubbo.common.config.configcenter.DynamicConfiguration;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.common.utils.Holder;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.cluster.router.RouterSnapshotNode;\nimport org.apache.dubbo.rpc.cluster.router.script.ScriptStateRouter;\nimport org.apache.dubbo.rpc.cluster.router.script.config.model.ScriptRule;\nimport org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\nimport org.apache.dubbo.rpc.cluster.router.state.BitList;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.CLUSTER_TAG_ROUTE_EMPTY;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.CLUSTER_TAG_ROUTE_INVALID;\nimport static org.apache.dubbo.common.utils.StringUtils.isEmpty;\nimport static org.apache.dubbo.rpc.cluster.Constants.DEFAULT_SCRIPT_TYPE_KEY;\nimport static org.apache.dubbo.rpc.cluster.Constants.FORCE_KEY;\nimport static org.apache.dubbo.rpc.cluster.Constants.RULE_KEY;\nimport static org.apache.dubbo.rpc.cluster.Constants.RUNTIME_KEY;\nimport static org.apache.dubbo.rpc.cluster.Constants.TYPE_KEY;\n\npublic class AppScriptStateRouter<T> extends AbstractStateRouter<T> implements ConfigurationListener {\n    private static final ErrorTypeAwareLogger logger =\n            LoggerFactory.getErrorTypeAwareLogger(AppScriptStateRouter.class);\n    private static final String RULE_SUFFIX = \".script-router\";\n\n    private ScriptRule scriptRule;\n    private ScriptStateRouter<T> scriptRouter;\n    private String application;\n\n    public AppScriptStateRouter(URL url) {\n        super(url);\n    }\n\n    @Override\n    protected BitList<Invoker<T>> doRoute(\n            BitList<Invoker<T>> invokers,\n            URL url,\n            Invocation invocation,\n            boolean needToPrintMessage,\n            Holder<RouterSnapshotNode<T>> routerSnapshotNodeHolder,\n            Holder<String> messageHolder)\n            throws RpcException {\n        if (scriptRouter == null || !scriptRule.isValid() || !scriptRule.isEnabled()) {\n            if (needToPrintMessage) {\n                messageHolder.set(\n                        \"Directly return from script router. Reason: Invokers from previous router is empty or script is not enabled. Script rule is: \"\n                                + (scriptRule == null ? \"null\" : scriptRule.getRawRule()));\n            }\n            return invokers;\n        }\n\n        invokers = scriptRouter.route(invokers, url, invocation, needToPrintMessage, routerSnapshotNodeHolder);\n\n        if (needToPrintMessage) {\n            messageHolder.set(messageHolder.get());\n        }\n\n        return invokers;\n    }\n\n    @Override\n    public synchronized void process(ConfigChangedEvent event) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Notification of script rule change, type is: \" + event.getChangeType() + \", raw rule is:\\n \"\n                    + event.getContent());\n        }\n\n        try {\n            if (event.getChangeType().equals(ConfigChangeType.DELETED)) {\n                this.scriptRule = null;\n            } else {\n                this.scriptRule = ScriptRule.parse(event.getContent());\n                URL scriptUrl = getUrl().addParameter(\n                                TYPE_KEY,\n                                isEmpty(scriptRule.getType()) ? DEFAULT_SCRIPT_TYPE_KEY : scriptRule.getType())\n                        .addParameterAndEncoded(RULE_KEY, scriptRule.getScript())\n                        .addParameter(FORCE_KEY, scriptRule.isForce())\n                        .addParameter(RUNTIME_KEY, scriptRule.isRuntime());\n                scriptRouter = new ScriptStateRouter<>(scriptUrl);\n            }\n        } catch (Exception e) {\n            logger.error(\n                    CLUSTER_TAG_ROUTE_INVALID,\n                    \"Failed to parse the raw tag router rule\",\n                    \"\",\n                    \"Failed to parse the raw tag router rule and it will not take effect, please check if the \"\n                            + \"rule matches with the template, the raw rule is:\\n \",\n                    e);\n        }\n    }\n\n    @Override\n    public void notify(BitList<Invoker<T>> invokers) {\n        if (CollectionUtils.isEmpty(invokers)) {\n            return;\n        }\n\n        Invoker<T> invoker = invokers.get(0);\n        URL url = invoker.getUrl();\n        String providerApplication = url.getRemoteApplication();\n\n        if (isEmpty(providerApplication)) {\n            logger.error(\n                    CLUSTER_TAG_ROUTE_EMPTY,\n                    \"tag router get providerApplication is empty\",\n                    \"\",\n                    \"TagRouter must getConfig from or subscribe to a specific application, but the application \"\n                            + \"in this TagRouter is not specified.\");\n            return;\n        }\n\n        synchronized (this) {\n            if (!providerApplication.equals(application)) {\n                if (StringUtils.isNotEmpty(application)) {\n                    this.getRuleRepository().removeListener(application + RULE_SUFFIX, this);\n                }\n                String key = providerApplication + RULE_SUFFIX;\n                this.getRuleRepository().addListener(key, this);\n                application = providerApplication;\n                String rawRule = this.getRuleRepository().getRule(key, DynamicConfiguration.DEFAULT_GROUP);\n                if (StringUtils.isNotEmpty(rawRule)) {\n                    this.process(new ConfigChangedEvent(key, DynamicConfiguration.DEFAULT_GROUP, rawRule));\n                }\n            }\n        }\n    }\n\n    @Override\n    public void stop() {\n        if (StringUtils.isNotEmpty(application)) {\n            this.getRuleRepository().removeListener(application + RULE_SUFFIX, this);\n        }\n    }\n\n    // for testing purpose\n    public void setScriptRule(ScriptRule scriptRule) {\n        this.scriptRule = scriptRule;\n    }\n}\n",
        "methodName": null,
        "exampleID": 6,
        "dataset": "codeql",
        "filepath": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/script/config/AppScriptStateRouter.java",
        "line": 78,
        "sink": "org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter<T>.route",
        "source": "-",
        "sourceLine": 78,
        "qualifier": "Call to org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter<T>.route with untrusted data from [msg : Object](1).\nCall to org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter<T>.route with untrusted data from [msg : Object](2).\nCall to org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter<T>.route with untrusted data from [msg : Object](3).",
        "line_number": 78,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 7
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 7
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 7
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 7
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/script/ScriptStateRouter.java#L156",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.cluster.router.script;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.ConcurrentHashMapUtils;\nimport org.apache.dubbo.common.utils.Holder;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.RpcContext;\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.cluster.router.RouterSnapshotNode;\nimport org.apache.dubbo.rpc.cluster.router.state.AbstractStateRouter;\nimport org.apache.dubbo.rpc.cluster.router.state.BitList;\nimport org.apache.dubbo.rpc.support.RpcUtils;\n\nimport javax.script.Bindings;\nimport javax.script.Compilable;\nimport javax.script.CompiledScript;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\n\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.CodeSource;\nimport java.security.Permissions;\nimport java.security.PrivilegedAction;\nimport java.security.ProtectionDomain;\nimport java.security.cert.Certificate;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.stream.Collectors;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.CLUSTER_SCRIPT_EXCEPTION;\nimport static org.apache.dubbo.rpc.cluster.Constants.DEFAULT_SCRIPT_TYPE_KEY;\nimport static org.apache.dubbo.rpc.cluster.Constants.FORCE_KEY;\nimport static org.apache.dubbo.rpc.cluster.Constants.RULE_KEY;\nimport static org.apache.dubbo.rpc.cluster.Constants.RUNTIME_KEY;\nimport static org.apache.dubbo.rpc.cluster.Constants.TYPE_KEY;\n\n/**\n * ScriptRouter\n */\npublic class ScriptStateRouter<T> extends AbstractStateRouter<T> {\n    public static final String NAME = \"SCRIPT_ROUTER\";\n    private static final int SCRIPT_ROUTER_DEFAULT_PRIORITY = 0;\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(ScriptStateRouter.class);\n\n    private static final ConcurrentMap<String, ScriptEngine> ENGINES = new ConcurrentHashMap<>();\n\n    private final ScriptEngine engine;\n\n    private final String rule;\n\n    private CompiledScript function;\n\n    private AccessControlContext accessControlContext;\n\n    {\n        // Just give permission of reflect to access member.\n        Permissions perms = new Permissions();\n        perms.add(new RuntimePermission(\"accessDeclaredMembers\"));\n        // Cast to Certificate[] required because of ambiguity:\n        ProtectionDomain domain = new ProtectionDomain(new CodeSource(null, (Certificate[]) null), perms);\n        accessControlContext = new AccessControlContext(new ProtectionDomain[] {domain});\n    }\n\n    public ScriptStateRouter(URL url) {\n        super(url);\n        this.setUrl(url);\n\n        engine = getEngine(url);\n        rule = getRule(url);\n        try {\n            Compilable compilable = (Compilable) engine;\n            function = compilable.compile(rule);\n        } catch (ScriptException e) {\n            logger.error(\n                    CLUSTER_SCRIPT_EXCEPTION,\n                    \"script route rule invalid\",\n                    \"\",\n                    \"script route error, rule has been ignored. rule: \" + rule + \", url: \"\n                            + RpcContext.getServiceContext().getUrl(),\n                    e);\n        }\n    }\n\n    /**\n     * get rule from url parameters.\n     */\n    private String getRule(URL url) {\n        String vRule = url.getParameterAndDecoded(RULE_KEY);\n        if (StringUtils.isEmpty(vRule)) {\n            throw new IllegalStateException(\"route rule can not be empty.\");\n        }\n        return vRule;\n    }\n\n    /**\n     * create ScriptEngine instance by type from url parameters, then cache it\n     */\n    private ScriptEngine getEngine(URL url) {\n        String type = url.getParameter(TYPE_KEY, DEFAULT_SCRIPT_TYPE_KEY);\n\n        return ConcurrentHashMapUtils.computeIfAbsent(ENGINES, type, t -> {\n            ScriptEngine scriptEngine = new ScriptEngineManager().getEngineByName(type);\n            if (scriptEngine == null) {\n                throw new IllegalStateException(\"unsupported route engine type: \" + type);\n            }\n            return scriptEngine;\n        });\n    }\n\n    @Override\n    protected BitList<Invoker<T>> doRoute(\n            BitList<Invoker<T>> invokers,\n            URL url,\n            Invocation invocation,\n            boolean needToPrintMessage,\n            Holder<RouterSnapshotNode<T>> nodeHolder,\n            Holder<String> messageHolder)\n            throws RpcException {\n        if (engine == null || function == null) {\n            if (needToPrintMessage) {\n                messageHolder.set(\"Directly Return. Reason: engine or function is null\");\n            }\n            return invokers;\n        }\n        Bindings bindings = createBindings(invokers, invocation);\n        return getRoutedInvokers(\n                invokers,\n                AccessController.doPrivileged(\n                        (PrivilegedAction<Object>) () -> {\n                            try {\n                                return function.eval(bindings);\n                            } catch (ScriptException e) {\n                                logger.error(\n                                        CLUSTER_SCRIPT_EXCEPTION,\n                                        \"Scriptrouter exec script error\",\n                                        \"\",\n                                        \"Script route error, rule has been ignored. rule: \" + rule + \", method:\"\n                                                + RpcUtils.getMethodName(invocation) + \", url: \"\n                                                + RpcContext.getContext().getUrl(),\n                                        e);\n                                return invokers;\n                            }\n                        },\n                        accessControlContext));\n    }\n\n    /**\n     * get routed invokers from result of script rule evaluation\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected BitList<Invoker<T>> getRoutedInvokers(BitList<Invoker<T>> invokers, Object obj) {\n        BitList<Invoker<T>> result = invokers.clone();\n        if (obj instanceof Invoker[]) {\n            result.retainAll(Arrays.asList((Invoker<T>[]) obj));\n        } else if (obj instanceof Object[]) {\n            result.retainAll(\n                    Arrays.stream((Object[]) obj).map(item -> (Invoker<T>) item).collect(Collectors.toList()));\n        } else {\n            result.retainAll((List<Invoker<T>>) obj);\n        }\n        return result;\n    }\n\n    /**\n     * create bindings for script engine\n     */\n    private Bindings createBindings(List<Invoker<T>> invokers, Invocation invocation) {\n        Bindings bindings = engine.createBindings();\n        // create a new List of invokers\n        bindings.put(\"invokers\", new ArrayList<>(invokers));\n        bindings.put(\"invocation\", invocation);\n        bindings.put(\"context\", RpcContext.getClientAttachment());\n        return bindings;\n    }\n\n    @Override\n    public boolean isRuntime() {\n        return this.getUrl().getParameter(RUNTIME_KEY, false);\n    }\n\n    @Override\n    public boolean isForce() {\n        return this.getUrl().getParameter(FORCE_KEY, false);\n    }\n}\n",
        "methodName": null,
        "exampleID": 8,
        "dataset": "codeql",
        "filepath": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/router/script/ScriptStateRouter.java",
        "line": 156,
        "sink": "javax.script.CompiledScript.eval",
        "source": "-",
        "sourceLine": 156,
        "qualifier": "Call to javax.script.CompiledScript.eval with untrusted data from [msg : Object](1).\nCall to javax.script.CompiledScript.eval with untrusted data from [msg : Object](2).\nCall to javax.script.CompiledScript.eval with untrusted data from [msg : Object](3).",
        "line_number": 156,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 9
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 9
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 9
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 9
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AvailableClusterInvoker.java#L43",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.cluster.support;\n\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.Result;\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.cluster.Directory;\nimport org.apache.dubbo.rpc.cluster.LoadBalance;\n\nimport java.util.List;\n\n/**\n * AvailableClusterInvoker\n *\n */\npublic class AvailableClusterInvoker<T> extends AbstractClusterInvoker<T> {\n\n    public AvailableClusterInvoker(Directory<T> directory) {\n        super(directory);\n    }\n\n    @Override\n    public Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance)\n            throws RpcException {\n        for (Invoker<T> invoker : invokers) {\n            if (invoker.isAvailable()) {\n                return invokeWithContext(invoker, invocation);\n            }\n        }\n        throw new RpcException(\"No provider available in \" + invokers);\n    }\n}\n",
        "methodName": null,
        "exampleID": 10,
        "dataset": "codeql",
        "filepath": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/AvailableClusterInvoker.java",
        "line": 43,
        "sink": "org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker<T>.invokeWithContext",
        "source": "-",
        "sourceLine": 43,
        "qualifier": "Call to org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker<T>.invokeWithContext with untrusted data from [msg : Object](1).\nCall to org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker<T>.invokeWithContext with untrusted data from [msg : Object](2).\nCall to org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker<T>.invokeWithContext with untrusted data from [msg : Object](3).",
        "line_number": 43,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 11
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 11
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 11
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 11
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java#L83",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.cluster.support;\n\nimport org.apache.dubbo.common.constants.LoggerCodeConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.ConfigUtils;\nimport org.apache.dubbo.rpc.AsyncRpcResult;\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.Result;\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.RpcInvocation;\nimport org.apache.dubbo.rpc.cluster.Directory;\nimport org.apache.dubbo.rpc.cluster.LoadBalance;\nimport org.apache.dubbo.rpc.cluster.Merger;\nimport org.apache.dubbo.rpc.cluster.merger.MergerFactory;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\nimport org.apache.dubbo.rpc.model.ScopeModelUtil;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.CLUSTER_FAILED_GROUP_MERGE;\nimport static org.apache.dubbo.rpc.Constants.ASYNC_KEY;\nimport static org.apache.dubbo.rpc.Constants.MERGER_KEY;\n\n/**\n * @param <T>\n */\n@SuppressWarnings(\"unchecked\")\npublic class MergeableClusterInvoker<T> extends AbstractClusterInvoker<T> {\n\n    private static final ErrorTypeAwareLogger log =\n            LoggerFactory.getErrorTypeAwareLogger(MergeableClusterInvoker.class);\n\n    public MergeableClusterInvoker(Directory<T> directory) {\n        super(directory);\n    }\n\n    @Override\n    protected Result doInvoke(Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance)\n            throws RpcException {\n        String merger = getUrl().getMethodParameter(invocation.getMethodName(), MERGER_KEY);\n        if (ConfigUtils.isEmpty(merger)) { // If a method doesn't have a merger, only invoke one Group\n            for (final Invoker<T> invoker : invokers) {\n                if (invoker.isAvailable()) {\n                    try {\n                        return invokeWithContext(invoker, invocation);\n                    } catch (RpcException e) {\n                        if (e.isNoInvokerAvailableAfterFilter()) {\n                            log.debug(\n                                    \"No available provider for service\" + getUrl().getServiceKey() + \" on group \"\n                                            + invoker.getUrl().getGroup() + \", will continue to try another group.\",\n                                    e);\n                        } else {\n                            throw e;\n                        }\n                    }\n                }\n            }\n            return invokeWithContext(invokers.iterator().next(), invocation);\n        }\n\n        Class<?> returnType;\n        try {\n            returnType = getInterface()\n                    .getMethod(invocation.getMethodName(), invocation.getParameterTypes())\n                    .getReturnType();\n        } catch (NoSuchMethodException e) {\n            returnType = null;\n        }\n\n        Map<String, Result> results = new HashMap<>();\n        for (final Invoker<T> invoker : invokers) {\n            RpcInvocation subInvocation = new RpcInvocation(invocation, invoker);\n            subInvocation.setAttachment(ASYNC_KEY, \"true\");\n            try {\n                results.put(invoker.getUrl().getServiceKey(), invokeWithContext(invoker, subInvocation));\n            } catch (RpcException e) {\n                if (e.isNoInvokerAvailableAfterFilter()) {\n                    log.warn(\n                            LoggerCodeConstants.CLUSTER_NO_VALID_PROVIDER,\n                            e.getCause().getMessage(),\n                            \"\",\n                            \"No available provider for service\" + getUrl().getServiceKey() + \" on group \"\n                                    + invoker.getUrl().getGroup() + \", will continue to try another group.\",\n                            e);\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        Object result;\n\n        List<Result> resultList = new ArrayList<>(results.size());\n\n        for (Map.Entry<String, Result> entry : results.entrySet()) {\n            Result asyncResult = entry.getValue();\n            try {\n                Result r = asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);\n                if (r.hasException()) {\n                    log.error(\n                            CLUSTER_FAILED_GROUP_MERGE,\n                            \"Invoke \" + getGroupDescFromServiceKey(entry.getKey()) + \" failed: \"\n                                    + r.getException().getMessage(),\n                            \"\",\n                            r.getException().getMessage());\n                } else {\n                    resultList.add(r);\n                }\n            } catch (Exception e) {\n                throw new RpcException(\"Failed to invoke service \" + entry.getKey() + \": \" + e.getMessage(), e);\n            }\n        }\n\n        if (resultList.isEmpty()) {\n            return AsyncRpcResult.newDefaultAsyncResult(invocation);\n        } else if (resultList.size() == 1) {\n            return AsyncRpcResult.newDefaultAsyncResult(resultList.get(0).getValue(), invocation);\n        }\n\n        if (returnType == void.class) {\n            return AsyncRpcResult.newDefaultAsyncResult(invocation);\n        }\n\n        if (merger.startsWith(\".\")) {\n            merger = merger.substring(1);\n            Method method;\n            try {\n                method = returnType.getMethod(merger, returnType);\n            } catch (NoSuchMethodException | NullPointerException e) {\n                throw new RpcException(\"Can not merge result because missing method [ \" + merger + \" ] in class [ \"\n                        + returnType.getName() + \" ]\");\n            }\n            if (!Modifier.isPublic(method.getModifiers())) {\n                method.setAccessible(true);\n            }\n            result = resultList.remove(0).getValue();\n            try {\n                if (method.getReturnType() != void.class\n                        && method.getReturnType().isAssignableFrom(result.getClass())) {\n                    for (Result r : resultList) {\n                        result = method.invoke(result, r.getValue());\n                    }\n                } else {\n                    for (Result r : resultList) {\n                        method.invoke(result, r.getValue());\n                    }\n                }\n            } catch (Exception e) {\n                throw new RpcException(\"Can not merge result: \" + e.getMessage(), e);\n            }\n        } else {\n            Merger resultMerger;\n            ApplicationModel applicationModel = ScopeModelUtil.getApplicationModel(\n                    invocation.getModuleModel().getApplicationModel());\n\n            if (ConfigUtils.isDefault(merger)) {\n                resultMerger = applicationModel\n                        .getBeanFactory()\n                        .getBean(MergerFactory.class)\n                        .getMerger(returnType);\n            } else {\n                resultMerger = applicationModel.getExtensionLoader(Merger.class).getExtension(merger);\n            }\n            if (resultMerger != null) {\n                List<Object> rets = new ArrayList<>(resultList.size());\n                for (Result r : resultList) {\n                    rets.add(r.getValue());\n                }\n                result = resultMerger.merge(rets.toArray((Object[]) Array.newInstance(returnType, 0)));\n            } else {\n                throw new RpcException(\"There is no merger to merge result.\");\n            }\n        }\n        return AsyncRpcResult.newDefaultAsyncResult(result, invocation);\n    }\n\n    @Override\n    public Class<T> getInterface() {\n        return directory.getInterface();\n    }\n\n    @Override\n    public boolean isAvailable() {\n        return directory.isAvailable();\n    }\n\n    @Override\n    public void destroy() {\n        directory.destroy();\n    }\n\n    private String getGroupDescFromServiceKey(String key) {\n        int index = key.indexOf(\"/\");\n        if (index > 0) {\n            return \"group [ \" + key.substring(0, index) + \" ]\";\n        }\n        return key;\n    }\n}\n",
        "methodName": null,
        "exampleID": 12,
        "dataset": "codeql",
        "filepath": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/MergeableClusterInvoker.java",
        "line": 83,
        "sink": "org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker<T>.invokeWithContext",
        "source": "-",
        "sourceLine": 83,
        "qualifier": "Call to org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker<T>.invokeWithContext with untrusted data from [msg : Object](1).\nCall to org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker<T>.invokeWithContext with untrusted data from [msg : Object](2).\nCall to org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker<T>.invokeWithContext with untrusted data from [msg : Object](3).",
        "line_number": 83,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 13
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 13
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 13
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 13
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvoker.java#L100",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.cluster.support;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.threadlocal.NamedInternalThreadFactory;\nimport org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository;\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.Result;\nimport org.apache.dubbo.rpc.RpcContext;\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.cluster.Directory;\nimport org.apache.dubbo.rpc.cluster.LoadBalance;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.CompletionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_TIMEOUT;\nimport static org.apache.dubbo.common.constants.CommonConstants.FORKS_KEY;\nimport static org.apache.dubbo.common.constants.CommonConstants.TIMEOUT_KEY;\nimport static org.apache.dubbo.rpc.cluster.Constants.DEFAULT_FORKS;\n\n/**\n * NOTICE! This implementation does not work well with async call.\n * <p>\n * Invoke a specific number of invokers concurrently, usually used for demanding real-time operations, but need to waste more service resources.\n *\n * <a href=\"http://en.wikipedia.org/wiki/Fork_(topology)\">Fork</a>\n */\npublic class ForkingClusterInvoker<T> extends AbstractClusterInvoker<T> {\n\n    /**\n     * Use {@link NamedInternalThreadFactory} to produce {@link org.apache.dubbo.common.threadlocal.InternalThread}\n     * which with the use of {@link org.apache.dubbo.common.threadlocal.InternalThreadLocal} in {@link RpcContext}.\n     */\n    private final ExecutorService executor;\n\n    public ForkingClusterInvoker(Directory<T> directory) {\n        super(directory);\n        executor = directory\n                .getUrl()\n                .getOrDefaultFrameworkModel()\n                .getBeanFactory()\n                .getBean(FrameworkExecutorRepository.class)\n                .getSharedExecutor();\n    }\n\n    @Override\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public Result doInvoke(final Invocation invocation, List<Invoker<T>> invokers, LoadBalance loadbalance)\n            throws RpcException {\n        try {\n            final List<Invoker<T>> selected;\n            final int forks = getUrl().getParameter(FORKS_KEY, DEFAULT_FORKS);\n            final int timeout = getUrl().getParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);\n            if (forks <= 0 || forks >= invokers.size()) {\n                selected = invokers;\n            } else {\n                selected = new ArrayList<>(forks);\n                while (selected.size() < forks) {\n                    Invoker<T> invoker = select(loadbalance, invocation, invokers, selected);\n                    if (!selected.contains(invoker)) {\n                        // Avoid add the same invoker several times.\n                        selected.add(invoker);\n                    }\n                }\n            }\n            RpcContext.getServiceContext().setInvokers((List) selected);\n            final AtomicInteger count = new AtomicInteger();\n            final BlockingQueue<Object> ref = new LinkedBlockingQueue<>(1);\n            selected.forEach(invoker -> {\n                URL consumerUrl = RpcContext.getServiceContext().getConsumerUrl();\n                CompletableFuture.<Object>supplyAsync(\n                                () -> {\n                                    if (ref.size() > 0) {\n                                        return null;\n                                    }\n                                    return invokeWithContextAsync(invoker, invocation, consumerUrl);\n                                },\n                                executor)\n                        .whenComplete((v, t) -> {\n                            if (t == null) {\n                                ref.offer(v);\n                            } else {\n                                int value = count.incrementAndGet();\n                                if (value >= selected.size()) {\n                                    ref.offer(t);\n                                }\n                            }\n                        });\n            });\n            try {\n                Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);\n                if (ret instanceof Throwable) {\n                    Throwable e = ret instanceof CompletionException\n                            ? ((CompletionException) ret).getCause()\n                            : (Throwable) ret;\n                    throw new RpcException(\n                            e instanceof RpcException ? ((RpcException) e).getCode() : RpcException.UNKNOWN_EXCEPTION,\n                            \"Failed to forking invoke provider \" + selected\n                                    + \", but no luck to perform the invocation. \" + \"Last error is: \" + e.getMessage(),\n                            e.getCause() != null ? e.getCause() : e);\n                }\n                return (Result) ret;\n            } catch (InterruptedException e) {\n                throw new RpcException(\n                        \"Failed to forking invoke provider \" + selected + \", \"\n                                + \"but no luck to perform the invocation. Last error is: \" + e.getMessage(),\n                        e);\n            }\n        } finally {\n            // clear attachments which is binding to current thread.\n            RpcContext.getClientAttachment().clearAttachments();\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 14,
        "dataset": "codeql",
        "filepath": "dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/support/ForkingClusterInvoker.java",
        "line": 100,
        "sink": "org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker<T>.invokeWithContextAsync",
        "source": "-",
        "sourceLine": 100,
        "qualifier": "Call to org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker<T>.invokeWithContextAsync with untrusted data from [msg : Object](1).\nCall to org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker<T>.invokeWithContextAsync with untrusted data from [msg : Object](2).\nCall to org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker<T>.invokeWithContextAsync with untrusted data from [msg : Object](3).",
        "line_number": 100,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 15
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 15
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 15
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 15
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/json/impl/FastJsonImpl.java#L43",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.json.impl;\n\nimport java.lang.reflect.Type;\nimport java.util.List;\n\nimport com.alibaba.fastjson.serializer.SerializerFeature;\n\npublic class FastJsonImpl extends AbstractJSONImpl {\n\n    @Override\n    public boolean isJson(String json) {\n        try {\n            Object obj = com.alibaba.fastjson.JSON.parse(json);\n            return obj instanceof com.alibaba.fastjson.JSONObject || obj instanceof com.alibaba.fastjson.JSONArray;\n        } catch (com.alibaba.fastjson.JSONException e) {\n            return false;\n        }\n    }\n\n    @Override\n    public <T> T toJavaObject(String json, Type type) {\n        return com.alibaba.fastjson.JSON.parseObject(json, type);\n    }\n\n    @Override\n    public <T> List<T> toJavaList(String json, Class<T> clazz) {\n        return com.alibaba.fastjson.JSON.parseArray(json, clazz);\n    }\n\n    @Override\n    public String toJson(Object obj) {\n        return com.alibaba.fastjson.JSON.toJSONString(obj, SerializerFeature.DisableCircularReferenceDetect);\n    }\n}\n",
        "methodName": null,
        "exampleID": 16,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/json/impl/FastJsonImpl.java",
        "line": 43,
        "sink": "com.alibaba.fastjson.JSON.parseArray",
        "source": "-",
        "sourceLine": 43,
        "qualifier": "Call to com.alibaba.fastjson.JSON.parseArray with untrusted data from [msg : HttpRequest](1).\nCall to com.alibaba.fastjson.JSON.parseArray with untrusted data from [msg : String](2).",
        "line_number": 43,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 17
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 17
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 17
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 17
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java#L48",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jdk;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport java.util.logging.Level;\n\npublic class JdkLogger implements Logger {\n\n    private final java.util.logging.Logger logger;\n\n    public JdkLogger(java.util.logging.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(Level.FINER, msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(Level.FINER, e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(Level.FINER, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(Level.FINE, msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(Level.FINE, e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(Level.FINE, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(Level.INFO, msg);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(Level.WARNING, msg);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(Level.WARNING, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(Level.SEVERE, msg);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(Level.SEVERE, msg, e);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(Level.SEVERE, e.getMessage(), e);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(Level.INFO, e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(Level.WARNING, e.getMessage(), e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINER);\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n}\n",
        "methodName": null,
        "exampleID": 18,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java",
        "line": 48,
        "sink": "java.util.logging.Logger.log",
        "source": "-",
        "sourceLine": 48,
        "qualifier": "Call to java.util.logging.Logger.log with untrusted data from [getHeaderString(...) : String](1).",
        "line_number": 48,
        "steps": [
            {
                "line": 42,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/filter/TraceRequestAndResponseFilter.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/filter/TraceRequestAndResponseFilter.java",
                "methodName": null,
                "exampleID": 19
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java#L63",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jdk;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport java.util.logging.Level;\n\npublic class JdkLogger implements Logger {\n\n    private final java.util.logging.Logger logger;\n\n    public JdkLogger(java.util.logging.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(Level.FINER, msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(Level.FINER, e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(Level.FINER, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(Level.FINE, msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(Level.FINE, e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(Level.FINE, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(Level.INFO, msg);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(Level.WARNING, msg);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(Level.WARNING, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(Level.SEVERE, msg);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(Level.SEVERE, msg, e);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(Level.SEVERE, e.getMessage(), e);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(Level.INFO, e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(Level.WARNING, e.getMessage(), e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINER);\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n}\n",
        "methodName": null,
        "exampleID": 20,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java",
        "line": 63,
        "sink": "java.util.logging.Logger.log",
        "source": "-",
        "sourceLine": 63,
        "qualifier": "Call to java.util.logging.Logger.log with untrusted data from [msg : HttpRequest](1).\nCall to java.util.logging.Logger.log with untrusted data from [msg : String](2).",
        "line_number": 63,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 21
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 21
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 21
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 21
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java#L68",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jdk;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport java.util.logging.Level;\n\npublic class JdkLogger implements Logger {\n\n    private final java.util.logging.Logger logger;\n\n    public JdkLogger(java.util.logging.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(Level.FINER, msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(Level.FINER, e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(Level.FINER, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(Level.FINE, msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(Level.FINE, e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(Level.FINE, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(Level.INFO, msg);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(Level.WARNING, msg);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(Level.WARNING, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(Level.SEVERE, msg);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(Level.SEVERE, msg, e);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(Level.SEVERE, e.getMessage(), e);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(Level.INFO, e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(Level.WARNING, e.getMessage(), e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINER);\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n}\n",
        "methodName": null,
        "exampleID": 22,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java",
        "line": 68,
        "sink": "java.util.logging.Logger.log",
        "source": "-",
        "sourceLine": 68,
        "qualifier": "Call to java.util.logging.Logger.log with untrusted data from [msg : HttpRequest](1).\nCall to java.util.logging.Logger.log with untrusted data from [msg : String](2).",
        "line_number": 68,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 23
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 23
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 23
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 23
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java#L73",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jdk;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport java.util.logging.Level;\n\npublic class JdkLogger implements Logger {\n\n    private final java.util.logging.Logger logger;\n\n    public JdkLogger(java.util.logging.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(Level.FINER, msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(Level.FINER, e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(Level.FINER, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(Level.FINE, msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(Level.FINE, e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(Level.FINE, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(Level.INFO, msg);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(Level.WARNING, msg);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(Level.WARNING, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(Level.SEVERE, msg);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(Level.SEVERE, msg, e);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(Level.SEVERE, e.getMessage(), e);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(Level.INFO, e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(Level.WARNING, e.getMessage(), e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINER);\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n}\n",
        "methodName": null,
        "exampleID": 24,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java",
        "line": 73,
        "sink": "java.util.logging.Logger.log",
        "source": "-",
        "sourceLine": 73,
        "qualifier": "Call to java.util.logging.Logger.log with untrusted data from [msg : HttpRequest](1).\nCall to java.util.logging.Logger.log with untrusted data from [msg : String](2).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](3).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](4).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](5).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Http2StreamFrame](6).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](7).",
        "line_number": 73,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 25
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 25
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 25
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 25
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java#L78",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jdk;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport java.util.logging.Level;\n\npublic class JdkLogger implements Logger {\n\n    private final java.util.logging.Logger logger;\n\n    public JdkLogger(java.util.logging.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(Level.FINER, msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(Level.FINER, e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(Level.FINER, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(Level.FINE, msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(Level.FINE, e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(Level.FINE, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(Level.INFO, msg);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(Level.WARNING, msg);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(Level.WARNING, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(Level.SEVERE, msg);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(Level.SEVERE, msg, e);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(Level.SEVERE, e.getMessage(), e);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(Level.INFO, e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(Level.WARNING, e.getMessage(), e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINER);\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n}\n",
        "methodName": null,
        "exampleID": 26,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java",
        "line": 78,
        "sink": "java.util.logging.Logger.log",
        "source": "-",
        "sourceLine": 78,
        "qualifier": "Call to java.util.logging.Logger.log with untrusted data from [msg : Object](1).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](2).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](3).",
        "line_number": 78,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 27
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 27
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 27
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 27
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java#L83",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jdk;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport java.util.logging.Level;\n\npublic class JdkLogger implements Logger {\n\n    private final java.util.logging.Logger logger;\n\n    public JdkLogger(java.util.logging.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(Level.FINER, msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(Level.FINER, e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(Level.FINER, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(Level.FINE, msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(Level.FINE, e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(Level.FINE, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(Level.INFO, msg);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(Level.WARNING, msg);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(Level.WARNING, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(Level.SEVERE, msg);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(Level.SEVERE, msg, e);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(Level.SEVERE, e.getMessage(), e);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(Level.INFO, e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(Level.WARNING, e.getMessage(), e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINER);\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n}\n",
        "methodName": null,
        "exampleID": 28,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java",
        "line": 83,
        "sink": "java.util.logging.Logger.log",
        "source": "-",
        "sourceLine": 83,
        "qualifier": "Call to java.util.logging.Logger.log with untrusted data from [msg : HttpRequest](1).\nCall to java.util.logging.Logger.log with untrusted data from [msg : String](2).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](3).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](4).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](5).",
        "line_number": 83,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 29
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 29
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 29
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 29
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java#L88",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jdk;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport java.util.logging.Level;\n\npublic class JdkLogger implements Logger {\n\n    private final java.util.logging.Logger logger;\n\n    public JdkLogger(java.util.logging.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(Level.FINER, msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(Level.FINER, e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(Level.FINER, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(Level.FINE, msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(Level.FINE, e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(Level.FINE, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(Level.INFO, msg);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(Level.WARNING, msg);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(Level.WARNING, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(Level.SEVERE, msg);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(Level.SEVERE, msg, e);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(Level.SEVERE, e.getMessage(), e);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(Level.INFO, e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(Level.WARNING, e.getMessage(), e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isLoggable(Level.FINER);\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isLoggable(Level.FINE);\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isLoggable(Level.INFO);\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isLoggable(Level.WARNING);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isLoggable(Level.SEVERE);\n    }\n}\n",
        "methodName": null,
        "exampleID": 30,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jdk/JdkLogger.java",
        "line": 88,
        "sink": "java.util.logging.Logger.log",
        "source": "-",
        "sourceLine": 88,
        "qualifier": "Call to java.util.logging.Logger.log with untrusted data from [msg : HttpRequest](1).\nCall to java.util.logging.Logger.log with untrusted data from [msg : String](2).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](3).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](4).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](5).\nCall to java.util.logging.Logger.log with untrusted data from [request : FullHttpRequest](6).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Http2StreamFrame](7).\nCall to java.util.logging.Logger.log with untrusted data from [msg : Object](8).",
        "line_number": 88,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 31
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 31
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 31
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 31
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java#L52",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jcl;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport org.apache.commons.logging.Log;\n\n/**\n * Adaptor to commons logging, depends on commons-logging.jar. For more information about commons logging, pls. refer to\n * <a target=\"_blank\" href=\"http://www.apache.org/\">http://www.apache.org/</a>\n */\npublic class JclLogger implements Logger {\n\n    private final Log logger;\n\n    public JclLogger(Log logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 32,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java",
        "line": 52,
        "sink": "org.apache.commons.logging.Log.debug",
        "source": "-",
        "sourceLine": 52,
        "qualifier": "Call to org.apache.commons.logging.Log.debug with untrusted data from [getHeaderString(...) : String](1).",
        "line_number": 52,
        "steps": [
            {
                "line": 42,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/filter/TraceRequestAndResponseFilter.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/filter/TraceRequestAndResponseFilter.java",
                "methodName": null,
                "exampleID": 33
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java#L67",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jcl;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport org.apache.commons.logging.Log;\n\n/**\n * Adaptor to commons logging, depends on commons-logging.jar. For more information about commons logging, pls. refer to\n * <a target=\"_blank\" href=\"http://www.apache.org/\">http://www.apache.org/</a>\n */\npublic class JclLogger implements Logger {\n\n    private final Log logger;\n\n    public JclLogger(Log logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 34,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java",
        "line": 67,
        "sink": "org.apache.commons.logging.Log.info",
        "source": "-",
        "sourceLine": 67,
        "qualifier": "Call to org.apache.commons.logging.Log.info with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.commons.logging.Log.info with untrusted data from [msg : String](2).",
        "line_number": 67,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 35
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 35
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 35
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 35
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java#L77",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jcl;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport org.apache.commons.logging.Log;\n\n/**\n * Adaptor to commons logging, depends on commons-logging.jar. For more information about commons logging, pls. refer to\n * <a target=\"_blank\" href=\"http://www.apache.org/\">http://www.apache.org/</a>\n */\npublic class JclLogger implements Logger {\n\n    private final Log logger;\n\n    public JclLogger(Log logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 36,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java",
        "line": 77,
        "sink": "org.apache.commons.logging.Log.info",
        "source": "-",
        "sourceLine": 77,
        "qualifier": "Call to org.apache.commons.logging.Log.info with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.commons.logging.Log.info with untrusted data from [msg : String](2).",
        "line_number": 77,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 37
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 37
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 37
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 37
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java#L82",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jcl;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport org.apache.commons.logging.Log;\n\n/**\n * Adaptor to commons logging, depends on commons-logging.jar. For more information about commons logging, pls. refer to\n * <a target=\"_blank\" href=\"http://www.apache.org/\">http://www.apache.org/</a>\n */\npublic class JclLogger implements Logger {\n\n    private final Log logger;\n\n    public JclLogger(Log logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 38,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java",
        "line": 82,
        "sink": "org.apache.commons.logging.Log.warn",
        "source": "-",
        "sourceLine": 82,
        "qualifier": "Call to org.apache.commons.logging.Log.warn with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.commons.logging.Log.warn with untrusted data from [msg : String](2).\nCall to org.apache.commons.logging.Log.warn with untrusted data from [msg : Object](3).\nCall to org.apache.commons.logging.Log.warn with untrusted data from [msg : Object](4).\nCall to org.apache.commons.logging.Log.warn with untrusted data from [msg : Object](5).\nCall to org.apache.commons.logging.Log.warn with untrusted data from [msg : Http2StreamFrame](6).\nCall to org.apache.commons.logging.Log.warn with untrusted data from [msg : Object](7).",
        "line_number": 82,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 39
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 39
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 39
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 39
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java#L92",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jcl;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport org.apache.commons.logging.Log;\n\n/**\n * Adaptor to commons logging, depends on commons-logging.jar. For more information about commons logging, pls. refer to\n * <a target=\"_blank\" href=\"http://www.apache.org/\">http://www.apache.org/</a>\n */\npublic class JclLogger implements Logger {\n\n    private final Log logger;\n\n    public JclLogger(Log logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 40,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java",
        "line": 92,
        "sink": "org.apache.commons.logging.Log.warn",
        "source": "-",
        "sourceLine": 92,
        "qualifier": "Call to org.apache.commons.logging.Log.warn with untrusted data from [msg : Object](1).\nCall to org.apache.commons.logging.Log.warn with untrusted data from [msg : Object](2).\nCall to org.apache.commons.logging.Log.warn with untrusted data from [msg : Object](3).",
        "line_number": 92,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 41
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 41
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 41
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 41
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java#L97",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jcl;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport org.apache.commons.logging.Log;\n\n/**\n * Adaptor to commons logging, depends on commons-logging.jar. For more information about commons logging, pls. refer to\n * <a target=\"_blank\" href=\"http://www.apache.org/\">http://www.apache.org/</a>\n */\npublic class JclLogger implements Logger {\n\n    private final Log logger;\n\n    public JclLogger(Log logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 42,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java",
        "line": 97,
        "sink": "org.apache.commons.logging.Log.error",
        "source": "-",
        "sourceLine": 97,
        "qualifier": "Call to org.apache.commons.logging.Log.error with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.commons.logging.Log.error with untrusted data from [msg : String](2).\nCall to org.apache.commons.logging.Log.error with untrusted data from [msg : Object](3).\nCall to org.apache.commons.logging.Log.error with untrusted data from [msg : Object](4).\nCall to org.apache.commons.logging.Log.error with untrusted data from [msg : Object](5).",
        "line_number": 97,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 43
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 43
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 43
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 43
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java#L107",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.jcl;\n\nimport org.apache.dubbo.common.logger.Logger;\n\nimport org.apache.commons.logging.Log;\n\n/**\n * Adaptor to commons logging, depends on commons-logging.jar. For more information about commons logging, pls. refer to\n * <a target=\"_blank\" href=\"http://www.apache.org/\">http://www.apache.org/</a>\n */\npublic class JclLogger implements Logger {\n\n    private final Log logger;\n\n    public JclLogger(Log logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 44,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/jcl/JclLogger.java",
        "line": 107,
        "sink": "org.apache.commons.logging.Log.error",
        "source": "-",
        "sourceLine": 107,
        "qualifier": "Call to org.apache.commons.logging.Log.error with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.commons.logging.Log.error with untrusted data from [msg : String](2).\nCall to org.apache.commons.logging.Log.error with untrusted data from [msg : Object](3).\nCall to org.apache.commons.logging.Log.error with untrusted data from [msg : Object](4).\nCall to org.apache.commons.logging.Log.error with untrusted data from [msg : Object](5).\nCall to org.apache.commons.logging.Log.error with untrusted data from [request : FullHttpRequest](6).\nCall to org.apache.commons.logging.Log.error with untrusted data from [msg : Http2StreamFrame](7).\nCall to org.apache.commons.logging.Log.error with untrusted data from [msg : Object](8).",
        "line_number": 107,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 45
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 45
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 45
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 45
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java#L51",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.apache.log4j.Level;\n\npublic class Log4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.apache.log4j.Logger logger;\n\n    public Log4jLogger(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(FQCN, Level.TRACE, msg, null);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(FQCN, Level.TRACE, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(FQCN, Level.TRACE, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(FQCN, Level.DEBUG, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(FQCN, Level.DEBUG, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(FQCN, Level.INFO, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(FQCN, Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(FQCN, Level.WARN, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(FQCN, Level.WARN, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(FQCN, Level.ERROR, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(FQCN, Level.ERROR, msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    // test purpose only\n    public org.apache.log4j.Logger getLogger() {\n        return logger;\n    }\n}\n",
        "methodName": null,
        "exampleID": 46,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java",
        "line": 51,
        "sink": "org.apache.log4j.Category.log",
        "source": "-",
        "sourceLine": 51,
        "qualifier": "Call to org.apache.log4j.Category.log with untrusted data from [getHeaderString(...) : String](1).",
        "line_number": 51,
        "steps": [
            {
                "line": 42,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/filter/TraceRequestAndResponseFilter.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/filter/TraceRequestAndResponseFilter.java",
                "methodName": null,
                "exampleID": 47
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java#L66",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.apache.log4j.Level;\n\npublic class Log4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.apache.log4j.Logger logger;\n\n    public Log4jLogger(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(FQCN, Level.TRACE, msg, null);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(FQCN, Level.TRACE, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(FQCN, Level.TRACE, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(FQCN, Level.DEBUG, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(FQCN, Level.DEBUG, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(FQCN, Level.INFO, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(FQCN, Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(FQCN, Level.WARN, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(FQCN, Level.WARN, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(FQCN, Level.ERROR, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(FQCN, Level.ERROR, msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    // test purpose only\n    public org.apache.log4j.Logger getLogger() {\n        return logger;\n    }\n}\n",
        "methodName": null,
        "exampleID": 48,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java",
        "line": 66,
        "sink": "org.apache.log4j.Category.log",
        "source": "-",
        "sourceLine": 66,
        "qualifier": "Call to org.apache.log4j.Category.log with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : String](2).",
        "line_number": 66,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 49
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 49
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 49
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 49
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java#L76",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.apache.log4j.Level;\n\npublic class Log4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.apache.log4j.Logger logger;\n\n    public Log4jLogger(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(FQCN, Level.TRACE, msg, null);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(FQCN, Level.TRACE, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(FQCN, Level.TRACE, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(FQCN, Level.DEBUG, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(FQCN, Level.DEBUG, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(FQCN, Level.INFO, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(FQCN, Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(FQCN, Level.WARN, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(FQCN, Level.WARN, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(FQCN, Level.ERROR, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(FQCN, Level.ERROR, msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    // test purpose only\n    public org.apache.log4j.Logger getLogger() {\n        return logger;\n    }\n}\n",
        "methodName": null,
        "exampleID": 50,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java",
        "line": 76,
        "sink": "org.apache.log4j.Category.log",
        "source": "-",
        "sourceLine": 76,
        "qualifier": "Call to org.apache.log4j.Category.log with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : String](2).",
        "line_number": 76,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 51
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 51
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 51
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 51
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java#L81",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.apache.log4j.Level;\n\npublic class Log4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.apache.log4j.Logger logger;\n\n    public Log4jLogger(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(FQCN, Level.TRACE, msg, null);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(FQCN, Level.TRACE, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(FQCN, Level.TRACE, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(FQCN, Level.DEBUG, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(FQCN, Level.DEBUG, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(FQCN, Level.INFO, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(FQCN, Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(FQCN, Level.WARN, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(FQCN, Level.WARN, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(FQCN, Level.ERROR, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(FQCN, Level.ERROR, msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    // test purpose only\n    public org.apache.log4j.Logger getLogger() {\n        return logger;\n    }\n}\n",
        "methodName": null,
        "exampleID": 52,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java",
        "line": 81,
        "sink": "org.apache.log4j.Category.log",
        "source": "-",
        "sourceLine": 81,
        "qualifier": "Call to org.apache.log4j.Category.log with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : String](2).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](3).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](4).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](5).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Http2StreamFrame](6).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](7).",
        "line_number": 81,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 53
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 53
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 53
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 53
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java#L91",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.apache.log4j.Level;\n\npublic class Log4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.apache.log4j.Logger logger;\n\n    public Log4jLogger(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(FQCN, Level.TRACE, msg, null);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(FQCN, Level.TRACE, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(FQCN, Level.TRACE, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(FQCN, Level.DEBUG, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(FQCN, Level.DEBUG, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(FQCN, Level.INFO, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(FQCN, Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(FQCN, Level.WARN, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(FQCN, Level.WARN, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(FQCN, Level.ERROR, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(FQCN, Level.ERROR, msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    // test purpose only\n    public org.apache.log4j.Logger getLogger() {\n        return logger;\n    }\n}\n",
        "methodName": null,
        "exampleID": 54,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java",
        "line": 91,
        "sink": "org.apache.log4j.Category.log",
        "source": "-",
        "sourceLine": 91,
        "qualifier": "Call to org.apache.log4j.Category.log with untrusted data from [msg : Object](1).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](2).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](3).",
        "line_number": 91,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 55
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 55
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 55
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 55
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java#L96",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.apache.log4j.Level;\n\npublic class Log4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.apache.log4j.Logger logger;\n\n    public Log4jLogger(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(FQCN, Level.TRACE, msg, null);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(FQCN, Level.TRACE, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(FQCN, Level.TRACE, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(FQCN, Level.DEBUG, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(FQCN, Level.DEBUG, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(FQCN, Level.INFO, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(FQCN, Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(FQCN, Level.WARN, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(FQCN, Level.WARN, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(FQCN, Level.ERROR, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(FQCN, Level.ERROR, msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    // test purpose only\n    public org.apache.log4j.Logger getLogger() {\n        return logger;\n    }\n}\n",
        "methodName": null,
        "exampleID": 56,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java",
        "line": 96,
        "sink": "org.apache.log4j.Category.log",
        "source": "-",
        "sourceLine": 96,
        "qualifier": "Call to org.apache.log4j.Category.log with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : String](2).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](3).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](4).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](5).",
        "line_number": 96,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 57
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 57
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 57
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 57
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java#L106",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.apache.log4j.Level;\n\npublic class Log4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.apache.log4j.Logger logger;\n\n    public Log4jLogger(org.apache.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.log(FQCN, Level.TRACE, msg, null);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.log(FQCN, Level.TRACE, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.log(FQCN, Level.TRACE, msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.log(FQCN, Level.DEBUG, msg, null);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.log(FQCN, Level.DEBUG, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.log(FQCN, Level.DEBUG, msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.log(FQCN, Level.INFO, msg, null);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.log(FQCN, Level.INFO, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.log(FQCN, Level.INFO, msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.log(FQCN, Level.WARN, msg, null);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.log(FQCN, Level.WARN, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.log(FQCN, Level.WARN, msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.log(FQCN, Level.ERROR, msg, null);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.log(FQCN, Level.ERROR, e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.log(FQCN, Level.ERROR, msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isEnabledFor(Level.WARN);\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isEnabledFor(Level.ERROR);\n    }\n\n    // test purpose only\n    public org.apache.log4j.Logger getLogger() {\n        return logger;\n    }\n}\n",
        "methodName": null,
        "exampleID": 58,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j/Log4jLogger.java",
        "line": 106,
        "sink": "org.apache.log4j.Category.log",
        "source": "-",
        "sourceLine": 106,
        "qualifier": "Call to org.apache.log4j.Category.log with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : String](2).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](3).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](4).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](5).\nCall to org.apache.log4j.Category.log with untrusted data from [request : FullHttpRequest](6).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Http2StreamFrame](7).\nCall to org.apache.log4j.Category.log with untrusted data from [msg : Object](8).",
        "line_number": 106,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 59
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 59
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 59
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 59
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java#L46",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j2;\n\nimport org.apache.dubbo.common.logger.Logger;\n\npublic class Log4j2Logger implements Logger {\n\n    private final org.apache.logging.log4j.Logger logger;\n\n    public Log4j2Logger(org.apache.logging.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 60,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java",
        "line": 46,
        "sink": "org.apache.logging.log4j.Logger.debug",
        "source": "-",
        "sourceLine": 46,
        "qualifier": "Call to org.apache.logging.log4j.Logger.debug with untrusted data from [getHeaderString(...) : String](1).",
        "line_number": 46,
        "steps": [
            {
                "line": 42,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/filter/TraceRequestAndResponseFilter.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/filter/TraceRequestAndResponseFilter.java",
                "methodName": null,
                "exampleID": 61
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java#L61",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j2;\n\nimport org.apache.dubbo.common.logger.Logger;\n\npublic class Log4j2Logger implements Logger {\n\n    private final org.apache.logging.log4j.Logger logger;\n\n    public Log4j2Logger(org.apache.logging.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 62,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java",
        "line": 61,
        "sink": "org.apache.logging.log4j.Logger.info",
        "source": "-",
        "sourceLine": 61,
        "qualifier": "Call to org.apache.logging.log4j.Logger.info with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.logging.log4j.Logger.info with untrusted data from [msg : String](2).",
        "line_number": 61,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 63
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 63
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 63
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 63
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java#L71",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j2;\n\nimport org.apache.dubbo.common.logger.Logger;\n\npublic class Log4j2Logger implements Logger {\n\n    private final org.apache.logging.log4j.Logger logger;\n\n    public Log4j2Logger(org.apache.logging.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 64,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java",
        "line": 71,
        "sink": "org.apache.logging.log4j.Logger.info",
        "source": "-",
        "sourceLine": 71,
        "qualifier": "Call to org.apache.logging.log4j.Logger.info with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.logging.log4j.Logger.info with untrusted data from [msg : String](2).",
        "line_number": 71,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 65
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 65
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 65
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 65
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java#L76",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j2;\n\nimport org.apache.dubbo.common.logger.Logger;\n\npublic class Log4j2Logger implements Logger {\n\n    private final org.apache.logging.log4j.Logger logger;\n\n    public Log4j2Logger(org.apache.logging.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 66,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java",
        "line": 76,
        "sink": "org.apache.logging.log4j.Logger.warn",
        "source": "-",
        "sourceLine": 76,
        "qualifier": "Call to org.apache.logging.log4j.Logger.warn with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.logging.log4j.Logger.warn with untrusted data from [msg : String](2).\nCall to org.apache.logging.log4j.Logger.warn with untrusted data from [msg : Object](3).\nCall to org.apache.logging.log4j.Logger.warn with untrusted data from [msg : Object](4).\nCall to org.apache.logging.log4j.Logger.warn with untrusted data from [msg : Object](5).\nCall to org.apache.logging.log4j.Logger.warn with untrusted data from [msg : Http2StreamFrame](6).\nCall to org.apache.logging.log4j.Logger.warn with untrusted data from [msg : Object](7).",
        "line_number": 76,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 67
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 67
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 67
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 67
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java#L86",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j2;\n\nimport org.apache.dubbo.common.logger.Logger;\n\npublic class Log4j2Logger implements Logger {\n\n    private final org.apache.logging.log4j.Logger logger;\n\n    public Log4j2Logger(org.apache.logging.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 68,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java",
        "line": 86,
        "sink": "org.apache.logging.log4j.Logger.warn",
        "source": "-",
        "sourceLine": 86,
        "qualifier": "Call to org.apache.logging.log4j.Logger.warn with untrusted data from [msg : Object](1).\nCall to org.apache.logging.log4j.Logger.warn with untrusted data from [msg : Object](2).\nCall to org.apache.logging.log4j.Logger.warn with untrusted data from [msg : Object](3).",
        "line_number": 86,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 69
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 69
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 69
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 69
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java#L91",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j2;\n\nimport org.apache.dubbo.common.logger.Logger;\n\npublic class Log4j2Logger implements Logger {\n\n    private final org.apache.logging.log4j.Logger logger;\n\n    public Log4j2Logger(org.apache.logging.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 70,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java",
        "line": 91,
        "sink": "org.apache.logging.log4j.Logger.error",
        "source": "-",
        "sourceLine": 91,
        "qualifier": "Call to org.apache.logging.log4j.Logger.error with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.logging.log4j.Logger.error with untrusted data from [msg : String](2).\nCall to org.apache.logging.log4j.Logger.error with untrusted data from [msg : Object](3).\nCall to org.apache.logging.log4j.Logger.error with untrusted data from [msg : Object](4).\nCall to org.apache.logging.log4j.Logger.error with untrusted data from [msg : Object](5).",
        "line_number": 91,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 71
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 71
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 71
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 71
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java#L101",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.log4j2;\n\nimport org.apache.dubbo.common.logger.Logger;\n\npublic class Log4j2Logger implements Logger {\n\n    private final org.apache.logging.log4j.Logger logger;\n\n    public Log4j2Logger(org.apache.logging.log4j.Logger logger) {\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        logger.trace(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        logger.debug(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        logger.info(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        logger.warn(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        logger.error(e == null ? null : e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n}\n",
        "methodName": null,
        "exampleID": 72,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/log4j2/Log4j2Logger.java",
        "line": 101,
        "sink": "org.apache.logging.log4j.Logger.error",
        "source": "-",
        "sourceLine": 101,
        "qualifier": "Call to org.apache.logging.log4j.Logger.error with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.logging.log4j.Logger.error with untrusted data from [msg : String](2).\nCall to org.apache.logging.log4j.Logger.error with untrusted data from [msg : Object](3).\nCall to org.apache.logging.log4j.Logger.error with untrusted data from [msg : Object](4).\nCall to org.apache.logging.log4j.Logger.error with untrusted data from [msg : Object](5).\nCall to org.apache.logging.log4j.Logger.error with untrusted data from [request : FullHttpRequest](6).\nCall to org.apache.logging.log4j.Logger.error with untrusted data from [msg : Http2StreamFrame](7).\nCall to org.apache.logging.log4j.Logger.error with untrusted data from [msg : Object](8).",
        "line_number": 101,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 73
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 73
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 73
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 73
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L72",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 74,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 72,
        "sink": "org.slf4j.spi.LocationAwareLogger.log",
        "source": "-",
        "sourceLine": 72,
        "qualifier": "Call to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [getHeaderString(...) : String](1).",
        "line_number": 72,
        "steps": [
            {
                "line": 42,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/filter/TraceRequestAndResponseFilter.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/filter/TraceRequestAndResponseFilter.java",
                "methodName": null,
                "exampleID": 75
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L75",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 76,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 75,
        "sink": "org.slf4j.Logger.debug",
        "source": "-",
        "sourceLine": 75,
        "qualifier": "Call to org.slf4j.Logger.debug with untrusted data from [getHeaderString(...) : String](1).",
        "line_number": 75,
        "steps": [
            {
                "line": 42,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/filter/TraceRequestAndResponseFilter.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/test/java/org/apache/dubbo/rpc/protocol/rest/filter/TraceRequestAndResponseFilter.java",
                "methodName": null,
                "exampleID": 77
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L99",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 78,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 99,
        "sink": "org.slf4j.spi.LocationAwareLogger.log",
        "source": "-",
        "sourceLine": 99,
        "qualifier": "Call to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : HttpRequest](1).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : String](2).",
        "line_number": 99,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 79
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 79
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 79
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 79
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L102",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 80,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 102,
        "sink": "org.slf4j.Logger.info",
        "source": "-",
        "sourceLine": 102,
        "qualifier": "Call to org.slf4j.Logger.info with untrusted data from [msg : HttpRequest](1).\nCall to org.slf4j.Logger.info with untrusted data from [msg : String](2).",
        "line_number": 102,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 81
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 81
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 81
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 81
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L117",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 82,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 117,
        "sink": "org.slf4j.spi.LocationAwareLogger.log",
        "source": "-",
        "sourceLine": 117,
        "qualifier": "Call to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : HttpRequest](1).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : String](2).",
        "line_number": 117,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 83
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 83
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 83
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 83
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L120",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 84,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 120,
        "sink": "org.slf4j.Logger.info",
        "source": "-",
        "sourceLine": 120,
        "qualifier": "Call to org.slf4j.Logger.info with untrusted data from [msg : HttpRequest](1).\nCall to org.slf4j.Logger.info with untrusted data from [msg : String](2).",
        "line_number": 120,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 85
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 85
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 85
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 85
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L126",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 86,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 126,
        "sink": "org.slf4j.spi.LocationAwareLogger.log",
        "source": "-",
        "sourceLine": 126,
        "qualifier": "Call to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : HttpRequest](1).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : String](2).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](3).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](4).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](5).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Http2StreamFrame](6).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](7).",
        "line_number": 126,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 87
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 87
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 87
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 87
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L129",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 88,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 129,
        "sink": "org.slf4j.Logger.warn",
        "source": "-",
        "sourceLine": 129,
        "qualifier": "Call to org.slf4j.Logger.warn with untrusted data from [msg : HttpRequest](1).\nCall to org.slf4j.Logger.warn with untrusted data from [msg : String](2).\nCall to org.slf4j.Logger.warn with untrusted data from [msg : Object](3).\nCall to org.slf4j.Logger.warn with untrusted data from [msg : Object](4).\nCall to org.slf4j.Logger.warn with untrusted data from [msg : Object](5).\nCall to org.slf4j.Logger.warn with untrusted data from [msg : Http2StreamFrame](6).\nCall to org.slf4j.Logger.warn with untrusted data from [msg : Object](7).",
        "line_number": 129,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 89
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 89
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 89
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 89
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L144",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 90,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 144,
        "sink": "org.slf4j.spi.LocationAwareLogger.log",
        "source": "-",
        "sourceLine": 144,
        "qualifier": "Call to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](1).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](2).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](3).",
        "line_number": 144,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 91
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 91
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 91
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 91
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L147",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 92,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 147,
        "sink": "org.slf4j.Logger.warn",
        "source": "-",
        "sourceLine": 147,
        "qualifier": "Call to org.slf4j.Logger.warn with untrusted data from [msg : Object](1).\nCall to org.slf4j.Logger.warn with untrusted data from [msg : Object](2).\nCall to org.slf4j.Logger.warn with untrusted data from [msg : Object](3).",
        "line_number": 147,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 93
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 93
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 93
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 93
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L153",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 94,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 153,
        "sink": "org.slf4j.spi.LocationAwareLogger.log",
        "source": "-",
        "sourceLine": 153,
        "qualifier": "Call to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : HttpRequest](1).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : String](2).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](3).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](4).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](5).",
        "line_number": 153,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 95
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 95
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 95
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 95
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L156",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 96,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 156,
        "sink": "org.slf4j.Logger.error",
        "source": "-",
        "sourceLine": 156,
        "qualifier": "Call to org.slf4j.Logger.error with untrusted data from [msg : HttpRequest](1).\nCall to org.slf4j.Logger.error with untrusted data from [msg : String](2).\nCall to org.slf4j.Logger.error with untrusted data from [msg : Object](3).\nCall to org.slf4j.Logger.error with untrusted data from [msg : Object](4).\nCall to org.slf4j.Logger.error with untrusted data from [msg : Object](5).",
        "line_number": 156,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 97
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 97
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 97
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 97
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L171",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 98,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 171,
        "sink": "org.slf4j.spi.LocationAwareLogger.log",
        "source": "-",
        "sourceLine": 171,
        "qualifier": "Call to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : HttpRequest](1).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : String](2).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](3).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](4).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](5).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [request : FullHttpRequest](6).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Http2StreamFrame](7).\nCall to org.slf4j.spi.LocationAwareLogger.log with untrusted data from [msg : Object](8).",
        "line_number": 171,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 99
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 99
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 99
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 99
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java#L174",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger.slf4j;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\n\nimport org.slf4j.spi.LocationAwareLogger;\n\npublic class Slf4jLogger implements Logger {\n\n    private static final String FQCN = FailsafeLogger.class.getName();\n\n    private final org.slf4j.Logger logger;\n\n    private final LocationAwareLogger locationAwareLogger;\n\n    public Slf4jLogger(org.slf4j.Logger logger) {\n        if (logger instanceof LocationAwareLogger) {\n            locationAwareLogger = (LocationAwareLogger) logger;\n        } else {\n            locationAwareLogger = null;\n        }\n        this.logger = logger;\n    }\n\n    @Override\n    public void trace(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, null);\n            return;\n        }\n        logger.trace(msg);\n    }\n\n    @Override\n    public void trace(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.trace(e.getMessage(), e);\n    }\n\n    @Override\n    public void trace(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.TRACE_INT, msg, null, e);\n            return;\n        }\n        logger.trace(msg, e);\n    }\n\n    @Override\n    public void debug(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, null);\n            return;\n        }\n        logger.debug(msg);\n    }\n\n    @Override\n    public void debug(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.debug(e.getMessage(), e);\n    }\n\n    @Override\n    public void debug(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.DEBUG_INT, msg, null, e);\n            return;\n        }\n        logger.debug(msg, e);\n    }\n\n    @Override\n    public void info(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, null);\n            return;\n        }\n        logger.info(msg);\n    }\n\n    @Override\n    public void info(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.info(e.getMessage(), e);\n    }\n\n    @Override\n    public void info(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.INFO_INT, msg, null, e);\n            return;\n        }\n        logger.info(msg, e);\n    }\n\n    @Override\n    public void warn(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, null);\n            return;\n        }\n        logger.warn(msg);\n    }\n\n    @Override\n    public void warn(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.warn(e.getMessage(), e);\n    }\n\n    @Override\n    public void warn(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.WARN_INT, msg, null, e);\n            return;\n        }\n        logger.warn(msg, e);\n    }\n\n    @Override\n    public void error(String msg) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, null);\n            return;\n        }\n        logger.error(msg);\n    }\n\n    @Override\n    public void error(Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, e.getMessage(), null, e);\n            return;\n        }\n        logger.error(e.getMessage(), e);\n    }\n\n    @Override\n    public void error(String msg, Throwable e) {\n        if (locationAwareLogger != null) {\n            locationAwareLogger.log(null, FQCN, LocationAwareLogger.ERROR_INT, msg, null, e);\n            return;\n        }\n        logger.error(msg, e);\n    }\n\n    @Override\n    public boolean isTraceEnabled() {\n        return logger.isTraceEnabled();\n    }\n\n    @Override\n    public boolean isDebugEnabled() {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled() {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled() {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled() {\n        return logger.isErrorEnabled();\n    }\n\n    public static Level getLevel(org.slf4j.Logger logger) {\n        if (logger.isTraceEnabled()) {\n            return Level.TRACE;\n        }\n        if (logger.isDebugEnabled()) {\n            return Level.DEBUG;\n        }\n        if (logger.isInfoEnabled()) {\n            return Level.INFO;\n        }\n        if (logger.isWarnEnabled()) {\n            return Level.WARN;\n        }\n        if (logger.isErrorEnabled()) {\n            return Level.ERROR;\n        }\n        return Level.OFF;\n    }\n\n    public Level getLevel() {\n        return getLevel(logger);\n    }\n}\n",
        "methodName": null,
        "exampleID": 100,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/slf4j/Slf4jLogger.java",
        "line": 174,
        "sink": "org.slf4j.Logger.error",
        "source": "-",
        "sourceLine": 174,
        "qualifier": "Call to org.slf4j.Logger.error with untrusted data from [msg : HttpRequest](1).\nCall to org.slf4j.Logger.error with untrusted data from [msg : String](2).\nCall to org.slf4j.Logger.error with untrusted data from [msg : Object](3).\nCall to org.slf4j.Logger.error with untrusted data from [msg : Object](4).\nCall to org.slf4j.Logger.error with untrusted data from [msg : Object](5).\nCall to org.slf4j.Logger.error with untrusted data from [request : FullHttpRequest](6).\nCall to org.slf4j.Logger.error with untrusted data from [msg : Http2StreamFrame](7).\nCall to org.slf4j.Logger.error with untrusted data from [msg : Object](8).",
        "line_number": 174,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 101
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 101
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 101
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 101
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/profiler/ProfilerSwitch.java#L61",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.profiler;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n * TODO\n */\npublic class ProfilerSwitch {\n    private static final AtomicBoolean enableDetailProfiler = new AtomicBoolean(false);\n\n    private static final AtomicBoolean enableSimpleProfiler = new AtomicBoolean(true);\n\n    private static final AtomicReference<Double> warnPercent = new AtomicReference<>(0.75);\n\n    public static void enableSimpleProfiler() {\n        enableSimpleProfiler.set(true);\n    }\n\n    public static void disableSimpleProfiler() {\n        enableSimpleProfiler.set(false);\n    }\n\n    public static void enableDetailProfiler() {\n        enableDetailProfiler.set(true);\n    }\n\n    public static void disableDetailProfiler() {\n        enableDetailProfiler.set(false);\n    }\n\n    public static boolean isEnableDetailProfiler() {\n        return enableDetailProfiler.get() && enableSimpleProfiler.get();\n    }\n\n    public static boolean isEnableSimpleProfiler() {\n        return enableSimpleProfiler.get();\n    }\n\n    public static double getWarnPercent() {\n        return warnPercent.get();\n    }\n\n    public static void setWarnPercent(double percent) {\n        warnPercent.set(percent);\n    }\n}\n",
        "methodName": null,
        "exampleID": 102,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/profiler/ProfilerSwitch.java",
        "line": 61,
        "sink": "java.util.concurrent.atomic.AtomicReference<Double>.set",
        "source": "-",
        "sourceLine": 61,
        "qualifier": "Call to java.util.concurrent.atomic.AtomicReference<Double>.set with untrusted data from [msg : HttpRequest](1).\nCall to java.util.concurrent.atomic.AtomicReference<Double>.set with untrusted data from [msg : String](2).",
        "line_number": 61,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 103
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 103
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 103
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 103
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/logger/LoggerFactory.java#L125",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.logger;\n\nimport org.apache.dubbo.common.logger.jcl.JclLoggerAdapter;\nimport org.apache.dubbo.common.logger.jdk.JdkLoggerAdapter;\nimport org.apache.dubbo.common.logger.log4j.Log4jLoggerAdapter;\nimport org.apache.dubbo.common.logger.log4j2.Log4j2LoggerAdapter;\nimport org.apache.dubbo.common.logger.slf4j.Slf4jLoggerAdapter;\nimport org.apache.dubbo.common.logger.support.FailsafeErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.support.FailsafeLogger;\nimport org.apache.dubbo.common.utils.ConcurrentHashMapUtils;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * Logger factory\n */\npublic class LoggerFactory {\n\n    private static final ConcurrentMap<String, FailsafeLogger> LOGGERS = new ConcurrentHashMap<>();\n    private static final ConcurrentMap<String, FailsafeErrorTypeAwareLogger> ERROR_TYPE_AWARE_LOGGERS =\n            new ConcurrentHashMap<>();\n    private static volatile LoggerAdapter loggerAdapter;\n\n    // search common-used logging frameworks\n    static {\n        String logger = System.getProperty(\"dubbo.application.logger\", \"\");\n        switch (logger) {\n            case Slf4jLoggerAdapter.NAME:\n                setLoggerAdapter(new Slf4jLoggerAdapter());\n                break;\n            case JclLoggerAdapter.NAME:\n                setLoggerAdapter(new JclLoggerAdapter());\n                break;\n            case Log4jLoggerAdapter.NAME:\n                setLoggerAdapter(new Log4jLoggerAdapter());\n                break;\n            case JdkLoggerAdapter.NAME:\n                setLoggerAdapter(new JdkLoggerAdapter());\n                break;\n            case Log4j2LoggerAdapter.NAME:\n                setLoggerAdapter(new Log4j2LoggerAdapter());\n                break;\n            default:\n                List<Class<? extends LoggerAdapter>> candidates = Arrays.asList(\n                        Log4jLoggerAdapter.class,\n                        Slf4jLoggerAdapter.class,\n                        Log4j2LoggerAdapter.class,\n                        JclLoggerAdapter.class,\n                        JdkLoggerAdapter.class);\n                boolean found = false;\n                // try to use the first available adapter\n                for (Class<? extends LoggerAdapter> clazz : candidates) {\n                    try {\n                        LoggerAdapter loggerAdapter =\n                                clazz.getDeclaredConstructor().newInstance();\n                        loggerAdapter.getLogger(LoggerFactory.class);\n                        if (loggerAdapter.isConfigured()) {\n                            setLoggerAdapter(loggerAdapter);\n                            found = true;\n                            break;\n                        }\n                    } catch (Exception | LinkageError ignored) {\n                        // ignore\n                    }\n                }\n                if (found) {\n                    break;\n                }\n\n                System.err.println(\"Dubbo: Unable to find a proper configured logger to log out.\");\n                for (Class<? extends LoggerAdapter> clazz : candidates) {\n                    try {\n                        LoggerAdapter loggerAdapter =\n                                clazz.getDeclaredConstructor().newInstance();\n                        loggerAdapter.getLogger(LoggerFactory.class);\n                        setLoggerAdapter(loggerAdapter);\n                        found = true;\n                        break;\n                    } catch (Throwable ignored) {\n                        // ignore\n                    }\n                }\n                if (found) {\n                    System.err.println(\n                            \"Dubbo: Using default logger: \"\n                                    + loggerAdapter.getClass().getName() + \". \"\n                                    + \"If you cannot see any log, please configure -Ddubbo.application.logger property to your preferred logging framework.\");\n                } else {\n                    System.err.println(\n                            \"Dubbo: Unable to find any available logger adapter to log out. Dubbo logs will be ignored. \"\n                                    + \"Please configure -Ddubbo.application.logger property and add corresponding logging library to classpath.\");\n                }\n        }\n    }\n\n    private LoggerFactory() {}\n\n    public static void setLoggerAdapter(FrameworkModel frameworkModel, String loggerAdapter) {\n        if (loggerAdapter != null && loggerAdapter.length() > 0) {\n            setLoggerAdapter(\n                    frameworkModel.getExtensionLoader(LoggerAdapter.class).getExtension(loggerAdapter));\n        }\n    }\n\n    /**\n     * Set logger provider\n     *\n     * @param loggerAdapter logger provider\n     */\n    public static void setLoggerAdapter(LoggerAdapter loggerAdapter) {\n        if (loggerAdapter != null) {\n            if (loggerAdapter == LoggerFactory.loggerAdapter) {\n                return;\n            }\n            loggerAdapter.getLogger(LoggerFactory.class.getName());\n            LoggerFactory.loggerAdapter = loggerAdapter;\n            for (Map.Entry<String, FailsafeLogger> entry : LOGGERS.entrySet()) {\n                entry.getValue().setLogger(LoggerFactory.loggerAdapter.getLogger(entry.getKey()));\n            }\n        }\n    }\n\n    /**\n     * Get logger provider\n     *\n     * @param key the returned logger will be named after clazz\n     * @return logger\n     */\n    public static Logger getLogger(Class<?> key) {\n        return ConcurrentHashMapUtils.computeIfAbsent(\n                LOGGERS, key.getName(), name -> new FailsafeLogger(loggerAdapter.getLogger(name)));\n    }\n\n    /**\n     * Get logger provider\n     *\n     * @param key the returned logger will be named after key\n     * @return logger provider\n     */\n    public static Logger getLogger(String key) {\n        return ConcurrentHashMapUtils.computeIfAbsent(\n                LOGGERS, key, k -> new FailsafeLogger(loggerAdapter.getLogger(k)));\n    }\n\n    /**\n     * Get error type aware logger by Class object.\n     *\n     * @param key the returned logger will be named after clazz\n     * @return error type aware logger\n     */\n    public static ErrorTypeAwareLogger getErrorTypeAwareLogger(Class<?> key) {\n        return ConcurrentHashMapUtils.computeIfAbsent(\n                ERROR_TYPE_AWARE_LOGGERS,\n                key.getName(),\n                name -> new FailsafeErrorTypeAwareLogger(loggerAdapter.getLogger(name)));\n    }\n\n    /**\n     * Get error type aware logger by a String key.\n     *\n     * @param key the returned logger will be named after key\n     * @return error type aware logger\n     */\n    public static ErrorTypeAwareLogger getErrorTypeAwareLogger(String key) {\n        return ConcurrentHashMapUtils.computeIfAbsent(\n                ERROR_TYPE_AWARE_LOGGERS, key, k -> new FailsafeErrorTypeAwareLogger(loggerAdapter.getLogger(k)));\n    }\n\n    /**\n     * Get logging level\n     *\n     * @return logging level\n     */\n    public static Level getLevel() {\n        return loggerAdapter.getLevel();\n    }\n\n    /**\n     * Set the current logging level\n     *\n     * @param level logging level\n     */\n    public static void setLevel(Level level) {\n        loggerAdapter.setLevel(level);\n    }\n\n    /**\n     * Get the current logging file\n     *\n     * @return current logging file\n     */\n    public static File getFile() {\n        return loggerAdapter.getFile();\n    }\n\n    /**\n     * Get the available adapter names\n     *\n     * @return available adapter names\n     */\n    public static List<String> getAvailableAdapter() {\n        Map<Class<? extends LoggerAdapter>, String> candidates = new HashMap<>();\n        candidates.put(Log4jLoggerAdapter.class, \"log4j\");\n        candidates.put(Slf4jLoggerAdapter.class, \"slf4j\");\n        candidates.put(Log4j2LoggerAdapter.class, \"log4j2\");\n        candidates.put(JclLoggerAdapter.class, \"jcl\");\n        candidates.put(JdkLoggerAdapter.class, \"jdk\");\n        List<String> result = new LinkedList<>();\n        for (Map.Entry<Class<? extends LoggerAdapter>, String> entry : candidates.entrySet()) {\n            try {\n                LoggerAdapter loggerAdapter =\n                        entry.getKey().getDeclaredConstructor().newInstance();\n                loggerAdapter.getLogger(LoggerFactory.class);\n                result.add(entry.getValue());\n            } catch (Exception ignored) {\n                // ignored\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the current adapter name\n     *\n     * @return current adapter name\n     */\n    public static String getCurrentAdapter() {\n        Map<Class<? extends LoggerAdapter>, String> candidates = new HashMap<>();\n        candidates.put(Log4jLoggerAdapter.class, \"log4j\");\n        candidates.put(Slf4jLoggerAdapter.class, \"slf4j\");\n        candidates.put(Log4j2LoggerAdapter.class, \"log4j2\");\n        candidates.put(JclLoggerAdapter.class, \"jcl\");\n        candidates.put(JdkLoggerAdapter.class, \"jdk\");\n\n        String name = candidates.get(loggerAdapter.getClass());\n        if (name == null) {\n            name = loggerAdapter.getClass().getSimpleName();\n        }\n        return name;\n    }\n}\n",
        "methodName": null,
        "exampleID": 104,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/logger/LoggerFactory.java",
        "line": 125,
        "sink": "org.apache.dubbo.common.extension.ExtensionLoader<LoggerAdapter>.getExtension",
        "source": "-",
        "sourceLine": 125,
        "qualifier": "Call to org.apache.dubbo.common.extension.ExtensionLoader<LoggerAdapter>.getExtension with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.dubbo.common.extension.ExtensionLoader<LoggerAdapter>.getExtension with untrusted data from [msg : String](2).",
        "line_number": 125,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 105
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 105
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 105
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 105
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java#L750",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.extension;\n\nimport org.apache.dubbo.common.Extension;\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.beans.support.InstantiationStrategy;\nimport org.apache.dubbo.common.compact.Dubbo2ActivateUtils;\nimport org.apache.dubbo.common.compact.Dubbo2CompactUtils;\nimport org.apache.dubbo.common.context.Lifecycle;\nimport org.apache.dubbo.common.extension.support.ActivateComparator;\nimport org.apache.dubbo.common.extension.support.WrapperComparator;\nimport org.apache.dubbo.common.lang.Prioritized;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.resource.Disposable;\nimport org.apache.dubbo.common.utils.ArrayUtils;\nimport org.apache.dubbo.common.utils.ClassLoaderResourceLoader;\nimport org.apache.dubbo.common.utils.ClassUtils;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.common.utils.ConcurrentHashSet;\nimport org.apache.dubbo.common.utils.ConfigUtils;\nimport org.apache.dubbo.common.utils.Holder;\nimport org.apache.dubbo.common.utils.NativeUtils;\nimport org.apache.dubbo.common.utils.ReflectUtils;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.model.ModuleModel;\nimport org.apache.dubbo.rpc.model.ScopeModel;\nimport org.apache.dubbo.rpc.model.ScopeModelAccessor;\nimport org.apache.dubbo.rpc.model.ScopeModelAware;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.lang.annotation.Annotation;\nimport java.lang.ref.SoftReference;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.ServiceLoader;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport static java.util.Arrays.asList;\nimport static java.util.ServiceLoader.load;\nimport static java.util.stream.StreamSupport.stream;\nimport static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;\nimport static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_KEY;\nimport static org.apache.dubbo.common.constants.CommonConstants.REMOVE_VALUE_PREFIX;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_ERROR_LOAD_EXTENSION;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_FAILED_LOAD_ENV_VARIABLE;\n\n/**\n * {@link org.apache.dubbo.rpc.model.ApplicationModel}, {@code DubboBootstrap} and this class are\n * at present designed to be singleton or static (by itself totally static or uses some static fields).\n * So the instances returned from them are of process or classloader scope. If you want to support\n * multiple dubbo servers in a single process, you may need to refactor these three classes.\n * <p>\n * Load dubbo extensions\n * <ul>\n * <li>auto inject dependency extension </li>\n * <li>auto wrap extension in wrapper </li>\n * <li>default extension is an adaptive instance</li>\n * </ul>\n *\n * @see <a href=\"http://java.sun.com/j2se/1.5.0/docs/guide/jar/jar.html#Service%20Provider\">Service Provider in Java 5</a>\n * @see org.apache.dubbo.common.extension.SPI\n * @see org.apache.dubbo.common.extension.Adaptive\n * @see org.apache.dubbo.common.extension.Activate\n */\npublic class ExtensionLoader<T> {\n\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(ExtensionLoader.class);\n\n    private static final Pattern NAME_SEPARATOR = Pattern.compile(\"\\\\s*[,]+\\\\s*\");\n    private static final String SPECIAL_SPI_PROPERTIES = \"special_spi.properties\";\n\n    private final ConcurrentMap<Class<?>, Object> extensionInstances = new ConcurrentHashMap<>(64);\n\n    private final Class<?> type;\n\n    private final ExtensionInjector injector;\n\n    private final ConcurrentMap<Class<?>, String> cachedNames = new ConcurrentHashMap<>();\n\n    private final Holder<Map<String, Class<?>>> cachedClasses = new Holder<>();\n\n    private final Map<String, Object> cachedActivates = Collections.synchronizedMap(new LinkedHashMap<>());\n    private final Map<String, Set<String>> cachedActivateGroups = Collections.synchronizedMap(new LinkedHashMap<>());\n    private final Map<String, String[][]> cachedActivateValues = Collections.synchronizedMap(new LinkedHashMap<>());\n    private final ConcurrentMap<String, Holder<Object>> cachedInstances = new ConcurrentHashMap<>();\n    private final Holder<Object> cachedAdaptiveInstance = new Holder<>();\n    private volatile Class<?> cachedAdaptiveClass = null;\n    private String cachedDefaultName;\n    private volatile Throwable createAdaptiveInstanceError;\n\n    private Set<Class<?>> cachedWrapperClasses;\n\n    private final Map<String, IllegalStateException> exceptions = new ConcurrentHashMap<>();\n\n    private static volatile LoadingStrategy[] strategies = loadLoadingStrategies();\n\n    private static final Map<String, String> specialSPILoadingStrategyMap = getSpecialSPILoadingStrategyMap();\n\n    private static SoftReference<Map<java.net.URL, List<String>>> urlListMapCache =\n            new SoftReference<>(new ConcurrentHashMap<>());\n\n    private static final List<String> ignoredInjectMethodsDesc = getIgnoredInjectMethodsDesc();\n\n    /**\n     * Record all unacceptable exceptions when using SPI\n     */\n    private final Set<String> unacceptableExceptions = new ConcurrentHashSet<>();\n\n    private final ExtensionDirector extensionDirector;\n    private final List<ExtensionPostProcessor> extensionPostProcessors;\n    private InstantiationStrategy instantiationStrategy;\n    private final ActivateComparator activateComparator;\n    private final ScopeModel scopeModel;\n    private final AtomicBoolean destroyed = new AtomicBoolean();\n\n    public static void setLoadingStrategies(LoadingStrategy... strategies) {\n        if (ArrayUtils.isNotEmpty(strategies)) {\n            ExtensionLoader.strategies = strategies;\n        }\n    }\n\n    /**\n     * Load all {@link Prioritized prioritized} {@link LoadingStrategy Loading Strategies} via {@link ServiceLoader}\n     *\n     * @return non-null\n     * @since 2.7.7\n     */\n    private static LoadingStrategy[] loadLoadingStrategies() {\n        return stream(load(LoadingStrategy.class).spliterator(), false).sorted().toArray(LoadingStrategy[]::new);\n    }\n\n    /**\n     * some spi are implements by dubbo framework only and scan multi classloaders resources may cause\n     * application startup very slow\n     *\n     * @return\n     */\n    private static Map<String, String> getSpecialSPILoadingStrategyMap() {\n        Map map = new ConcurrentHashMap<>();\n        Properties properties = loadProperties(ExtensionLoader.class.getClassLoader(), SPECIAL_SPI_PROPERTIES);\n        map.putAll(properties);\n        return map;\n    }\n\n    /**\n     * Get all {@link LoadingStrategy Loading Strategies}\n     *\n     * @return non-null\n     * @see LoadingStrategy\n     * @see Prioritized\n     * @since 2.7.7\n     */\n    public static List<LoadingStrategy> getLoadingStrategies() {\n        return asList(strategies);\n    }\n\n    private static List<String> getIgnoredInjectMethodsDesc() {\n        List<String> ignoreInjectMethodsDesc = new ArrayList<>();\n        Arrays.stream(ScopeModelAware.class.getMethods())\n                .map(ReflectUtils::getDesc)\n                .forEach(ignoreInjectMethodsDesc::add);\n        Arrays.stream(ExtensionAccessorAware.class.getMethods())\n                .map(ReflectUtils::getDesc)\n                .forEach(ignoreInjectMethodsDesc::add);\n        return ignoreInjectMethodsDesc;\n    }\n\n    ExtensionLoader(Class<?> type, ExtensionDirector extensionDirector, ScopeModel scopeModel) {\n        this.type = type;\n        this.extensionDirector = extensionDirector;\n        this.extensionPostProcessors = extensionDirector.getExtensionPostProcessors();\n        initInstantiationStrategy();\n        this.injector = (type == ExtensionInjector.class\n                ? null\n                : extensionDirector.getExtensionLoader(ExtensionInjector.class).getAdaptiveExtension());\n        this.activateComparator = new ActivateComparator(extensionDirector);\n        this.scopeModel = scopeModel;\n    }\n\n    private void initInstantiationStrategy() {\n        instantiationStrategy = extensionPostProcessors.stream()\n                .filter(extensionPostProcessor -> extensionPostProcessor instanceof ScopeModelAccessor)\n                .map(extensionPostProcessor -> new InstantiationStrategy((ScopeModelAccessor) extensionPostProcessor))\n                .findFirst()\n                .orElse(new InstantiationStrategy());\n    }\n\n    /**\n     * @see ApplicationModel#getExtensionDirector()\n     * @see FrameworkModel#getExtensionDirector()\n     * @see ModuleModel#getExtensionDirector()\n     * @see ExtensionDirector#getExtensionLoader(java.lang.Class)\n     * @deprecated get extension loader from extension director of some module.\n     */\n    @Deprecated\n    public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {\n        return ApplicationModel.defaultModel().getDefaultModule().getExtensionLoader(type);\n    }\n\n    @Deprecated\n    public static void resetExtensionLoader(Class type) {}\n\n    public void destroy() {\n        if (!destroyed.compareAndSet(false, true)) {\n            return;\n        }\n        // destroy raw extension instance\n        extensionInstances.forEach((type, instance) -> {\n            if (instance instanceof Disposable) {\n                Disposable disposable = (Disposable) instance;\n                try {\n                    disposable.destroy();\n                } catch (Exception e) {\n                    logger.error(COMMON_ERROR_LOAD_EXTENSION, \"\", \"\", \"Error destroying extension \" + disposable, e);\n                }\n            }\n        });\n        extensionInstances.clear();\n\n        // destroy wrapped extension instance\n        for (Holder<Object> holder : cachedInstances.values()) {\n            Object wrappedInstance = holder.get();\n            if (wrappedInstance instanceof Disposable) {\n                Disposable disposable = (Disposable) wrappedInstance;\n                try {\n                    disposable.destroy();\n                } catch (Exception e) {\n                    logger.error(COMMON_ERROR_LOAD_EXTENSION, \"\", \"\", \"Error destroying extension \" + disposable, e);\n                }\n            }\n        }\n        cachedInstances.clear();\n    }\n\n    private void checkDestroyed() {\n        if (destroyed.get()) {\n            throw new IllegalStateException(\"ExtensionLoader is destroyed: \" + type);\n        }\n    }\n\n    public String getExtensionName(T extensionInstance) {\n        return getExtensionName(extensionInstance.getClass());\n    }\n\n    public String getExtensionName(Class<?> extensionClass) {\n        getExtensionClasses(); // load class\n        return cachedNames.get(extensionClass);\n    }\n\n    /**\n     * This is equivalent to {@code getActivateExtension(url, key, null)}\n     *\n     * @param url url\n     * @param key url parameter key which used to get extension point names\n     * @return extension list which are activated.\n     * @see #getActivateExtension(org.apache.dubbo.common.URL, String, String)\n     */\n    public List<T> getActivateExtension(URL url, String key) {\n        return getActivateExtension(url, key, null);\n    }\n\n    /**\n     * This is equivalent to {@code getActivateExtension(url, values, null)}\n     *\n     * @param url    url\n     * @param values extension point names\n     * @return extension list which are activated\n     * @see #getActivateExtension(org.apache.dubbo.common.URL, String[], String)\n     */\n    public List<T> getActivateExtension(URL url, String[] values) {\n        return getActivateExtension(url, values, null);\n    }\n\n    /**\n     * This is equivalent to {@code getActivateExtension(url, url.getParameter(key).split(\",\"), null)}\n     *\n     * @param url   url\n     * @param key   url parameter key which used to get extension point names\n     * @param group group\n     * @return extension list which are activated.\n     * @see #getActivateExtension(org.apache.dubbo.common.URL, String[], String)\n     */\n    public List<T> getActivateExtension(URL url, String key, String group) {\n        String value = url.getParameter(key);\n        return getActivateExtension(url, StringUtils.isEmpty(value) ? null : COMMA_SPLIT_PATTERN.split(value), group);\n    }\n\n    /**\n     * Get activate extensions.\n     *\n     * @param url    url\n     * @param values extension point names\n     * @param group  group\n     * @return extension list which are activated\n     * @see org.apache.dubbo.common.extension.Activate\n     */\n    @SuppressWarnings(\"deprecation\")\n    public List<T> getActivateExtension(URL url, String[] values, String group) {\n        checkDestroyed();\n        // solve the bug of using @SPI's wrapper method to report a null pointer exception.\n        Map<Class<?>, T> activateExtensionsMap = new TreeMap<>(activateComparator);\n        List<String> names = values == null\n                ? new ArrayList<>(0)\n                : Arrays.stream(values).map(StringUtils::trim).collect(Collectors.toList());\n        Set<String> namesSet = new HashSet<>(names);\n        if (!namesSet.contains(REMOVE_VALUE_PREFIX + DEFAULT_KEY)) {\n            if (cachedActivateGroups.size() == 0) {\n                synchronized (cachedActivateGroups) {\n                    // cache all extensions\n                    if (cachedActivateGroups.size() == 0) {\n                        getExtensionClasses();\n                        for (Map.Entry<String, Object> entry : cachedActivates.entrySet()) {\n                            String name = entry.getKey();\n                            Object activate = entry.getValue();\n\n                            String[] activateGroup, activateValue;\n\n                            if (activate instanceof Activate) {\n                                activateGroup = ((Activate) activate).group();\n                                activateValue = ((Activate) activate).value();\n                            } else if (Dubbo2CompactUtils.isEnabled()\n                                    && Dubbo2ActivateUtils.isActivateLoaded()\n                                    && Dubbo2ActivateUtils.getActivateClass().isAssignableFrom(activate.getClass())) {\n                                activateGroup = Dubbo2ActivateUtils.getGroup((Annotation) activate);\n                                activateValue = Dubbo2ActivateUtils.getValue((Annotation) activate);\n                            } else {\n                                continue;\n                            }\n                            cachedActivateGroups.put(name, new HashSet<>(Arrays.asList(activateGroup)));\n                            String[][] keyPairs = new String[activateValue.length][];\n                            for (int i = 0; i < activateValue.length; i++) {\n                                if (activateValue[i].contains(\":\")) {\n                                    keyPairs[i] = new String[2];\n                                    String[] arr = activateValue[i].split(\":\");\n                                    keyPairs[i][0] = arr[0];\n                                    keyPairs[i][1] = arr[1];\n                                } else {\n                                    keyPairs[i] = new String[1];\n                                    keyPairs[i][0] = activateValue[i];\n                                }\n                            }\n                            cachedActivateValues.put(name, keyPairs);\n                        }\n                    }\n                }\n            }\n\n            // traverse all cached extensions\n            cachedActivateGroups.forEach((name, activateGroup) -> {\n                if (isMatchGroup(group, activateGroup)\n                        && !namesSet.contains(name)\n                        && !namesSet.contains(REMOVE_VALUE_PREFIX + name)\n                        && isActive(cachedActivateValues.get(name), url)) {\n\n                    activateExtensionsMap.put(getExtensionClass(name), getExtension(name));\n                }\n            });\n        }\n\n        if (namesSet.contains(DEFAULT_KEY)) {\n            // will affect order\n            // `ext1,default,ext2` means ext1 will happens before all of the default extensions while ext2 will after\n            // them\n            ArrayList<T> extensionsResult = new ArrayList<>(activateExtensionsMap.size() + names.size());\n            for (String name : names) {\n                if (name.startsWith(REMOVE_VALUE_PREFIX) || namesSet.contains(REMOVE_VALUE_PREFIX + name)) {\n                    continue;\n                }\n                if (DEFAULT_KEY.equals(name)) {\n                    extensionsResult.addAll(activateExtensionsMap.values());\n                    continue;\n                }\n                if (containsExtension(name)) {\n                    extensionsResult.add(getExtension(name));\n                }\n            }\n            return extensionsResult;\n        } else {\n            // add extensions, will be sorted by its order\n            for (String name : names) {\n                if (name.startsWith(REMOVE_VALUE_PREFIX) || namesSet.contains(REMOVE_VALUE_PREFIX + name)) {\n                    continue;\n                }\n                if (DEFAULT_KEY.equals(name)) {\n                    continue;\n                }\n                if (containsExtension(name)) {\n                    activateExtensionsMap.put(getExtensionClass(name), getExtension(name));\n                }\n            }\n            return new ArrayList<>(activateExtensionsMap.values());\n        }\n    }\n\n    public List<T> getActivateExtensions() {\n        checkDestroyed();\n        List<T> activateExtensions = new ArrayList<>();\n        TreeMap<Class<?>, T> activateExtensionsMap = new TreeMap<>(activateComparator);\n        getExtensionClasses();\n        for (Map.Entry<String, Object> entry : cachedActivates.entrySet()) {\n            String name = entry.getKey();\n            Object activate = entry.getValue();\n            if (!(activate instanceof Activate)) {\n                continue;\n            }\n            activateExtensionsMap.put(getExtensionClass(name), getExtension(name));\n        }\n        if (!activateExtensionsMap.isEmpty()) {\n            activateExtensions.addAll(activateExtensionsMap.values());\n        }\n\n        return activateExtensions;\n    }\n\n    private boolean isMatchGroup(String group, Set<String> groups) {\n        if (StringUtils.isEmpty(group)) {\n            return true;\n        }\n        if (CollectionUtils.isNotEmpty(groups)) {\n            return groups.contains(group);\n        }\n        return false;\n    }\n\n    private boolean isActive(String[][] keyPairs, URL url) {\n        if (keyPairs.length == 0) {\n            return true;\n        }\n        for (String[] keyPair : keyPairs) {\n            // @Active(value=\"key1:value1, key2:value2\")\n            String key;\n            String keyValue = null;\n            if (keyPair.length > 1) {\n                key = keyPair[0];\n                keyValue = keyPair[1];\n            } else {\n                key = keyPair[0];\n            }\n\n            String realValue = url.getParameter(key);\n            if (StringUtils.isEmpty(realValue)) {\n                realValue = url.getAnyMethodParameter(key);\n            }\n            if ((keyValue != null && keyValue.equals(realValue))\n                    || (keyValue == null && ConfigUtils.isNotEmpty(realValue))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get extension's instance. Return <code>null</code> if extension is not found or is not initialized. Pls. note\n     * that this method will not trigger extension load.\n     * <p>\n     * In order to trigger extension load, call {@link #getExtension(String)} instead.\n     *\n     * @see #getExtension(String)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public T getLoadedExtension(String name) {\n        checkDestroyed();\n        if (StringUtils.isEmpty(name)) {\n            throw new IllegalArgumentException(\"Extension name == null\");\n        }\n        Holder<Object> holder = getOrCreateHolder(name);\n        return (T) holder.get();\n    }\n\n    private Holder<Object> getOrCreateHolder(String name) {\n        Holder<Object> holder = cachedInstances.get(name);\n        if (holder == null) {\n            cachedInstances.putIfAbsent(name, new Holder<>());\n            holder = cachedInstances.get(name);\n        }\n        return holder;\n    }\n\n    /**\n     * Return the list of extensions which are already loaded.\n     * <p>\n     * Usually {@link #getSupportedExtensions()} should be called in order to get all extensions.\n     *\n     * @see #getSupportedExtensions()\n     */\n    public Set<String> getLoadedExtensions() {\n        return Collections.unmodifiableSet(new TreeSet<>(cachedInstances.keySet()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public List<T> getLoadedExtensionInstances() {\n        checkDestroyed();\n        List<T> instances = new ArrayList<>();\n        cachedInstances.values().forEach(holder -> instances.add((T) holder.get()));\n        return instances;\n    }\n\n    /**\n     * Find the extension with the given name.\n     *\n     * @throws IllegalStateException If the specified extension is not found.\n     */\n    public T getExtension(String name) {\n        T extension = getExtension(name, true);\n        if (extension == null) {\n            throw new IllegalArgumentException(\"Not find extension: \" + name);\n        }\n        return extension;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public T getExtension(String name, boolean wrap) {\n        checkDestroyed();\n        if (StringUtils.isEmpty(name)) {\n            throw new IllegalArgumentException(\"Extension name == null\");\n        }\n        if (\"true\".equals(name)) {\n            return getDefaultExtension();\n        }\n        String cacheKey = name;\n        if (!wrap) {\n            cacheKey += \"_origin\";\n        }\n        final Holder<Object> holder = getOrCreateHolder(cacheKey);\n        Object instance = holder.get();\n        if (instance == null) {\n            synchronized (holder) {\n                instance = holder.get();\n                if (instance == null) {\n                    instance = createExtension(name, wrap);\n                    holder.set(instance);\n                }\n            }\n        }\n        return (T) instance;\n    }\n\n    /**\n     * Get the extension by specified name if found, or {@link #getDefaultExtension() returns the default one}\n     *\n     * @param name the name of extension\n     * @return non-null\n     */\n    public T getOrDefaultExtension(String name) {\n        return containsExtension(name) ? getExtension(name) : getDefaultExtension();\n    }\n\n    /**\n     * Return default extension, return <code>null</code> if it's not configured.\n     */\n    public T getDefaultExtension() {\n        getExtensionClasses();\n        if (StringUtils.isBlank(cachedDefaultName) || \"true\".equals(cachedDefaultName)) {\n            return null;\n        }\n        return getExtension(cachedDefaultName);\n    }\n\n    public boolean hasExtension(String name) {\n        checkDestroyed();\n        if (StringUtils.isEmpty(name)) {\n            throw new IllegalArgumentException(\"Extension name == null\");\n        }\n        Class<?> c = this.getExtensionClass(name);\n        return c != null;\n    }\n\n    public Set<String> getSupportedExtensions() {\n        checkDestroyed();\n        Map<String, Class<?>> classes = getExtensionClasses();\n        return Collections.unmodifiableSet(new TreeSet<>(classes.keySet()));\n    }\n\n    public Set<T> getSupportedExtensionInstances() {\n        checkDestroyed();\n        List<T> instances = new LinkedList<>();\n        Set<String> supportedExtensions = getSupportedExtensions();\n        if (CollectionUtils.isNotEmpty(supportedExtensions)) {\n            for (String name : supportedExtensions) {\n                instances.add(getExtension(name));\n            }\n        }\n        // sort the Prioritized instances\n        instances.sort(Prioritized.COMPARATOR);\n        return new LinkedHashSet<>(instances);\n    }\n\n    /**\n     * Return default extension name, return <code>null</code> if not configured.\n     */\n    public String getDefaultExtensionName() {\n        getExtensionClasses();\n        return cachedDefaultName;\n    }\n\n    /**\n     * Register new extension via API\n     *\n     * @param name  extension name\n     * @param clazz extension class\n     * @throws IllegalStateException when extension with the same name has already been registered.\n     */\n    public void addExtension(String name, Class<?> clazz) {\n        checkDestroyed();\n        getExtensionClasses(); // load classes\n\n        if (!type.isAssignableFrom(clazz)) {\n            throw new IllegalStateException(\"Input type \" + clazz + \" doesn't implement the Extension \" + type);\n        }\n        if (clazz.isInterface()) {\n            throw new IllegalStateException(\"Input type \" + clazz + \" can't be interface!\");\n        }\n\n        if (!clazz.isAnnotationPresent(Adaptive.class)) {\n            if (StringUtils.isBlank(name)) {\n                throw new IllegalStateException(\"Extension name is blank (Extension \" + type + \")!\");\n            }\n            if (cachedClasses.get().containsKey(name)) {\n                throw new IllegalStateException(\"Extension name \" + name + \" already exists (Extension \" + type + \")!\");\n            }\n\n            cachedNames.put(clazz, name);\n            cachedClasses.get().put(name, clazz);\n        } else {\n            if (cachedAdaptiveClass != null) {\n                throw new IllegalStateException(\"Adaptive Extension already exists (Extension \" + type + \")!\");\n            }\n\n            cachedAdaptiveClass = clazz;\n        }\n    }\n\n    /**\n     * Replace the existing extension via API\n     *\n     * @param name  extension name\n     * @param clazz extension class\n     * @throws IllegalStateException when extension to be placed doesn't exist\n     * @deprecated not recommended any longer, and use only when test\n     */\n    @Deprecated\n    public void replaceExtension(String name, Class<?> clazz) {\n        checkDestroyed();\n        getExtensionClasses(); // load classes\n\n        if (!type.isAssignableFrom(clazz)) {\n            throw new IllegalStateException(\"Input type \" + clazz + \" doesn't implement Extension \" + type);\n        }\n        if (clazz.isInterface()) {\n            throw new IllegalStateException(\"Input type \" + clazz + \" can't be interface!\");\n        }\n\n        if (!clazz.isAnnotationPresent(Adaptive.class)) {\n            if (StringUtils.isBlank(name)) {\n                throw new IllegalStateException(\"Extension name is blank (Extension \" + type + \")!\");\n            }\n            if (!cachedClasses.get().containsKey(name)) {\n                throw new IllegalStateException(\"Extension name \" + name + \" doesn't exist (Extension \" + type + \")!\");\n            }\n\n            cachedNames.put(clazz, name);\n            cachedClasses.get().put(name, clazz);\n            cachedInstances.remove(name);\n        } else {\n            if (cachedAdaptiveClass == null) {\n                throw new IllegalStateException(\"Adaptive Extension doesn't exist (Extension \" + type + \")!\");\n            }\n\n            cachedAdaptiveClass = clazz;\n            cachedAdaptiveInstance.set(null);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public T getAdaptiveExtension() {\n        checkDestroyed();\n        Object instance = cachedAdaptiveInstance.get();\n        if (instance == null) {\n            if (createAdaptiveInstanceError != null) {\n                throw new IllegalStateException(\n                        \"Failed to create adaptive instance: \" + createAdaptiveInstanceError.toString(),\n                        createAdaptiveInstanceError);\n            }\n\n            synchronized (cachedAdaptiveInstance) {\n                instance = cachedAdaptiveInstance.get();\n                if (instance == null) {\n                    try {\n                        instance = createAdaptiveExtension();\n                        cachedAdaptiveInstance.set(instance);\n                    } catch (Throwable t) {\n                        createAdaptiveInstanceError = t;\n                        throw new IllegalStateException(\"Failed to create adaptive instance: \" + t.toString(), t);\n                    }\n                }\n            }\n        }\n\n        return (T) instance;\n    }\n\n    private IllegalStateException findException(String name) {\n        StringBuilder buf = new StringBuilder(\"No such extension \" + type.getName() + \" by name \" + name);\n\n        int i = 1;\n        for (Map.Entry<String, IllegalStateException> entry : exceptions.entrySet()) {\n            if (entry.getKey().toLowerCase().startsWith(name.toLowerCase())) {\n                if (i == 1) {\n                    buf.append(\", possible causes: \");\n                }\n                buf.append(\"\\r\\n(\");\n                buf.append(i++);\n                buf.append(\") \");\n                buf.append(entry.getKey());\n                buf.append(\":\\r\\n\");\n                buf.append(StringUtils.toString(entry.getValue()));\n            }\n        }\n\n        if (i == 1) {\n            buf.append(\", no related exception was found, please check whether related SPI module is missing.\");\n        }\n        return new IllegalStateException(buf.toString());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private T createExtension(String name, boolean wrap) {\n        Class<?> clazz = getExtensionClasses().get(name);\n        if (clazz == null || unacceptableExceptions.contains(name)) {\n            throw findException(name);\n        }\n        try {\n            T instance = (T) extensionInstances.get(clazz);\n            if (instance == null) {\n                extensionInstances.putIfAbsent(clazz, createExtensionInstance(clazz));\n                instance = (T) extensionInstances.get(clazz);\n                instance = postProcessBeforeInitialization(instance, name);\n                injectExtension(instance);\n                instance = postProcessAfterInitialization(instance, name);\n            }\n\n            if (wrap) {\n                List<Class<?>> wrapperClassesList = new ArrayList<>();\n                if (cachedWrapperClasses != null) {\n                    wrapperClassesList.addAll(cachedWrapperClasses);\n                    wrapperClassesList.sort(WrapperComparator.COMPARATOR);\n                    Collections.reverse(wrapperClassesList);\n                }\n\n                if (CollectionUtils.isNotEmpty(wrapperClassesList)) {\n                    for (Class<?> wrapperClass : wrapperClassesList) {\n                        Wrapper wrapper = wrapperClass.getAnnotation(Wrapper.class);\n                        boolean match = (wrapper == null)\n                                || ((ArrayUtils.isEmpty(wrapper.matches())\n                                                || ArrayUtils.contains(wrapper.matches(), name))\n                                        && !ArrayUtils.contains(wrapper.mismatches(), name));\n                        if (match) {\n                            instance = injectExtension(\n                                    (T) wrapperClass.getConstructor(type).newInstance(instance));\n                            instance = postProcessAfterInitialization(instance, name);\n                        }\n                    }\n                }\n            }\n\n            // Warning: After an instance of Lifecycle is wrapped by cachedWrapperClasses, it may not still be Lifecycle\n            // instance, this application may not invoke the lifecycle.initialize hook.\n            initExtension(instance);\n            return instance;\n        } catch (Throwable t) {\n            throw new IllegalStateException(\n                    \"Extension instance (name: \" + name + \", class: \" + type + \") couldn't be instantiated: \"\n                            + t.getMessage(),\n                    t);\n        }\n    }\n\n    private Object createExtensionInstance(Class<?> type) throws ReflectiveOperationException {\n        return instantiationStrategy.instantiate(type);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private T postProcessBeforeInitialization(T instance, String name) throws Exception {\n        if (extensionPostProcessors != null) {\n            for (ExtensionPostProcessor processor : extensionPostProcessors) {\n                instance = (T) processor.postProcessBeforeInitialization(instance, name);\n            }\n        }\n        return instance;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private T postProcessAfterInitialization(T instance, String name) throws Exception {\n        if (instance instanceof ExtensionAccessorAware) {\n            ((ExtensionAccessorAware) instance).setExtensionAccessor(extensionDirector);\n        }\n        if (extensionPostProcessors != null) {\n            for (ExtensionPostProcessor processor : extensionPostProcessors) {\n                instance = (T) processor.postProcessAfterInitialization(instance, name);\n            }\n        }\n        return instance;\n    }\n\n    private boolean containsExtension(String name) {\n        return getExtensionClasses().containsKey(name);\n    }\n\n    private T injectExtension(T instance) {\n        if (injector == null) {\n            return instance;\n        }\n\n        try {\n            for (Method method : instance.getClass().getMethods()) {\n                if (!isSetter(method)) {\n                    continue;\n                }\n                /**\n                 * Check {@link DisableInject} to see if we need auto-injection for this property\n                 */\n                if (method.isAnnotationPresent(DisableInject.class)) {\n                    continue;\n                }\n\n                // When spiXXX implements ScopeModelAware, ExtensionAccessorAware,\n                // the setXXX of ScopeModelAware and ExtensionAccessorAware does not need to be injected\n                if (method.getDeclaringClass() == ScopeModelAware.class) {\n                    continue;\n                }\n                if (instance instanceof ScopeModelAware || instance instanceof ExtensionAccessorAware) {\n                    if (ignoredInjectMethodsDesc.contains(ReflectUtils.getDesc(method))) {\n                        continue;\n                    }\n                }\n\n                Class<?> pt = method.getParameterTypes()[0];\n                if (ReflectUtils.isPrimitives(pt)) {\n                    continue;\n                }\n\n                try {\n                    String property = getSetterProperty(method);\n                    Object object = injector.getInstance(pt, property);\n                    if (object != null) {\n                        method.invoke(instance, object);\n                    }\n                } catch (Exception e) {\n                    logger.error(\n                            COMMON_ERROR_LOAD_EXTENSION,\n                            \"\",\n                            \"\",\n                            \"Failed to inject via method \" + method.getName() + \" of interface \" + type.getName() + \": \"\n                                    + e.getMessage(),\n                            e);\n                }\n            }\n        } catch (Exception e) {\n            logger.error(COMMON_ERROR_LOAD_EXTENSION, \"\", \"\", e.getMessage(), e);\n        }\n        return instance;\n    }\n\n    private void initExtension(T instance) {\n        if (instance instanceof Lifecycle) {\n            Lifecycle lifecycle = (Lifecycle) instance;\n            lifecycle.initialize();\n        }\n    }\n\n    /**\n     * get properties name for setter, for instance: setVersion, return \"version\"\n     * <p>\n     * return \"\", if setter name with length less than 3\n     */\n    private String getSetterProperty(Method method) {\n        return method.getName().length() > 3\n                ? method.getName().substring(3, 4).toLowerCase()\n                        + method.getName().substring(4)\n                : \"\";\n    }\n\n    /**\n     * return true if and only if:\n     * <p>\n     * 1, public\n     * <p>\n     * 2, name starts with \"set\"\n     * <p>\n     * 3, only has one parameter\n     */\n    private boolean isSetter(Method method) {\n        return method.getName().startsWith(\"set\")\n                && method.getParameterTypes().length == 1\n                && Modifier.isPublic(method.getModifiers());\n    }\n\n    private Class<?> getExtensionClass(String name) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Extension type == null\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"Extension name == null\");\n        }\n        return getExtensionClasses().get(name);\n    }\n\n    private Map<String, Class<?>> getExtensionClasses() {\n        Map<String, Class<?>> classes = cachedClasses.get();\n        if (classes == null) {\n            synchronized (cachedClasses) {\n                classes = cachedClasses.get();\n                if (classes == null) {\n                    try {\n                        classes = loadExtensionClasses();\n                    } catch (InterruptedException e) {\n                        logger.error(\n                                COMMON_ERROR_LOAD_EXTENSION,\n                                \"\",\n                                \"\",\n                                \"Exception occurred when loading extension class (interface: \" + type + \")\",\n                                e);\n                        throw new IllegalStateException(\n                                \"Exception occurred when loading extension class (interface: \" + type + \")\", e);\n                    }\n                    cachedClasses.set(classes);\n                }\n            }\n        }\n        return classes;\n    }\n\n    /**\n     * synchronized in getExtensionClasses\n     */\n    @SuppressWarnings(\"deprecation\")\n    private Map<String, Class<?>> loadExtensionClasses() throws InterruptedException {\n        checkDestroyed();\n        cacheDefaultExtensionName();\n\n        Map<String, Class<?>> extensionClasses = new HashMap<>();\n\n        for (LoadingStrategy strategy : strategies) {\n            loadDirectory(extensionClasses, strategy, type.getName());\n\n            // compatible with old ExtensionFactory\n            if (this.type == ExtensionInjector.class) {\n                loadDirectory(extensionClasses, strategy, ExtensionFactory.class.getName());\n            }\n        }\n\n        return extensionClasses;\n    }\n\n    private void loadDirectory(Map<String, Class<?>> extensionClasses, LoadingStrategy strategy, String type)\n            throws InterruptedException {\n        loadDirectoryInternal(extensionClasses, strategy, type);\n        if (Dubbo2CompactUtils.isEnabled()) {\n            try {\n                String oldType = type.replace(\"org.apache\", \"com.alibaba\");\n                if (oldType.equals(type)) {\n                    return;\n                }\n                // if class not found,skip try to load resources\n                ClassUtils.forName(oldType);\n                loadDirectoryInternal(extensionClasses, strategy, oldType);\n            } catch (ClassNotFoundException classNotFoundException) {\n\n            }\n        }\n    }\n\n    /**\n     * extract and cache default extension name if exists\n     */\n    private void cacheDefaultExtensionName() {\n        final SPI defaultAnnotation = type.getAnnotation(SPI.class);\n        if (defaultAnnotation == null) {\n            return;\n        }\n\n        String value = defaultAnnotation.value();\n        if ((value = value.trim()).length() > 0) {\n            String[] names = NAME_SEPARATOR.split(value);\n            if (names.length > 1) {\n                throw new IllegalStateException(\"More than 1 default extension name on extension \" + type.getName()\n                        + \": \" + Arrays.toString(names));\n            }\n            if (names.length == 1) {\n                cachedDefaultName = names[0];\n            }\n        }\n    }\n\n    private void loadDirectoryInternal(\n            Map<String, Class<?>> extensionClasses, LoadingStrategy loadingStrategy, String type)\n            throws InterruptedException {\n        String fileName = loadingStrategy.directory() + type;\n        try {\n            List<ClassLoader> classLoadersToLoad = new LinkedList<>();\n\n            // try to load from ExtensionLoader's ClassLoader first\n            if (loadingStrategy.preferExtensionClassLoader()) {\n                ClassLoader extensionLoaderClassLoader = ExtensionLoader.class.getClassLoader();\n                if (ClassLoader.getSystemClassLoader() != extensionLoaderClassLoader) {\n                    classLoadersToLoad.add(extensionLoaderClassLoader);\n                }\n            }\n\n            if (specialSPILoadingStrategyMap.containsKey(type)) {\n                String internalDirectoryType = specialSPILoadingStrategyMap.get(type);\n                // skip to load spi when name don't match\n                if (!LoadingStrategy.ALL.equals(internalDirectoryType)\n                        && !internalDirectoryType.equals(loadingStrategy.getName())) {\n                    return;\n                }\n                classLoadersToLoad.clear();\n                classLoadersToLoad.add(ExtensionLoader.class.getClassLoader());\n            } else {\n                // load from scope model\n                Set<ClassLoader> classLoaders = scopeModel.getClassLoaders();\n\n                if (CollectionUtils.isEmpty(classLoaders)) {\n                    Enumeration<java.net.URL> resources = ClassLoader.getSystemResources(fileName);\n                    if (resources != null) {\n                        while (resources.hasMoreElements()) {\n                            loadResource(\n                                    extensionClasses,\n                                    null,\n                                    resources.nextElement(),\n                                    loadingStrategy.overridden(),\n                                    loadingStrategy.includedPackages(),\n                                    loadingStrategy.excludedPackages(),\n                                    loadingStrategy.onlyExtensionClassLoaderPackages());\n                        }\n                    }\n                } else {\n                    classLoadersToLoad.addAll(classLoaders);\n                }\n            }\n\n            Map<ClassLoader, Set<java.net.URL>> resources =\n                    ClassLoaderResourceLoader.loadResources(fileName, classLoadersToLoad);\n            resources.forEach(((classLoader, urls) -> {\n                loadFromClass(\n                        extensionClasses,\n                        loadingStrategy.overridden(),\n                        urls,\n                        classLoader,\n                        loadingStrategy.includedPackages(),\n                        loadingStrategy.excludedPackages(),\n                        loadingStrategy.onlyExtensionClassLoaderPackages());\n            }));\n        } catch (InterruptedException e) {\n            throw e;\n        } catch (Throwable t) {\n            logger.error(\n                    COMMON_ERROR_LOAD_EXTENSION,\n                    \"\",\n                    \"\",\n                    \"Exception occurred when loading extension class (interface: \" + type + \", description file: \"\n                            + fileName + \").\",\n                    t);\n        }\n    }\n\n    private void loadFromClass(\n            Map<String, Class<?>> extensionClasses,\n            boolean overridden,\n            Set<java.net.URL> urls,\n            ClassLoader classLoader,\n            String[] includedPackages,\n            String[] excludedPackages,\n            String[] onlyExtensionClassLoaderPackages) {\n        if (CollectionUtils.isNotEmpty(urls)) {\n            for (java.net.URL url : urls) {\n                loadResource(\n                        extensionClasses,\n                        classLoader,\n                        url,\n                        overridden,\n                        includedPackages,\n                        excludedPackages,\n                        onlyExtensionClassLoaderPackages);\n            }\n        }\n    }\n\n    private void loadResource(\n            Map<String, Class<?>> extensionClasses,\n            ClassLoader classLoader,\n            java.net.URL resourceURL,\n            boolean overridden,\n            String[] includedPackages,\n            String[] excludedPackages,\n            String[] onlyExtensionClassLoaderPackages) {\n        try {\n            List<String> newContentList = getResourceContent(resourceURL);\n            String clazz;\n            for (String line : newContentList) {\n                try {\n                    String name = null;\n                    int i = line.indexOf('=');\n                    if (i > 0) {\n                        name = line.substring(0, i).trim();\n                        clazz = line.substring(i + 1).trim();\n                    } else {\n                        clazz = line;\n                    }\n                    if (StringUtils.isNotEmpty(clazz)\n                            && !isExcluded(clazz, excludedPackages)\n                            && isIncluded(clazz, includedPackages)\n                            && !isExcludedByClassLoader(clazz, classLoader, onlyExtensionClassLoaderPackages)) {\n\n                        loadClass(\n                                classLoader,\n                                extensionClasses,\n                                resourceURL,\n                                Class.forName(clazz, true, classLoader),\n                                name,\n                                overridden);\n                    }\n                } catch (Throwable t) {\n                    IllegalStateException e = new IllegalStateException(\n                            \"Failed to load extension class (interface: \" + type + \", class line: \" + line + \") in \"\n                                    + resourceURL + \", cause: \" + t.getMessage(),\n                            t);\n                    exceptions.put(line, e);\n                }\n            }\n        } catch (Throwable t) {\n            logger.error(\n                    COMMON_ERROR_LOAD_EXTENSION,\n                    \"\",\n                    \"\",\n                    \"Exception occurred when loading extension class (interface: \" + type + \", class file: \"\n                            + resourceURL + \") in \" + resourceURL,\n                    t);\n        }\n    }\n\n    private List<String> getResourceContent(java.net.URL resourceURL) throws IOException {\n        Map<java.net.URL, List<String>> urlListMap = urlListMapCache.get();\n        if (urlListMap == null) {\n            synchronized (ExtensionLoader.class) {\n                if ((urlListMap = urlListMapCache.get()) == null) {\n                    urlListMap = new ConcurrentHashMap<>();\n                    urlListMapCache = new SoftReference<>(urlListMap);\n                }\n            }\n        }\n\n        List<String> contentList = urlListMap.computeIfAbsent(resourceURL, key -> {\n            List<String> newContentList = new ArrayList<>();\n\n            try (BufferedReader reader =\n                    new BufferedReader(new InputStreamReader(resourceURL.openStream(), StandardCharsets.UTF_8))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    final int ci = line.indexOf('#');\n                    if (ci >= 0) {\n                        line = line.substring(0, ci);\n                    }\n                    line = line.trim();\n                    if (line.length() > 0) {\n                        newContentList.add(line);\n                    }\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e.getMessage(), e);\n            }\n            return newContentList;\n        });\n        return contentList;\n    }\n\n    private boolean isIncluded(String className, String... includedPackages) {\n        if (includedPackages != null && includedPackages.length > 0) {\n            for (String includedPackage : includedPackages) {\n                if (className.startsWith(includedPackage + \".\")) {\n                    // one match, return true\n                    return true;\n                }\n            }\n            // none matcher match, return false\n            return false;\n        }\n        // matcher is empty, return true\n        return true;\n    }\n\n    private boolean isExcluded(String className, String... excludedPackages) {\n        if (excludedPackages != null) {\n            for (String excludePackage : excludedPackages) {\n                if (className.startsWith(excludePackage + \".\")) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean isExcludedByClassLoader(\n            String className, ClassLoader classLoader, String... onlyExtensionClassLoaderPackages) {\n        if (onlyExtensionClassLoaderPackages != null) {\n            for (String excludePackage : onlyExtensionClassLoaderPackages) {\n                if (className.startsWith(excludePackage + \".\")) {\n                    // if target classLoader is not ExtensionLoader's classLoader should be excluded\n                    return !Objects.equals(ExtensionLoader.class.getClassLoader(), classLoader);\n                }\n            }\n        }\n        return false;\n    }\n\n    private void loadClass(\n            ClassLoader classLoader,\n            Map<String, Class<?>> extensionClasses,\n            java.net.URL resourceURL,\n            Class<?> clazz,\n            String name,\n            boolean overridden) {\n        if (!type.isAssignableFrom(clazz)) {\n            throw new IllegalStateException(\n                    \"Error occurred when loading extension class (interface: \" + type + \", class line: \"\n                            + clazz.getName() + \"), class \" + clazz.getName() + \" is not subtype of interface.\");\n        }\n\n        boolean isActive = loadClassIfActive(classLoader, clazz);\n\n        if (!isActive) {\n            return;\n        }\n\n        if (clazz.isAnnotationPresent(Adaptive.class)) {\n            cacheAdaptiveClass(clazz, overridden);\n        } else if (isWrapperClass(clazz)) {\n            cacheWrapperClass(clazz);\n        } else {\n            if (StringUtils.isEmpty(name)) {\n                name = findAnnotationName(clazz);\n                if (name.length() == 0) {\n                    throw new IllegalStateException(\"No such extension name for the class \" + clazz.getName()\n                            + \" in the config \" + resourceURL);\n                }\n            }\n\n            String[] names = NAME_SEPARATOR.split(name);\n            if (ArrayUtils.isNotEmpty(names)) {\n                cacheActivateClass(clazz, names[0]);\n                for (String n : names) {\n                    cacheName(clazz, n);\n                    saveInExtensionClass(extensionClasses, clazz, n, overridden);\n                }\n            }\n        }\n    }\n\n    private boolean loadClassIfActive(ClassLoader classLoader, Class<?> clazz) {\n        Activate activate = clazz.getAnnotation(Activate.class);\n\n        if (activate == null) {\n            return true;\n        }\n        String[] onClass = null;\n\n        if (activate instanceof Activate) {\n            onClass = ((Activate) activate).onClass();\n        } else if (Dubbo2CompactUtils.isEnabled()\n                && Dubbo2ActivateUtils.isActivateLoaded()\n                && Dubbo2ActivateUtils.getActivateClass().isAssignableFrom(activate.getClass())) {\n            onClass = Dubbo2ActivateUtils.getOnClass(activate);\n        }\n\n        boolean isActive = true;\n\n        if (null != onClass && onClass.length > 0) {\n            isActive = Arrays.stream(onClass)\n                    .filter(StringUtils::isNotBlank)\n                    .allMatch(className -> ClassUtils.isPresent(className, classLoader));\n        }\n        return isActive;\n    }\n\n    /**\n     * cache name\n     */\n    private void cacheName(Class<?> clazz, String name) {\n        if (!cachedNames.containsKey(clazz)) {\n            cachedNames.put(clazz, name);\n        }\n    }\n\n    /**\n     * put clazz in extensionClasses\n     */\n    private void saveInExtensionClass(\n            Map<String, Class<?>> extensionClasses, Class<?> clazz, String name, boolean overridden) {\n        Class<?> c = extensionClasses.get(name);\n        if (c == null || overridden) {\n            extensionClasses.put(name, clazz);\n        } else if (c != clazz) {\n            // duplicate implementation is unacceptable\n            unacceptableExceptions.add(name);\n            String duplicateMsg = \"Duplicate extension \" + type.getName() + \" name \" + name + \" on \" + c.getName()\n                    + \" and \" + clazz.getName();\n            logger.error(COMMON_ERROR_LOAD_EXTENSION, \"\", \"\", duplicateMsg);\n            throw new IllegalStateException(duplicateMsg);\n        }\n    }\n\n    /**\n     * cache Activate class which is annotated with <code>Activate</code>\n     * <p>\n     * for compatibility, also cache class with old alibaba Activate annotation\n     */\n    @SuppressWarnings(\"deprecation\")\n    private void cacheActivateClass(Class<?> clazz, String name) {\n        Activate activate = clazz.getAnnotation(Activate.class);\n        if (activate != null) {\n            cachedActivates.put(name, activate);\n        } else if (Dubbo2CompactUtils.isEnabled() && Dubbo2ActivateUtils.isActivateLoaded()) {\n            // support com.alibaba.dubbo.common.extension.Activate\n            Annotation oldActivate = clazz.getAnnotation(Dubbo2ActivateUtils.getActivateClass());\n            if (oldActivate != null) {\n                cachedActivates.put(name, oldActivate);\n            }\n        }\n    }\n\n    /**\n     * cache Adaptive class which is annotated with <code>Adaptive</code>\n     */\n    private void cacheAdaptiveClass(Class<?> clazz, boolean overridden) {\n        if (cachedAdaptiveClass == null || overridden) {\n            cachedAdaptiveClass = clazz;\n        } else if (!cachedAdaptiveClass.equals(clazz)) {\n            throw new IllegalStateException(\n                    \"More than 1 adaptive class found: \" + cachedAdaptiveClass.getName() + \", \" + clazz.getName());\n        }\n    }\n\n    /**\n     * cache wrapper class\n     * <p>\n     * like: ProtocolFilterWrapper, ProtocolListenerWrapper\n     */\n    private void cacheWrapperClass(Class<?> clazz) {\n        if (cachedWrapperClasses == null) {\n            cachedWrapperClasses = new ConcurrentHashSet<>();\n        }\n        cachedWrapperClasses.add(clazz);\n    }\n\n    /**\n     * test if clazz is a wrapper class\n     * <p>\n     * which has Constructor with given class type as its only argument\n     */\n    protected boolean isWrapperClass(Class<?> clazz) {\n        Constructor<?>[] constructors = clazz.getConstructors();\n        for (Constructor<?> constructor : constructors) {\n            if (constructor.getParameterTypes().length == 1 && constructor.getParameterTypes()[0] == type) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    private String findAnnotationName(Class<?> clazz) {\n        Extension extension = clazz.getAnnotation(Extension.class);\n        if (extension != null) {\n            return extension.value();\n        }\n\n        String name = clazz.getSimpleName();\n        if (name.endsWith(type.getSimpleName())) {\n            name = name.substring(0, name.length() - type.getSimpleName().length());\n        }\n        return name.toLowerCase();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private T createAdaptiveExtension() {\n        try {\n            T instance = (T) getAdaptiveExtensionClass().newInstance();\n            instance = postProcessBeforeInitialization(instance, null);\n            injectExtension(instance);\n            instance = postProcessAfterInitialization(instance, null);\n            initExtension(instance);\n            return instance;\n        } catch (Exception e) {\n            throw new IllegalStateException(\n                    \"Can't create adaptive extension \" + type + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    private Class<?> getAdaptiveExtensionClass() {\n        getExtensionClasses();\n        if (cachedAdaptiveClass != null) {\n            return cachedAdaptiveClass;\n        }\n        return cachedAdaptiveClass = createAdaptiveExtensionClass();\n    }\n\n    private Class<?> createAdaptiveExtensionClass() {\n        // Adaptive Classes' ClassLoader should be the same with Real SPI interface classes' ClassLoader\n        ClassLoader classLoader = type.getClassLoader();\n        try {\n            if (NativeUtils.isNative()) {\n                return classLoader.loadClass(type.getName() + \"$Adaptive\");\n            }\n        } catch (Throwable ignore) {\n\n        }\n        String code = new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();\n        org.apache.dubbo.common.compiler.Compiler compiler = extensionDirector\n                .getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class)\n                .getAdaptiveExtension();\n        return compiler.compile(type, code, classLoader);\n    }\n\n    @Override\n    public String toString() {\n        return this.getClass().getName() + \"[\" + type.getName() + \"]\";\n    }\n\n    private static Properties loadProperties(ClassLoader classLoader, String resourceName) {\n        Properties properties = new Properties();\n        if (classLoader != null) {\n            try {\n                Enumeration<java.net.URL> resources = classLoader.getResources(resourceName);\n                while (resources.hasMoreElements()) {\n                    java.net.URL url = resources.nextElement();\n                    Properties props = loadFromUrl(url);\n                    for (Map.Entry<Object, Object> entry : props.entrySet()) {\n                        String key = entry.getKey().toString();\n                        if (properties.containsKey(key)) {\n                            continue;\n                        }\n                        properties.put(key, entry.getValue().toString());\n                    }\n                }\n            } catch (IOException ex) {\n                logger.error(CONFIG_FAILED_LOAD_ENV_VARIABLE, \"\", \"\", \"load properties failed.\", ex);\n            }\n        }\n\n        return properties;\n    }\n\n    private static Properties loadFromUrl(java.net.URL url) {\n        Properties properties = new Properties();\n        InputStream is = null;\n        try {\n            is = url.openStream();\n            properties.load(is);\n        } catch (IOException e) {\n            // ignore\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n        return properties;\n    }\n}\n",
        "methodName": null,
        "exampleID": 106,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/extension/ExtensionLoader.java",
        "line": 750,
        "sink": "java.lang.String.startsWith",
        "source": "-",
        "sourceLine": 750,
        "qualifier": "Call to java.lang.String.startsWith with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.String.startsWith with untrusted data from [msg : String](2).\nCall to java.lang.String.startsWith with untrusted data from [msg : Object](3).\nCall to java.lang.String.startsWith with untrusted data from [msg : Object](4).\nCall to java.lang.String.startsWith with untrusted data from [msg : Object](5).\nCall to java.lang.String.startsWith with untrusted data from [msg : Http2StreamFrame](6).\nCall to java.lang.String.startsWith with untrusted data from [msg : Object](7).\nCall to java.lang.String.startsWith with untrusted data from [getRequestURI(...) : String](8).",
        "line_number": 750,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 107
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 107
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 107
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 107
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLAddress.java#L45",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.url.component;\n\nimport org.apache.dubbo.common.utils.NetUtils;\nimport org.apache.dubbo.common.utils.StringUtils;\n\nimport java.io.Serializable;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.Objects;\n\nimport static org.apache.dubbo.common.constants.CommonConstants.PATH_SEPARATOR;\n\npublic class URLAddress implements Serializable {\n    private static final long serialVersionUID = -1985165475234910535L;\n\n    protected String host;\n    protected int port;\n\n    // cache\n    protected transient String rawAddress;\n    protected transient long timestamp;\n\n    public URLAddress(String host, int port) {\n        this(host, port, null);\n    }\n\n    public URLAddress(String host, int port, String rawAddress) {\n        this.host = host;\n        port = Math.max(port, 0);\n        this.port = port;\n\n        this.rawAddress = rawAddress;\n        this.timestamp = System.currentTimeMillis();\n    }\n\n    public String getProtocol() {\n        return \"\";\n    }\n\n    public URLAddress setProtocol(String protocol) {\n        return this;\n    }\n\n    public String getUsername() {\n        return \"\";\n    }\n\n    public URLAddress setUsername(String username) {\n        return this;\n    }\n\n    public String getPassword() {\n        return \"\";\n    }\n\n    public URLAddress setPassword(String password) {\n        return this;\n    }\n\n    public String getPath() {\n        return \"\";\n    }\n\n    public URLAddress setPath(String path) {\n        return this;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public URLAddress setHost(String host) {\n        return new URLAddress(host, port, null);\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public URLAddress setPort(int port) {\n        return new URLAddress(host, port, null);\n    }\n\n    public String getAddress() {\n        if (rawAddress == null) {\n            rawAddress = getAddress(getHost(), getPort());\n        }\n        return rawAddress;\n    }\n\n    public URLAddress setAddress(String host, int port) {\n        return new URLAddress(host, port, rawAddress);\n    }\n\n    public String getIp() {\n        return NetUtils.getIpByHost(getHost());\n    }\n\n    public String getRawAddress() {\n        return rawAddress;\n    }\n\n    protected String getAddress(String host, int port) {\n        return port <= 0 ? host : host + ':' + port;\n    }\n\n    public long getTimestamp() {\n        return timestamp;\n    }\n\n    public void setTimestamp(long timestamp) {\n        this.timestamp = timestamp;\n    }\n\n    @Override\n    public int hashCode() {\n        return host.hashCode() * 31 + port;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (!(obj instanceof URLAddress)) return false;\n        URLAddress that = (URLAddress) obj;\n        return Objects.equals(this.getProtocol(), that.getProtocol())\n                && Objects.equals(this.getUsername(), that.getUsername())\n                && Objects.equals(this.getPassword(), that.getPassword())\n                && Objects.equals(this.getPath(), that.getPath())\n                && Objects.equals(this.getHost(), that.getHost())\n                && Objects.equals(this.getPort(), that.getPort());\n    }\n\n    @Override\n    public String toString() {\n        if (rawAddress != null) {\n            return rawAddress;\n        }\n\n        StringBuilder buf = new StringBuilder();\n        if (StringUtils.isNotEmpty(host)) {\n            buf.append(host);\n            if (port > 0) {\n                buf.append(':');\n                buf.append(port);\n            }\n        }\n        return buf.toString();\n    }\n\n    public static URLAddress parse(String rawAddress, String defaultProtocol, boolean encoded) {\n        try {\n            String decodeStr = rawAddress;\n            if (encoded) {\n                decodeStr = URLDecoder.decode(rawAddress, \"UTF-8\");\n            }\n\n            boolean isPathAddress = decodeStr.contains(PATH_SEPARATOR);\n            if (isPathAddress) {\n                return createPathURLAddress(decodeStr, rawAddress, defaultProtocol);\n            }\n            return createURLAddress(decodeStr, rawAddress, defaultProtocol);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n    }\n\n    private static URLAddress createURLAddress(String decodeStr, String rawAddress, String defaultProtocol) {\n        String host = null;\n        int port = 0;\n\n        int i = decodeStr.lastIndexOf(':');\n        if (i >= 0 && i < decodeStr.length() - 1) {\n            if (decodeStr.lastIndexOf('%') > i) {\n                // ipv6 address with scope id\n                // e.g. fe80:0:0:0:894:aeec:f37d:23e1%en0\n                // see https://howdoesinternetwork.com/2013/ipv6-zone-id\n                // ignore\n            } else {\n                port = Integer.parseInt(decodeStr.substring(i + 1));\n                host = decodeStr.substring(0, i);\n            }\n        } else {\n            host = decodeStr;\n        }\n\n        return new URLAddress(host, port, rawAddress);\n    }\n\n    private static PathURLAddress createPathURLAddress(String decodeStr, String rawAddress, String defaultProtocol) {\n        String protocol = defaultProtocol;\n        String path = null, username = null, password = null, host = null;\n        int port = 0;\n        int i = decodeStr.indexOf(\"://\");\n        if (i >= 0) {\n            if (i == 0) {\n                throw new IllegalStateException(\"url missing protocol: \\\"\" + decodeStr + \"\\\"\");\n            }\n            protocol = decodeStr.substring(0, i);\n            decodeStr = decodeStr.substring(i + 3);\n        } else {\n            // case: file:/path/to/file.txt\n            i = decodeStr.indexOf(\":/\");\n            if (i >= 0) {\n                if (i == 0) {\n                    throw new IllegalStateException(\"url missing protocol: \\\"\" + decodeStr + \"\\\"\");\n                }\n                protocol = decodeStr.substring(0, i);\n                decodeStr = decodeStr.substring(i + 1);\n            }\n        }\n\n        i = decodeStr.indexOf('/');\n        if (i >= 0) {\n            path = decodeStr.substring(i + 1);\n            decodeStr = decodeStr.substring(0, i);\n        }\n        i = decodeStr.lastIndexOf('@');\n        if (i >= 0) {\n            username = decodeStr.substring(0, i);\n            int j = username.indexOf(':');\n            if (j >= 0) {\n                password = username.substring(j + 1);\n                username = username.substring(0, j);\n            }\n            decodeStr = decodeStr.substring(i + 1);\n        }\n        i = decodeStr.lastIndexOf(':');\n        if (i >= 0 && i < decodeStr.length() - 1) {\n            if (decodeStr.lastIndexOf('%') > i) {\n                // ipv6 address with scope id\n                // e.g. fe80:0:0:0:894:aeec:f37d:23e1%en0\n                // see https://howdoesinternetwork.com/2013/ipv6-zone-id\n                // ignore\n            } else {\n                port = Integer.parseInt(decodeStr.substring(i + 1));\n                host = decodeStr.substring(0, i);\n            }\n        }\n\n        // check cache\n        protocol = URLItemCache.intern(protocol);\n        path = URLItemCache.checkPath(path);\n\n        return new PathURLAddress(protocol, username, password, path, host, port, rawAddress);\n    }\n}\n",
        "methodName": null,
        "exampleID": 108,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLAddress.java",
        "line": 45,
        "sink": "java.lang.Math.max",
        "source": "-",
        "sourceLine": 45,
        "qualifier": "Call to java.lang.Math.max with untrusted data from [getQueryString(...) : String](1).\nCall to java.lang.Math.max with untrusted data from [getRequestURL(...) : StringBuffer](2).",
        "line_number": 45,
        "steps": [
            {
                "line": 126,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "methodName": null,
                "exampleID": 109
            },
            {
                "line": 128,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "methodName": null,
                "exampleID": 109
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLParam.java#L138",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.url.component;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.URLStrParser;\nimport org.apache.dubbo.common.url.component.param.DynamicParamTable;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.common.utils.StringUtils;\n\nimport java.util.AbstractMap;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.StringJoiner;\n\nimport static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_KEY_PREFIX;\nimport static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;\nimport static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;\n\n/**\n * A class which store parameters for {@link URL}\n * <br/>\n * Using {@link DynamicParamTable} to compress common keys (i.e. side, version)\n * <br/>\n * {@link DynamicParamTable} allow to use only two integer value named `key` and\n * `value-offset` to find a unique string to string key-pair. Also, `value-offset`\n * is not required if the real value is the default value.\n * <br/>\n * URLParam should operate as Copy-On-Write, each modify actions will return a new Object\n * <br/>\n * <p>\n * NOTE: URLParam is not support serialization! {@link DynamicParamTable} is related with\n * current running environment. If you want to make URL as a parameter, please call\n * {@link URL#toSerializableURL()} to create {@link URLPlainParam} instead.\n *\n * @since 3.0\n */\npublic class URLParam {\n\n    /**\n     * Maximum size of key-pairs requested using array moving to add into URLParam.\n     * If user request like addParameter for only one key-pair, adding value into a array\n     * on moving is more efficient. However when add more than ADD_PARAMETER_ON_MOVE_THRESHOLD\n     * size of key-pairs, recover compressed array back to map can reduce operation count\n     * when putting objects.\n     */\n    private static final int ADD_PARAMETER_ON_MOVE_THRESHOLD = 1;\n\n    /**\n     * the original parameters string, empty if parameters have been modified or init by {@link Map}\n     */\n    private final String rawParam;\n\n    /**\n     * using bit to save if index exist even if value is default value\n     */\n    private final BitSet KEY;\n\n    /**\n     * an array which contains value-offset\n     */\n    private final int[] VALUE;\n\n    /**\n     * store extra parameters which key not match in {@link DynamicParamTable}\n     */\n    private final Map<String, String> EXTRA_PARAMS;\n\n    /**\n     * store method related parameters\n     * <p>\n     * K - key\n     * V -\n     * K - method\n     * V - value\n     * <p>\n     * e.g. method1.mock=true => ( mock, (method1, true) )\n     */\n    private final Map<String, Map<String, String>> METHOD_PARAMETERS;\n\n    private transient long timestamp;\n\n    /**\n     * Whether to enable DynamicParamTable compression\n     */\n    protected boolean enableCompressed;\n\n    private static final URLParam EMPTY_PARAM =\n            new URLParam(new BitSet(0), Collections.emptyMap(), Collections.emptyMap(), Collections.emptyMap(), \"\");\n\n    protected URLParam() {\n        this.rawParam = null;\n        this.KEY = null;\n        this.VALUE = null;\n        this.EXTRA_PARAMS = null;\n        this.METHOD_PARAMETERS = null;\n        this.enableCompressed = true;\n    }\n\n    protected URLParam(\n            BitSet key,\n            Map<Integer, Integer> value,\n            Map<String, String> extraParams,\n            Map<String, Map<String, String>> methodParameters,\n            String rawParam) {\n        this.KEY = key;\n        this.VALUE = new int[value.size()];\n        for (int i = key.nextSetBit(0), offset = 0; i >= 0; i = key.nextSetBit(i + 1)) {\n            if (value.containsKey(i)) {\n                VALUE[offset++] = value.get(i);\n            } else {\n                throw new IllegalArgumentException();\n            }\n        }\n        this.EXTRA_PARAMS =\n                Collections.unmodifiableMap((extraParams == null ? new HashMap<>() : new HashMap<>(extraParams)));\n        this.METHOD_PARAMETERS = Collections.unmodifiableMap(\n                (methodParameters == null) ? Collections.emptyMap() : new LinkedHashMap<>(methodParameters));\n        this.rawParam = rawParam;\n\n        this.timestamp = System.currentTimeMillis();\n        this.enableCompressed = true;\n    }\n\n    protected URLParam(\n            BitSet key,\n            int[] value,\n            Map<String, String> extraParams,\n            Map<String, Map<String, String>> methodParameters,\n            String rawParam) {\n        this.KEY = key;\n        this.VALUE = value;\n        this.EXTRA_PARAMS =\n                Collections.unmodifiableMap((extraParams == null ? new HashMap<>() : new HashMap<>(extraParams)));\n        this.METHOD_PARAMETERS = Collections.unmodifiableMap(\n                (methodParameters == null) ? Collections.emptyMap() : new LinkedHashMap<>(methodParameters));\n        this.rawParam = rawParam;\n        this.timestamp = System.currentTimeMillis();\n        this.enableCompressed = true;\n    }\n\n    /**\n     * Weather there contains some parameter match method\n     *\n     * @param method method name\n     * @return contains or not\n     */\n    public boolean hasMethodParameter(String method) {\n        if (method == null) {\n            return false;\n        }\n\n        String methodsString = getParameter(METHODS_KEY);\n        if (StringUtils.isNotEmpty(methodsString)) {\n            if (!methodsString.contains(method)) {\n                return false;\n            }\n        }\n\n        for (Map.Entry<String, Map<String, String>> methods : METHOD_PARAMETERS.entrySet()) {\n            if (methods.getValue().containsKey(method)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get method related parameter. If not contains, use getParameter(key) instead.\n     * Specially, in some situation like `method1.1.callback=true`, key is `1.callback`.\n     *\n     * @param method method name\n     * @param key    key\n     * @return value\n     */\n    public String getMethodParameter(String method, String key) {\n        String strictResult = getMethodParameterStrict(method, key);\n        return StringUtils.isNotEmpty(strictResult) ? strictResult : getParameter(key);\n    }\n\n    /**\n     * Get method related parameter. If not contains, return null.\n     * Specially, in some situation like `method1.1.callback=true`, key is `1.callback`.\n     *\n     * @param method method name\n     * @param key    key\n     * @return value\n     */\n    public String getMethodParameterStrict(String method, String key) {\n        String methodsString = getParameter(METHODS_KEY);\n        if (StringUtils.isNotEmpty(methodsString)) {\n            if (!methodsString.contains(method)) {\n                return null;\n            }\n        }\n\n        Map<String, String> methodMap = METHOD_PARAMETERS.get(key);\n        if (CollectionUtils.isNotEmptyMap(methodMap)) {\n            return methodMap.get(method);\n        } else {\n            return null;\n        }\n    }\n\n    public static Map<String, Map<String, String>> initMethodParameters(Map<String, String> parameters) {\n        Map<String, Map<String, String>> methodParameters = new HashMap<>();\n        if (parameters == null) {\n            return methodParameters;\n        }\n\n        String methodsString = parameters.get(METHODS_KEY);\n        if (StringUtils.isNotEmpty(methodsString)) {\n            String[] methods = methodsString.split(\",\");\n            for (Map.Entry<String, String> entry : parameters.entrySet()) {\n                String key = entry.getKey();\n                for (String method : methods) {\n                    String methodPrefix = method + '.';\n                    if (key.startsWith(methodPrefix)) {\n                        String realKey = key.substring(methodPrefix.length());\n                        URL.putMethodParameter(method, realKey, entry.getValue(), methodParameters);\n                    }\n                }\n            }\n        } else {\n            for (Map.Entry<String, String> entry : parameters.entrySet()) {\n                String key = entry.getKey();\n                int methodSeparator = key.indexOf('.');\n                if (methodSeparator > 0) {\n                    String method = key.substring(0, methodSeparator);\n                    String realKey = key.substring(methodSeparator + 1);\n                    URL.putMethodParameter(method, realKey, entry.getValue(), methodParameters);\n                }\n            }\n        }\n        return methodParameters;\n    }\n\n    /**\n     * An embedded Map adapt to URLParam\n     * <br/>\n     * copy-on-write mode, urlParam reference will be changed after modify actions.\n     * If wishes to get the result after modify, please use {@link URLParamMap#getUrlParam()}\n     */\n    public static class URLParamMap extends AbstractMap<String, String> {\n        private URLParam urlParam;\n\n        public URLParamMap(URLParam urlParam) {\n            this.urlParam = urlParam;\n        }\n\n        public static class Node implements Map.Entry<String, String> {\n            private final String key;\n            private String value;\n\n            public Node(String key, String value) {\n                this.key = key;\n                this.value = value;\n            }\n\n            @Override\n            public String getKey() {\n                return key;\n            }\n\n            @Override\n            public String getValue() {\n                return value;\n            }\n\n            @Override\n            public String setValue(String value) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public boolean equals(Object o) {\n                if (this == o) {\n                    return true;\n                }\n                if (o == null || getClass() != o.getClass()) {\n                    return false;\n                }\n                Node node = (Node) o;\n                return Objects.equals(key, node.key) && Objects.equals(value, node.value);\n            }\n\n            @Override\n            public int hashCode() {\n                return Objects.hash(key, value);\n            }\n        }\n\n        @Override\n        public int size() {\n            return urlParam.KEY.cardinality() + urlParam.EXTRA_PARAMS.size();\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return size() == 0;\n        }\n\n        @Override\n        public boolean containsKey(Object key) {\n            if (key instanceof String) {\n                return urlParam.hasParameter((String) key);\n            } else {\n                return false;\n            }\n        }\n\n        @Override\n        public boolean containsValue(Object value) {\n            return values().contains(value);\n        }\n\n        @Override\n        public String get(Object key) {\n            if (key instanceof String) {\n                return urlParam.getParameter((String) key);\n            } else {\n                return null;\n            }\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String previous = urlParam.getParameter(key);\n            urlParam = urlParam.addParameter(key, value);\n            return previous;\n        }\n\n        @Override\n        public String remove(Object key) {\n            if (key instanceof String) {\n                String previous = urlParam.getParameter((String) key);\n                urlParam = urlParam.removeParameters((String) key);\n                return previous;\n            } else {\n                return null;\n            }\n        }\n\n        @Override\n        public void putAll(Map<? extends String, ? extends String> m) {\n            urlParam = urlParam.addParameters((Map<String, String>) m);\n        }\n\n        @Override\n        public void clear() {\n            urlParam = urlParam.clearParameters();\n        }\n\n        @Override\n        public Set<String> keySet() {\n            Set<String> set =\n                    new LinkedHashSet<>((int) ((urlParam.VALUE.length + urlParam.EXTRA_PARAMS.size()) / 0.75) + 1);\n            for (int i = urlParam.KEY.nextSetBit(0); i >= 0; i = urlParam.KEY.nextSetBit(i + 1)) {\n                set.add(DynamicParamTable.getKey(i));\n            }\n            for (Entry<String, String> entry : urlParam.EXTRA_PARAMS.entrySet()) {\n                set.add(entry.getKey());\n            }\n            return Collections.unmodifiableSet(set);\n        }\n\n        @Override\n        public Collection<String> values() {\n            Set<String> set =\n                    new LinkedHashSet<>((int) ((urlParam.VALUE.length + urlParam.EXTRA_PARAMS.size()) / 0.75) + 1);\n            for (int i = urlParam.KEY.nextSetBit(0); i >= 0; i = urlParam.KEY.nextSetBit(i + 1)) {\n                String value;\n                int offset = urlParam.keyIndexToOffset(i);\n                value = DynamicParamTable.getValue(i, offset);\n                set.add(value);\n            }\n\n            for (Entry<String, String> entry : urlParam.EXTRA_PARAMS.entrySet()) {\n                set.add(entry.getValue());\n            }\n            return Collections.unmodifiableSet(set);\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            Set<Entry<String, String>> set =\n                    new LinkedHashSet<>((int) ((urlParam.KEY.cardinality() + urlParam.EXTRA_PARAMS.size()) / 0.75) + 1);\n            for (int i = urlParam.KEY.nextSetBit(0); i >= 0; i = urlParam.KEY.nextSetBit(i + 1)) {\n                String value;\n                int offset = urlParam.keyIndexToOffset(i);\n                value = DynamicParamTable.getValue(i, offset);\n                set.add(new Node(DynamicParamTable.getKey(i), value));\n            }\n\n            for (Entry<String, String> entry : urlParam.EXTRA_PARAMS.entrySet()) {\n                set.add(new Node(entry.getKey(), entry.getValue()));\n            }\n            return Collections.unmodifiableSet(set);\n        }\n\n        public URLParam getUrlParam() {\n            return urlParam;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n            URLParamMap that = (URLParamMap) o;\n            return Objects.equals(urlParam, that.urlParam);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(urlParam);\n        }\n    }\n\n    /**\n     * Get a Map like URLParam\n     *\n     * @return a {@link URLParamMap} adapt to URLParam\n     */\n    public Map<String, String> getParameters() {\n        return new URLParamMap(this);\n    }\n\n    /**\n     * Get any method related parameter which match key\n     *\n     * @param key key\n     * @return result ( if any, random choose one )\n     */\n    public String getAnyMethodParameter(String key) {\n        Map<String, String> methodMap = METHOD_PARAMETERS.get(key);\n        if (CollectionUtils.isNotEmptyMap(methodMap)) {\n            String methods = getParameter(METHODS_KEY);\n            if (StringUtils.isNotEmpty(methods)) {\n                for (String method : methods.split(\",\")) {\n                    String value = methodMap.get(method);\n                    if (StringUtils.isNotEmpty(value)) {\n                        return value;\n                    }\n                }\n            } else {\n                return methodMap.values().iterator().next();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Add parameters to a new URLParam.\n     *\n     * @param key   key\n     * @param value value\n     * @return A new URLParam\n     */\n    public URLParam addParameter(String key, String value) {\n        if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value)) {\n            return this;\n        }\n        return addParameters(Collections.singletonMap(key, value));\n    }\n\n    /**\n     * Add absent parameters to a new URLParam.\n     *\n     * @param key   key\n     * @param value value\n     * @return A new URLParam\n     */\n    public URLParam addParameterIfAbsent(String key, String value) {\n        if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value)) {\n            return this;\n        }\n        if (hasParameter(key)) {\n            return this;\n        }\n        return addParametersIfAbsent(Collections.singletonMap(key, value));\n    }\n\n    /**\n     * Add parameters to a new URLParam.\n     * If key-pair is present, this will cover it.\n     *\n     * @param parameters parameters in key-value pairs\n     * @return A new URLParam\n     */\n    public URLParam addParameters(Map<String, String> parameters) {\n        if (CollectionUtils.isEmptyMap(parameters)) {\n            return this;\n        }\n\n        boolean hasAndEqual = true;\n        Map<String, String> urlParamMap = getParameters();\n        for (Map.Entry<String, String> entry : parameters.entrySet()) {\n            String value = urlParamMap.get(entry.getKey());\n            if (value == null) {\n                if (entry.getValue() != null) {\n                    hasAndEqual = false;\n                    break;\n                }\n            } else {\n                if (!value.equals(entry.getValue())) {\n                    hasAndEqual = false;\n                    break;\n                }\n            }\n        }\n        // return immediately if there's no change\n        if (hasAndEqual) {\n            return this;\n        }\n\n        return doAddParameters(parameters, false);\n    }\n\n    /**\n     * Add absent parameters to a new URLParam.\n     *\n     * @param parameters parameters in key-value pairs\n     * @return A new URL\n     */\n    public URLParam addParametersIfAbsent(Map<String, String> parameters) {\n        if (CollectionUtils.isEmptyMap(parameters)) {\n            return this;\n        }\n\n        return doAddParameters(parameters, true);\n    }\n\n    private URLParam doAddParameters(Map<String, String> parameters, boolean skipIfPresent) {\n        // lazy init, null if no modify\n        BitSet newKey = null;\n        int[] newValueArray = null;\n        Map<Integer, Integer> newValueMap = null;\n        Map<String, String> newExtraParams = null;\n        Map<String, Map<String, String>> newMethodParams = null;\n        for (Map.Entry<String, String> entry : parameters.entrySet()) {\n            if (skipIfPresent && hasParameter(entry.getKey())) {\n                continue;\n            }\n            if (entry.getKey() == null || entry.getValue() == null) {\n                continue;\n            }\n            int keyIndex = DynamicParamTable.getKeyIndex(enableCompressed, entry.getKey());\n            if (keyIndex < 0) {\n                // entry key is not present in DynamicParamTable, add it to EXTRA_PARAMS\n                if (newExtraParams == null) {\n                    newExtraParams = new HashMap<>(EXTRA_PARAMS);\n                }\n                newExtraParams.put(entry.getKey(), entry.getValue());\n                String[] methodSplit = entry.getKey().split(\"\\\\.\");\n                if (methodSplit.length == 2) {\n                    if (newMethodParams == null) {\n                        newMethodParams = new HashMap<>(METHOD_PARAMETERS);\n                    }\n                    Map<String, String> methodMap =\n                            newMethodParams.computeIfAbsent(methodSplit[1], (k) -> new HashMap<>());\n                    methodMap.put(methodSplit[0], entry.getValue());\n                }\n            } else {\n                if (KEY.get(keyIndex)) {\n                    // contains key, replace value\n                    if (parameters.size() > ADD_PARAMETER_ON_MOVE_THRESHOLD) {\n                        // recover VALUE back to Map, use map to replace key pair\n                        if (newValueMap == null) {\n                            newValueMap = recoverValue();\n                        }\n                        newValueMap.put(keyIndex, DynamicParamTable.getValueIndex(entry.getKey(), entry.getValue()));\n                    } else {\n                        newValueArray = replaceOffset(\n                                VALUE,\n                                keyIndexToIndex(KEY, keyIndex),\n                                DynamicParamTable.getValueIndex(entry.getKey(), entry.getValue()));\n                    }\n                } else {\n                    // key is absent, add it\n                    if (newKey == null) {\n                        newKey = (BitSet) KEY.clone();\n                    }\n                    newKey.set(keyIndex);\n\n                    if (parameters.size() > ADD_PARAMETER_ON_MOVE_THRESHOLD) {\n                        // recover VALUE back to Map\n                        if (newValueMap == null) {\n                            newValueMap = recoverValue();\n                        }\n                        newValueMap.put(keyIndex, DynamicParamTable.getValueIndex(entry.getKey(), entry.getValue()));\n                    } else {\n                        // add parameter by moving array, only support for adding once\n                        newValueArray = addByMove(\n                                VALUE,\n                                keyIndexToIndex(newKey, keyIndex),\n                                DynamicParamTable.getValueIndex(entry.getKey(), entry.getValue()));\n                    }\n                }\n            }\n        }\n        if (newKey == null) {\n            newKey = KEY;\n        }\n        if (newValueArray == null && newValueMap == null) {\n            newValueArray = VALUE;\n        }\n        if (newExtraParams == null) {\n            newExtraParams = EXTRA_PARAMS;\n        }\n        if (newMethodParams == null) {\n            newMethodParams = METHOD_PARAMETERS;\n        }\n        if (newValueMap == null) {\n            return new URLParam(newKey, newValueArray, newExtraParams, newMethodParams, null);\n        } else {\n            return new URLParam(newKey, newValueMap, newExtraParams, newMethodParams, null);\n        }\n    }\n\n    private Map<Integer, Integer> recoverValue() {\n        Map<Integer, Integer> map = new HashMap<>((int) (KEY.size() / 0.75) + 1);\n        for (int i = KEY.nextSetBit(0), offset = 0; i >= 0; i = KEY.nextSetBit(i + 1)) {\n            map.put(i, VALUE[offset++]);\n        }\n        return map;\n    }\n\n    private int[] addByMove(int[] array, int index, Integer value) {\n        if (index < 0 || index > array.length) {\n            throw new IllegalArgumentException();\n        }\n        // copy-on-write\n        int[] result = new int[array.length + 1];\n\n        System.arraycopy(array, 0, result, 0, index);\n        result[index] = value;\n        System.arraycopy(array, index, result, index + 1, array.length - index);\n\n        return result;\n    }\n\n    private int[] replaceOffset(int[] array, int index, Integer value) {\n        if (index < 0 || index > array.length) {\n            throw new IllegalArgumentException();\n        }\n        // copy-on-write\n        int[] result = new int[array.length];\n\n        System.arraycopy(array, 0, result, 0, array.length);\n        result[index] = value;\n\n        return result;\n    }\n\n    /**\n     * remove specified parameters in URLParam\n     *\n     * @param keys keys to being removed\n     * @return A new URLParam\n     */\n    public URLParam removeParameters(String... keys) {\n        if (keys == null || keys.length == 0) {\n            return this;\n        }\n        // lazy init, null if no modify\n        BitSet newKey = null;\n        int[] newValueArray = null;\n        Map<String, String> newExtraParams = null;\n        Map<String, Map<String, String>> newMethodParams = null;\n        for (String key : keys) {\n            int keyIndex = DynamicParamTable.getKeyIndex(enableCompressed, key);\n            if (keyIndex >= 0 && KEY.get(keyIndex)) {\n                if (newKey == null) {\n                    newKey = (BitSet) KEY.clone();\n                }\n                newKey.clear(keyIndex);\n                // which offset is in VALUE array, set value as -1, compress in the end\n                if (newValueArray == null) {\n                    newValueArray = new int[VALUE.length];\n                    System.arraycopy(VALUE, 0, newValueArray, 0, VALUE.length);\n                }\n                // KEY is immutable\n                newValueArray[keyIndexToIndex(KEY, keyIndex)] = -1;\n            }\n            if (EXTRA_PARAMS.containsKey(key)) {\n                if (newExtraParams == null) {\n                    newExtraParams = new HashMap<>(EXTRA_PARAMS);\n                }\n                newExtraParams.remove(key);\n\n                String[] methodSplit = key.split(\"\\\\.\");\n                if (methodSplit.length == 2) {\n                    if (newMethodParams == null) {\n                        newMethodParams = new HashMap<>(METHOD_PARAMETERS);\n                    }\n                    Map<String, String> methodMap = newMethodParams.get(methodSplit[1]);\n                    if (CollectionUtils.isNotEmptyMap(methodMap)) {\n                        methodMap.remove(methodSplit[0]);\n                    }\n                }\n            }\n            // ignore if key is absent\n        }\n        if (newKey == null) {\n            newKey = KEY;\n        }\n        if (newValueArray == null) {\n            newValueArray = VALUE;\n        } else {\n            // remove -1 value\n            newValueArray = compressArray(newValueArray);\n        }\n        if (newExtraParams == null) {\n            newExtraParams = EXTRA_PARAMS;\n        }\n        if (newMethodParams == null) {\n            newMethodParams = METHOD_PARAMETERS;\n        }\n        if (newKey.cardinality() + newExtraParams.size() == 0) {\n            // empty, directly return cache\n            return EMPTY_PARAM;\n        } else {\n            return new URLParam(newKey, newValueArray, newExtraParams, newMethodParams, null);\n        }\n    }\n\n    private int[] compressArray(int[] array) {\n        int total = 0;\n        for (int i : array) {\n            if (i > -1) {\n                total++;\n            }\n        }\n        if (total == 0) {\n            return new int[0];\n        }\n\n        int[] result = new int[total];\n        for (int i = 0, offset = 0; i < array.length; i++) {\n            // skip if value if less than 0\n            if (array[i] > -1) {\n                result[offset++] = array[i];\n            }\n        }\n        return result;\n    }\n\n    /**\n     * remove all of the parameters in URLParam\n     *\n     * @return An empty URLParam\n     */\n    public URLParam clearParameters() {\n        return EMPTY_PARAM;\n    }\n\n    /**\n     * check if specified key is present in URLParam\n     *\n     * @param key specified key\n     * @return present or not\n     */\n    public boolean hasParameter(String key) {\n        int keyIndex = DynamicParamTable.getKeyIndex(enableCompressed, key);\n        if (keyIndex < 0) {\n            return EXTRA_PARAMS.containsKey(key);\n        }\n        return KEY.get(keyIndex);\n    }\n\n    /**\n     * get value of specified key in URLParam\n     *\n     * @param key specified key\n     * @return value, null if key is absent\n     */\n    public String getParameter(String key) {\n        int keyIndex = DynamicParamTable.getKeyIndex(enableCompressed, key);\n        if (keyIndex < 0) {\n            return EXTRA_PARAMS.get(key);\n        }\n        if (KEY.get(keyIndex)) {\n            String value;\n            int offset = keyIndexToOffset(keyIndex);\n            value = DynamicParamTable.getValue(keyIndex, offset);\n\n            return value;\n            //            if (StringUtils.isEmpty(value)) {\n            //                // Forward compatible, make sure key dynamic increment can work.\n            //                // In that case, some values which are proceed before increment will set in EXTRA_PARAMS.\n            //                return EXTRA_PARAMS.get(key);\n            //            } else {\n            //                return value;\n            //            }\n        }\n        return null;\n    }\n\n    private int keyIndexToIndex(BitSet key, int keyIndex) {\n        return key.get(0, keyIndex).cardinality();\n    }\n\n    private int keyIndexToOffset(int keyIndex) {\n        int arrayOffset = keyIndexToIndex(KEY, keyIndex);\n        return VALUE[arrayOffset];\n    }\n\n    /**\n     * get raw string like parameters\n     *\n     * @return raw string like parameters\n     */\n    public String getRawParam() {\n        if (StringUtils.isNotEmpty(rawParam)) {\n            return rawParam;\n        } else {\n            // empty if parameters have been modified or init by Map\n            return toString();\n        }\n    }\n\n    protected Map<String, Map<String, String>> getMethodParameters() {\n        return METHOD_PARAMETERS;\n    }\n\n    public long getTimestamp() {\n        return timestamp;\n    }\n\n    public void setTimestamp(long timestamp) {\n        this.timestamp = timestamp;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        URLParam urlParam = (URLParam) o;\n\n        if (Objects.equals(KEY, urlParam.KEY) && Arrays.equals(VALUE, urlParam.VALUE)) {\n            if (CollectionUtils.isNotEmptyMap(EXTRA_PARAMS)) {\n                if (CollectionUtils.isEmptyMap(urlParam.EXTRA_PARAMS)\n                        || EXTRA_PARAMS.size() != urlParam.EXTRA_PARAMS.size()) {\n                    return false;\n                }\n                for (Map.Entry<String, String> entry : EXTRA_PARAMS.entrySet()) {\n                    if (TIMESTAMP_KEY.equals(entry.getKey())) {\n                        continue;\n                    }\n                    if (!entry.getValue().equals(urlParam.EXTRA_PARAMS.get(entry.getKey()))) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return CollectionUtils.isEmptyMap(urlParam.EXTRA_PARAMS);\n        }\n        return false;\n    }\n\n    private int hashCodeCache = -1;\n\n    @Override\n    public int hashCode() {\n        if (hashCodeCache == -1) {\n            for (Map.Entry<String, String> entry : EXTRA_PARAMS.entrySet()) {\n                if (!TIMESTAMP_KEY.equals(entry.getKey())) {\n                    hashCodeCache = hashCodeCache * 31 + Objects.hashCode(entry);\n                }\n            }\n            for (Integer value : VALUE) {\n                hashCodeCache = hashCodeCache * 31 + value;\n            }\n            hashCodeCache = hashCodeCache * 31 + ((KEY == null) ? 0 : KEY.hashCode());\n        }\n        return hashCodeCache;\n    }\n\n    @Override\n    public String toString() {\n        if (StringUtils.isNotEmpty(rawParam)) {\n            return rawParam;\n        }\n        if ((KEY.cardinality() + EXTRA_PARAMS.size()) == 0) {\n            return \"\";\n        }\n\n        StringJoiner stringJoiner = new StringJoiner(\"&\");\n        for (int i = KEY.nextSetBit(0); i >= 0; i = KEY.nextSetBit(i + 1)) {\n            String key = DynamicParamTable.getKey(i);\n            String value = DynamicParamTable.getValue(i, keyIndexToOffset(i));\n            value = value == null ? \"\" : value.trim();\n            stringJoiner.add(String.format(\"%s=%s\", key, value));\n        }\n        for (Map.Entry<String, String> entry : EXTRA_PARAMS.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            value = value == null ? \"\" : value.trim();\n            stringJoiner.add(String.format(\"%s=%s\", key, value));\n        }\n\n        return stringJoiner.toString();\n    }\n\n    /**\n     * Parse URLParam\n     * Init URLParam by constructor is not allowed\n     * rawParam field in result will be null while {@link URLParam#getRawParam()} will automatically create it\n     *\n     * @param params params map added into URLParam\n     * @return a new URLParam\n     */\n    public static URLParam parse(Map<String, String> params) {\n        return parse(params, null);\n    }\n\n    /**\n     * Parse URLParam\n     * Init URLParam by constructor is not allowed\n     *\n     * @param rawParam        original rawParam string\n     * @param encoded         if parameters are URL encoded\n     * @param extraParameters extra parameters to add into URLParam\n     * @return a new URLParam\n     */\n    public static URLParam parse(String rawParam, boolean encoded, Map<String, String> extraParameters) {\n        Map<String, String> parameters = URLStrParser.parseParams(rawParam, encoded);\n        if (CollectionUtils.isNotEmptyMap(extraParameters)) {\n            parameters.putAll(extraParameters);\n        }\n        return parse(parameters, rawParam);\n    }\n\n    /**\n     * Parse URLParam\n     * Init URLParam by constructor is not allowed\n     *\n     * @param rawParam original rawParam string\n     * @return a new URLParam\n     */\n    public static URLParam parse(String rawParam) {\n        String[] parts = rawParam.split(\"&\");\n\n        int capacity = (int) (parts.length / .75f) + 1;\n        BitSet keyBit = new BitSet(capacity);\n        Map<Integer, Integer> valueMap = new HashMap<>(capacity);\n        Map<String, String> extraParam = new HashMap<>(capacity);\n        Map<String, Map<String, String>> methodParameters = new HashMap<>(capacity);\n\n        for (String part : parts) {\n            part = part.trim();\n            if (part.length() > 0) {\n                int j = part.indexOf('=');\n                if (j >= 0) {\n                    String key = part.substring(0, j);\n                    String value = part.substring(j + 1);\n                    addParameter(keyBit, valueMap, extraParam, methodParameters, key, value, false);\n                    // compatible with lower versions registering \"default.\" keys\n                    if (key.startsWith(DEFAULT_KEY_PREFIX)) {\n                        addParameter(\n                                keyBit,\n                                valueMap,\n                                extraParam,\n                                methodParameters,\n                                key.substring(DEFAULT_KEY_PREFIX.length()),\n                                value,\n                                true);\n                    }\n                } else {\n                    addParameter(keyBit, valueMap, extraParam, methodParameters, part, part, false);\n                }\n            }\n        }\n        return new URLParam(keyBit, valueMap, extraParam, methodParameters, rawParam);\n    }\n\n    /**\n     * Parse URLParam\n     * Init URLParam by constructor is not allowed\n     *\n     * @param params   params map added into URLParam\n     * @param rawParam original rawParam string, directly add to rawParam field,\n     *                 will not affect real key-pairs store in URLParam.\n     *                 Please make sure it can correspond with params or will\n     *                 cause unexpected result when calling {@link URLParam#getRawParam()}\n     *                 and {@link URLParam#toString()} ()}. If you not sure, you can call\n     *                 {@link URLParam#parse(String)} to init.\n     * @return a new URLParam\n     */\n    public static URLParam parse(Map<String, String> params, String rawParam) {\n        if (CollectionUtils.isNotEmptyMap(params)) {\n            int capacity = (int) (params.size() / .75f) + 1;\n            BitSet keyBit = new BitSet(capacity);\n            Map<Integer, Integer> valueMap = new HashMap<>(capacity);\n            Map<String, String> extraParam = new HashMap<>(capacity);\n            Map<String, Map<String, String>> methodParameters = new HashMap<>(capacity);\n\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                String key = entry.getKey();\n                String value = entry.getValue();\n                addParameter(keyBit, valueMap, extraParam, methodParameters, key, value, false);\n                // compatible with lower versions registering \"default.\" keys\n                if (key.startsWith(DEFAULT_KEY_PREFIX)) {\n                    addParameter(\n                            keyBit,\n                            valueMap,\n                            extraParam,\n                            methodParameters,\n                            key.substring(DEFAULT_KEY_PREFIX.length()),\n                            value,\n                            true);\n                }\n            }\n            return new URLParam(keyBit, valueMap, extraParam, methodParameters, rawParam);\n        } else {\n            return EMPTY_PARAM;\n        }\n    }\n\n    private static void addParameter(\n            BitSet keyBit,\n            Map<Integer, Integer> valueMap,\n            Map<String, String> extraParam,\n            Map<String, Map<String, String>> methodParameters,\n            String key,\n            String value,\n            boolean skipIfPresent) {\n        int keyIndex = DynamicParamTable.getKeyIndex(true, key);\n        if (skipIfPresent) {\n            if (keyIndex < 0) {\n                if (extraParam.containsKey(key)) {\n                    return;\n                }\n            } else {\n                if (keyBit.get(keyIndex)) {\n                    return;\n                }\n            }\n        }\n\n        if (keyIndex < 0) {\n            extraParam.put(key, value);\n            String[] methodSplit = key.split(\"\\\\.\", 2);\n            if (methodSplit.length == 2) {\n                Map<String, String> methodMap =\n                        methodParameters.computeIfAbsent(methodSplit[1], (k) -> new HashMap<>());\n                methodMap.put(methodSplit[0], value);\n            }\n        } else {\n            valueMap.put(keyIndex, DynamicParamTable.getValueIndex(key, value));\n            keyBit.set(keyIndex);\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 110,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLParam.java",
        "line": 138,
        "sink": "java.util.Collections.unmodifiableMap",
        "source": "-",
        "sourceLine": 138,
        "qualifier": "Call to java.util.Collections.unmodifiableMap with untrusted data from [getQueryString(...) : String](1).\nCall to java.util.Collections.unmodifiableMap with untrusted data from [getRequestURL(...) : StringBuffer](2).",
        "line_number": 138,
        "steps": [
            {
                "line": 126,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "methodName": null,
                "exampleID": 111
            },
            {
                "line": 126,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "methodName": null,
                "exampleID": 111
            },
            {
                "line": 128,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "methodName": null,
                "exampleID": 111
            },
            {
                "line": 128,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "methodName": null,
                "exampleID": 111
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/AtomicPositiveInteger.java#L54",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n\npublic class AtomicPositiveInteger extends Number {\n\n    private static final long serialVersionUID = -3038533876489105940L;\n\n    private static final AtomicIntegerFieldUpdater<AtomicPositiveInteger> INDEX_UPDATER =\n            AtomicIntegerFieldUpdater.newUpdater(AtomicPositiveInteger.class, \"index\");\n\n    @SuppressWarnings(\"unused\")\n    private volatile int index = 0;\n\n    public AtomicPositiveInteger() {}\n\n    public AtomicPositiveInteger(int initialValue) {\n        INDEX_UPDATER.set(this, initialValue);\n    }\n\n    public final int getAndIncrement() {\n        return INDEX_UPDATER.getAndIncrement(this) & Integer.MAX_VALUE;\n    }\n\n    public final int getAndDecrement() {\n        return INDEX_UPDATER.getAndDecrement(this) & Integer.MAX_VALUE;\n    }\n\n    public final int incrementAndGet() {\n        return INDEX_UPDATER.incrementAndGet(this) & Integer.MAX_VALUE;\n    }\n\n    public final int decrementAndGet() {\n        return INDEX_UPDATER.decrementAndGet(this) & Integer.MAX_VALUE;\n    }\n\n    public final int get() {\n        return INDEX_UPDATER.get(this) & Integer.MAX_VALUE;\n    }\n\n    public final void set(int newValue) {\n        if (newValue < 0) {\n            throw new IllegalArgumentException(\"new value \" + newValue + \" < 0\");\n        }\n        INDEX_UPDATER.set(this, newValue);\n    }\n\n    public final int getAndSet(int newValue) {\n        if (newValue < 0) {\n            throw new IllegalArgumentException(\"new value \" + newValue + \" < 0\");\n        }\n        return INDEX_UPDATER.getAndSet(this, newValue) & Integer.MAX_VALUE;\n    }\n\n    public final int getAndAdd(int delta) {\n        if (delta < 0) {\n            throw new IllegalArgumentException(\"delta \" + delta + \" < 0\");\n        }\n        return INDEX_UPDATER.getAndAdd(this, delta) & Integer.MAX_VALUE;\n    }\n\n    public final int addAndGet(int delta) {\n        if (delta < 0) {\n            throw new IllegalArgumentException(\"delta \" + delta + \" < 0\");\n        }\n        return INDEX_UPDATER.addAndGet(this, delta) & Integer.MAX_VALUE;\n    }\n\n    public final boolean compareAndSet(int expect, int update) {\n        if (update < 0) {\n            throw new IllegalArgumentException(\"update value \" + update + \" < 0\");\n        }\n        return INDEX_UPDATER.compareAndSet(this, expect, update);\n    }\n\n    public final boolean weakCompareAndSet(int expect, int update) {\n        if (update < 0) {\n            throw new IllegalArgumentException(\"update value \" + update + \" < 0\");\n        }\n        return INDEX_UPDATER.weakCompareAndSet(this, expect, update);\n    }\n\n    @Override\n    public byte byteValue() {\n        return (byte) get();\n    }\n\n    @Override\n    public short shortValue() {\n        return (short) get();\n    }\n\n    @Override\n    public int intValue() {\n        return get();\n    }\n\n    @Override\n    public long longValue() {\n        return (long) get();\n    }\n\n    @Override\n    public float floatValue() {\n        return (float) get();\n    }\n\n    @Override\n    public double doubleValue() {\n        return (double) get();\n    }\n\n    @Override\n    public String toString() {\n        return Integer.toString(get());\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + get();\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof AtomicPositiveInteger)) {\n            return false;\n        }\n        AtomicPositiveInteger other = (AtomicPositiveInteger) obj;\n        return intValue() == other.intValue();\n    }\n}\n",
        "methodName": null,
        "exampleID": 112,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/AtomicPositiveInteger.java",
        "line": 54,
        "sink": "java.util.concurrent.atomic.AtomicIntegerFieldUpdater<AtomicPositiveInteger>.get",
        "source": "-",
        "sourceLine": 54,
        "qualifier": "Call to java.util.concurrent.atomic.AtomicIntegerFieldUpdater<AtomicPositiveInteger>.get with untrusted data from [msg : HttpRequest](1).\nCall to java.util.concurrent.atomic.AtomicIntegerFieldUpdater<AtomicPositiveInteger>.get with untrusted data from [msg : String](2).",
        "line_number": 54,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 113
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 113
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 113
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 113
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLParam.java#L1076",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.url.component;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.URLStrParser;\nimport org.apache.dubbo.common.url.component.param.DynamicParamTable;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.common.utils.StringUtils;\n\nimport java.util.AbstractMap;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.StringJoiner;\n\nimport static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_KEY_PREFIX;\nimport static org.apache.dubbo.common.constants.CommonConstants.METHODS_KEY;\nimport static org.apache.dubbo.common.constants.CommonConstants.TIMESTAMP_KEY;\n\n/**\n * A class which store parameters for {@link URL}\n * <br/>\n * Using {@link DynamicParamTable} to compress common keys (i.e. side, version)\n * <br/>\n * {@link DynamicParamTable} allow to use only two integer value named `key` and\n * `value-offset` to find a unique string to string key-pair. Also, `value-offset`\n * is not required if the real value is the default value.\n * <br/>\n * URLParam should operate as Copy-On-Write, each modify actions will return a new Object\n * <br/>\n * <p>\n * NOTE: URLParam is not support serialization! {@link DynamicParamTable} is related with\n * current running environment. If you want to make URL as a parameter, please call\n * {@link URL#toSerializableURL()} to create {@link URLPlainParam} instead.\n *\n * @since 3.0\n */\npublic class URLParam {\n\n    /**\n     * Maximum size of key-pairs requested using array moving to add into URLParam.\n     * If user request like addParameter for only one key-pair, adding value into a array\n     * on moving is more efficient. However when add more than ADD_PARAMETER_ON_MOVE_THRESHOLD\n     * size of key-pairs, recover compressed array back to map can reduce operation count\n     * when putting objects.\n     */\n    private static final int ADD_PARAMETER_ON_MOVE_THRESHOLD = 1;\n\n    /**\n     * the original parameters string, empty if parameters have been modified or init by {@link Map}\n     */\n    private final String rawParam;\n\n    /**\n     * using bit to save if index exist even if value is default value\n     */\n    private final BitSet KEY;\n\n    /**\n     * an array which contains value-offset\n     */\n    private final int[] VALUE;\n\n    /**\n     * store extra parameters which key not match in {@link DynamicParamTable}\n     */\n    private final Map<String, String> EXTRA_PARAMS;\n\n    /**\n     * store method related parameters\n     * <p>\n     * K - key\n     * V -\n     * K - method\n     * V - value\n     * <p>\n     * e.g. method1.mock=true => ( mock, (method1, true) )\n     */\n    private final Map<String, Map<String, String>> METHOD_PARAMETERS;\n\n    private transient long timestamp;\n\n    /**\n     * Whether to enable DynamicParamTable compression\n     */\n    protected boolean enableCompressed;\n\n    private static final URLParam EMPTY_PARAM =\n            new URLParam(new BitSet(0), Collections.emptyMap(), Collections.emptyMap(), Collections.emptyMap(), \"\");\n\n    protected URLParam() {\n        this.rawParam = null;\n        this.KEY = null;\n        this.VALUE = null;\n        this.EXTRA_PARAMS = null;\n        this.METHOD_PARAMETERS = null;\n        this.enableCompressed = true;\n    }\n\n    protected URLParam(\n            BitSet key,\n            Map<Integer, Integer> value,\n            Map<String, String> extraParams,\n            Map<String, Map<String, String>> methodParameters,\n            String rawParam) {\n        this.KEY = key;\n        this.VALUE = new int[value.size()];\n        for (int i = key.nextSetBit(0), offset = 0; i >= 0; i = key.nextSetBit(i + 1)) {\n            if (value.containsKey(i)) {\n                VALUE[offset++] = value.get(i);\n            } else {\n                throw new IllegalArgumentException();\n            }\n        }\n        this.EXTRA_PARAMS =\n                Collections.unmodifiableMap((extraParams == null ? new HashMap<>() : new HashMap<>(extraParams)));\n        this.METHOD_PARAMETERS = Collections.unmodifiableMap(\n                (methodParameters == null) ? Collections.emptyMap() : new LinkedHashMap<>(methodParameters));\n        this.rawParam = rawParam;\n\n        this.timestamp = System.currentTimeMillis();\n        this.enableCompressed = true;\n    }\n\n    protected URLParam(\n            BitSet key,\n            int[] value,\n            Map<String, String> extraParams,\n            Map<String, Map<String, String>> methodParameters,\n            String rawParam) {\n        this.KEY = key;\n        this.VALUE = value;\n        this.EXTRA_PARAMS =\n                Collections.unmodifiableMap((extraParams == null ? new HashMap<>() : new HashMap<>(extraParams)));\n        this.METHOD_PARAMETERS = Collections.unmodifiableMap(\n                (methodParameters == null) ? Collections.emptyMap() : new LinkedHashMap<>(methodParameters));\n        this.rawParam = rawParam;\n        this.timestamp = System.currentTimeMillis();\n        this.enableCompressed = true;\n    }\n\n    /**\n     * Weather there contains some parameter match method\n     *\n     * @param method method name\n     * @return contains or not\n     */\n    public boolean hasMethodParameter(String method) {\n        if (method == null) {\n            return false;\n        }\n\n        String methodsString = getParameter(METHODS_KEY);\n        if (StringUtils.isNotEmpty(methodsString)) {\n            if (!methodsString.contains(method)) {\n                return false;\n            }\n        }\n\n        for (Map.Entry<String, Map<String, String>> methods : METHOD_PARAMETERS.entrySet()) {\n            if (methods.getValue().containsKey(method)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Get method related parameter. If not contains, use getParameter(key) instead.\n     * Specially, in some situation like `method1.1.callback=true`, key is `1.callback`.\n     *\n     * @param method method name\n     * @param key    key\n     * @return value\n     */\n    public String getMethodParameter(String method, String key) {\n        String strictResult = getMethodParameterStrict(method, key);\n        return StringUtils.isNotEmpty(strictResult) ? strictResult : getParameter(key);\n    }\n\n    /**\n     * Get method related parameter. If not contains, return null.\n     * Specially, in some situation like `method1.1.callback=true`, key is `1.callback`.\n     *\n     * @param method method name\n     * @param key    key\n     * @return value\n     */\n    public String getMethodParameterStrict(String method, String key) {\n        String methodsString = getParameter(METHODS_KEY);\n        if (StringUtils.isNotEmpty(methodsString)) {\n            if (!methodsString.contains(method)) {\n                return null;\n            }\n        }\n\n        Map<String, String> methodMap = METHOD_PARAMETERS.get(key);\n        if (CollectionUtils.isNotEmptyMap(methodMap)) {\n            return methodMap.get(method);\n        } else {\n            return null;\n        }\n    }\n\n    public static Map<String, Map<String, String>> initMethodParameters(Map<String, String> parameters) {\n        Map<String, Map<String, String>> methodParameters = new HashMap<>();\n        if (parameters == null) {\n            return methodParameters;\n        }\n\n        String methodsString = parameters.get(METHODS_KEY);\n        if (StringUtils.isNotEmpty(methodsString)) {\n            String[] methods = methodsString.split(\",\");\n            for (Map.Entry<String, String> entry : parameters.entrySet()) {\n                String key = entry.getKey();\n                for (String method : methods) {\n                    String methodPrefix = method + '.';\n                    if (key.startsWith(methodPrefix)) {\n                        String realKey = key.substring(methodPrefix.length());\n                        URL.putMethodParameter(method, realKey, entry.getValue(), methodParameters);\n                    }\n                }\n            }\n        } else {\n            for (Map.Entry<String, String> entry : parameters.entrySet()) {\n                String key = entry.getKey();\n                int methodSeparator = key.indexOf('.');\n                if (methodSeparator > 0) {\n                    String method = key.substring(0, methodSeparator);\n                    String realKey = key.substring(methodSeparator + 1);\n                    URL.putMethodParameter(method, realKey, entry.getValue(), methodParameters);\n                }\n            }\n        }\n        return methodParameters;\n    }\n\n    /**\n     * An embedded Map adapt to URLParam\n     * <br/>\n     * copy-on-write mode, urlParam reference will be changed after modify actions.\n     * If wishes to get the result after modify, please use {@link URLParamMap#getUrlParam()}\n     */\n    public static class URLParamMap extends AbstractMap<String, String> {\n        private URLParam urlParam;\n\n        public URLParamMap(URLParam urlParam) {\n            this.urlParam = urlParam;\n        }\n\n        public static class Node implements Map.Entry<String, String> {\n            private final String key;\n            private String value;\n\n            public Node(String key, String value) {\n                this.key = key;\n                this.value = value;\n            }\n\n            @Override\n            public String getKey() {\n                return key;\n            }\n\n            @Override\n            public String getValue() {\n                return value;\n            }\n\n            @Override\n            public String setValue(String value) {\n                throw new UnsupportedOperationException();\n            }\n\n            @Override\n            public boolean equals(Object o) {\n                if (this == o) {\n                    return true;\n                }\n                if (o == null || getClass() != o.getClass()) {\n                    return false;\n                }\n                Node node = (Node) o;\n                return Objects.equals(key, node.key) && Objects.equals(value, node.value);\n            }\n\n            @Override\n            public int hashCode() {\n                return Objects.hash(key, value);\n            }\n        }\n\n        @Override\n        public int size() {\n            return urlParam.KEY.cardinality() + urlParam.EXTRA_PARAMS.size();\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return size() == 0;\n        }\n\n        @Override\n        public boolean containsKey(Object key) {\n            if (key instanceof String) {\n                return urlParam.hasParameter((String) key);\n            } else {\n                return false;\n            }\n        }\n\n        @Override\n        public boolean containsValue(Object value) {\n            return values().contains(value);\n        }\n\n        @Override\n        public String get(Object key) {\n            if (key instanceof String) {\n                return urlParam.getParameter((String) key);\n            } else {\n                return null;\n            }\n        }\n\n        @Override\n        public String put(String key, String value) {\n            String previous = urlParam.getParameter(key);\n            urlParam = urlParam.addParameter(key, value);\n            return previous;\n        }\n\n        @Override\n        public String remove(Object key) {\n            if (key instanceof String) {\n                String previous = urlParam.getParameter((String) key);\n                urlParam = urlParam.removeParameters((String) key);\n                return previous;\n            } else {\n                return null;\n            }\n        }\n\n        @Override\n        public void putAll(Map<? extends String, ? extends String> m) {\n            urlParam = urlParam.addParameters((Map<String, String>) m);\n        }\n\n        @Override\n        public void clear() {\n            urlParam = urlParam.clearParameters();\n        }\n\n        @Override\n        public Set<String> keySet() {\n            Set<String> set =\n                    new LinkedHashSet<>((int) ((urlParam.VALUE.length + urlParam.EXTRA_PARAMS.size()) / 0.75) + 1);\n            for (int i = urlParam.KEY.nextSetBit(0); i >= 0; i = urlParam.KEY.nextSetBit(i + 1)) {\n                set.add(DynamicParamTable.getKey(i));\n            }\n            for (Entry<String, String> entry : urlParam.EXTRA_PARAMS.entrySet()) {\n                set.add(entry.getKey());\n            }\n            return Collections.unmodifiableSet(set);\n        }\n\n        @Override\n        public Collection<String> values() {\n            Set<String> set =\n                    new LinkedHashSet<>((int) ((urlParam.VALUE.length + urlParam.EXTRA_PARAMS.size()) / 0.75) + 1);\n            for (int i = urlParam.KEY.nextSetBit(0); i >= 0; i = urlParam.KEY.nextSetBit(i + 1)) {\n                String value;\n                int offset = urlParam.keyIndexToOffset(i);\n                value = DynamicParamTable.getValue(i, offset);\n                set.add(value);\n            }\n\n            for (Entry<String, String> entry : urlParam.EXTRA_PARAMS.entrySet()) {\n                set.add(entry.getValue());\n            }\n            return Collections.unmodifiableSet(set);\n        }\n\n        @Override\n        public Set<Entry<String, String>> entrySet() {\n            Set<Entry<String, String>> set =\n                    new LinkedHashSet<>((int) ((urlParam.KEY.cardinality() + urlParam.EXTRA_PARAMS.size()) / 0.75) + 1);\n            for (int i = urlParam.KEY.nextSetBit(0); i >= 0; i = urlParam.KEY.nextSetBit(i + 1)) {\n                String value;\n                int offset = urlParam.keyIndexToOffset(i);\n                value = DynamicParamTable.getValue(i, offset);\n                set.add(new Node(DynamicParamTable.getKey(i), value));\n            }\n\n            for (Entry<String, String> entry : urlParam.EXTRA_PARAMS.entrySet()) {\n                set.add(new Node(entry.getKey(), entry.getValue()));\n            }\n            return Collections.unmodifiableSet(set);\n        }\n\n        public URLParam getUrlParam() {\n            return urlParam;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n            URLParamMap that = (URLParamMap) o;\n            return Objects.equals(urlParam, that.urlParam);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(urlParam);\n        }\n    }\n\n    /**\n     * Get a Map like URLParam\n     *\n     * @return a {@link URLParamMap} adapt to URLParam\n     */\n    public Map<String, String> getParameters() {\n        return new URLParamMap(this);\n    }\n\n    /**\n     * Get any method related parameter which match key\n     *\n     * @param key key\n     * @return result ( if any, random choose one )\n     */\n    public String getAnyMethodParameter(String key) {\n        Map<String, String> methodMap = METHOD_PARAMETERS.get(key);\n        if (CollectionUtils.isNotEmptyMap(methodMap)) {\n            String methods = getParameter(METHODS_KEY);\n            if (StringUtils.isNotEmpty(methods)) {\n                for (String method : methods.split(\",\")) {\n                    String value = methodMap.get(method);\n                    if (StringUtils.isNotEmpty(value)) {\n                        return value;\n                    }\n                }\n            } else {\n                return methodMap.values().iterator().next();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Add parameters to a new URLParam.\n     *\n     * @param key   key\n     * @param value value\n     * @return A new URLParam\n     */\n    public URLParam addParameter(String key, String value) {\n        if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value)) {\n            return this;\n        }\n        return addParameters(Collections.singletonMap(key, value));\n    }\n\n    /**\n     * Add absent parameters to a new URLParam.\n     *\n     * @param key   key\n     * @param value value\n     * @return A new URLParam\n     */\n    public URLParam addParameterIfAbsent(String key, String value) {\n        if (StringUtils.isEmpty(key) || StringUtils.isEmpty(value)) {\n            return this;\n        }\n        if (hasParameter(key)) {\n            return this;\n        }\n        return addParametersIfAbsent(Collections.singletonMap(key, value));\n    }\n\n    /**\n     * Add parameters to a new URLParam.\n     * If key-pair is present, this will cover it.\n     *\n     * @param parameters parameters in key-value pairs\n     * @return A new URLParam\n     */\n    public URLParam addParameters(Map<String, String> parameters) {\n        if (CollectionUtils.isEmptyMap(parameters)) {\n            return this;\n        }\n\n        boolean hasAndEqual = true;\n        Map<String, String> urlParamMap = getParameters();\n        for (Map.Entry<String, String> entry : parameters.entrySet()) {\n            String value = urlParamMap.get(entry.getKey());\n            if (value == null) {\n                if (entry.getValue() != null) {\n                    hasAndEqual = false;\n                    break;\n                }\n            } else {\n                if (!value.equals(entry.getValue())) {\n                    hasAndEqual = false;\n                    break;\n                }\n            }\n        }\n        // return immediately if there's no change\n        if (hasAndEqual) {\n            return this;\n        }\n\n        return doAddParameters(parameters, false);\n    }\n\n    /**\n     * Add absent parameters to a new URLParam.\n     *\n     * @param parameters parameters in key-value pairs\n     * @return A new URL\n     */\n    public URLParam addParametersIfAbsent(Map<String, String> parameters) {\n        if (CollectionUtils.isEmptyMap(parameters)) {\n            return this;\n        }\n\n        return doAddParameters(parameters, true);\n    }\n\n    private URLParam doAddParameters(Map<String, String> parameters, boolean skipIfPresent) {\n        // lazy init, null if no modify\n        BitSet newKey = null;\n        int[] newValueArray = null;\n        Map<Integer, Integer> newValueMap = null;\n        Map<String, String> newExtraParams = null;\n        Map<String, Map<String, String>> newMethodParams = null;\n        for (Map.Entry<String, String> entry : parameters.entrySet()) {\n            if (skipIfPresent && hasParameter(entry.getKey())) {\n                continue;\n            }\n            if (entry.getKey() == null || entry.getValue() == null) {\n                continue;\n            }\n            int keyIndex = DynamicParamTable.getKeyIndex(enableCompressed, entry.getKey());\n            if (keyIndex < 0) {\n                // entry key is not present in DynamicParamTable, add it to EXTRA_PARAMS\n                if (newExtraParams == null) {\n                    newExtraParams = new HashMap<>(EXTRA_PARAMS);\n                }\n                newExtraParams.put(entry.getKey(), entry.getValue());\n                String[] methodSplit = entry.getKey().split(\"\\\\.\");\n                if (methodSplit.length == 2) {\n                    if (newMethodParams == null) {\n                        newMethodParams = new HashMap<>(METHOD_PARAMETERS);\n                    }\n                    Map<String, String> methodMap =\n                            newMethodParams.computeIfAbsent(methodSplit[1], (k) -> new HashMap<>());\n                    methodMap.put(methodSplit[0], entry.getValue());\n                }\n            } else {\n                if (KEY.get(keyIndex)) {\n                    // contains key, replace value\n                    if (parameters.size() > ADD_PARAMETER_ON_MOVE_THRESHOLD) {\n                        // recover VALUE back to Map, use map to replace key pair\n                        if (newValueMap == null) {\n                            newValueMap = recoverValue();\n                        }\n                        newValueMap.put(keyIndex, DynamicParamTable.getValueIndex(entry.getKey(), entry.getValue()));\n                    } else {\n                        newValueArray = replaceOffset(\n                                VALUE,\n                                keyIndexToIndex(KEY, keyIndex),\n                                DynamicParamTable.getValueIndex(entry.getKey(), entry.getValue()));\n                    }\n                } else {\n                    // key is absent, add it\n                    if (newKey == null) {\n                        newKey = (BitSet) KEY.clone();\n                    }\n                    newKey.set(keyIndex);\n\n                    if (parameters.size() > ADD_PARAMETER_ON_MOVE_THRESHOLD) {\n                        // recover VALUE back to Map\n                        if (newValueMap == null) {\n                            newValueMap = recoverValue();\n                        }\n                        newValueMap.put(keyIndex, DynamicParamTable.getValueIndex(entry.getKey(), entry.getValue()));\n                    } else {\n                        // add parameter by moving array, only support for adding once\n                        newValueArray = addByMove(\n                                VALUE,\n                                keyIndexToIndex(newKey, keyIndex),\n                                DynamicParamTable.getValueIndex(entry.getKey(), entry.getValue()));\n                    }\n                }\n            }\n        }\n        if (newKey == null) {\n            newKey = KEY;\n        }\n        if (newValueArray == null && newValueMap == null) {\n            newValueArray = VALUE;\n        }\n        if (newExtraParams == null) {\n            newExtraParams = EXTRA_PARAMS;\n        }\n        if (newMethodParams == null) {\n            newMethodParams = METHOD_PARAMETERS;\n        }\n        if (newValueMap == null) {\n            return new URLParam(newKey, newValueArray, newExtraParams, newMethodParams, null);\n        } else {\n            return new URLParam(newKey, newValueMap, newExtraParams, newMethodParams, null);\n        }\n    }\n\n    private Map<Integer, Integer> recoverValue() {\n        Map<Integer, Integer> map = new HashMap<>((int) (KEY.size() / 0.75) + 1);\n        for (int i = KEY.nextSetBit(0), offset = 0; i >= 0; i = KEY.nextSetBit(i + 1)) {\n            map.put(i, VALUE[offset++]);\n        }\n        return map;\n    }\n\n    private int[] addByMove(int[] array, int index, Integer value) {\n        if (index < 0 || index > array.length) {\n            throw new IllegalArgumentException();\n        }\n        // copy-on-write\n        int[] result = new int[array.length + 1];\n\n        System.arraycopy(array, 0, result, 0, index);\n        result[index] = value;\n        System.arraycopy(array, index, result, index + 1, array.length - index);\n\n        return result;\n    }\n\n    private int[] replaceOffset(int[] array, int index, Integer value) {\n        if (index < 0 || index > array.length) {\n            throw new IllegalArgumentException();\n        }\n        // copy-on-write\n        int[] result = new int[array.length];\n\n        System.arraycopy(array, 0, result, 0, array.length);\n        result[index] = value;\n\n        return result;\n    }\n\n    /**\n     * remove specified parameters in URLParam\n     *\n     * @param keys keys to being removed\n     * @return A new URLParam\n     */\n    public URLParam removeParameters(String... keys) {\n        if (keys == null || keys.length == 0) {\n            return this;\n        }\n        // lazy init, null if no modify\n        BitSet newKey = null;\n        int[] newValueArray = null;\n        Map<String, String> newExtraParams = null;\n        Map<String, Map<String, String>> newMethodParams = null;\n        for (String key : keys) {\n            int keyIndex = DynamicParamTable.getKeyIndex(enableCompressed, key);\n            if (keyIndex >= 0 && KEY.get(keyIndex)) {\n                if (newKey == null) {\n                    newKey = (BitSet) KEY.clone();\n                }\n                newKey.clear(keyIndex);\n                // which offset is in VALUE array, set value as -1, compress in the end\n                if (newValueArray == null) {\n                    newValueArray = new int[VALUE.length];\n                    System.arraycopy(VALUE, 0, newValueArray, 0, VALUE.length);\n                }\n                // KEY is immutable\n                newValueArray[keyIndexToIndex(KEY, keyIndex)] = -1;\n            }\n            if (EXTRA_PARAMS.containsKey(key)) {\n                if (newExtraParams == null) {\n                    newExtraParams = new HashMap<>(EXTRA_PARAMS);\n                }\n                newExtraParams.remove(key);\n\n                String[] methodSplit = key.split(\"\\\\.\");\n                if (methodSplit.length == 2) {\n                    if (newMethodParams == null) {\n                        newMethodParams = new HashMap<>(METHOD_PARAMETERS);\n                    }\n                    Map<String, String> methodMap = newMethodParams.get(methodSplit[1]);\n                    if (CollectionUtils.isNotEmptyMap(methodMap)) {\n                        methodMap.remove(methodSplit[0]);\n                    }\n                }\n            }\n            // ignore if key is absent\n        }\n        if (newKey == null) {\n            newKey = KEY;\n        }\n        if (newValueArray == null) {\n            newValueArray = VALUE;\n        } else {\n            // remove -1 value\n            newValueArray = compressArray(newValueArray);\n        }\n        if (newExtraParams == null) {\n            newExtraParams = EXTRA_PARAMS;\n        }\n        if (newMethodParams == null) {\n            newMethodParams = METHOD_PARAMETERS;\n        }\n        if (newKey.cardinality() + newExtraParams.size() == 0) {\n            // empty, directly return cache\n            return EMPTY_PARAM;\n        } else {\n            return new URLParam(newKey, newValueArray, newExtraParams, newMethodParams, null);\n        }\n    }\n\n    private int[] compressArray(int[] array) {\n        int total = 0;\n        for (int i : array) {\n            if (i > -1) {\n                total++;\n            }\n        }\n        if (total == 0) {\n            return new int[0];\n        }\n\n        int[] result = new int[total];\n        for (int i = 0, offset = 0; i < array.length; i++) {\n            // skip if value if less than 0\n            if (array[i] > -1) {\n                result[offset++] = array[i];\n            }\n        }\n        return result;\n    }\n\n    /**\n     * remove all of the parameters in URLParam\n     *\n     * @return An empty URLParam\n     */\n    public URLParam clearParameters() {\n        return EMPTY_PARAM;\n    }\n\n    /**\n     * check if specified key is present in URLParam\n     *\n     * @param key specified key\n     * @return present or not\n     */\n    public boolean hasParameter(String key) {\n        int keyIndex = DynamicParamTable.getKeyIndex(enableCompressed, key);\n        if (keyIndex < 0) {\n            return EXTRA_PARAMS.containsKey(key);\n        }\n        return KEY.get(keyIndex);\n    }\n\n    /**\n     * get value of specified key in URLParam\n     *\n     * @param key specified key\n     * @return value, null if key is absent\n     */\n    public String getParameter(String key) {\n        int keyIndex = DynamicParamTable.getKeyIndex(enableCompressed, key);\n        if (keyIndex < 0) {\n            return EXTRA_PARAMS.get(key);\n        }\n        if (KEY.get(keyIndex)) {\n            String value;\n            int offset = keyIndexToOffset(keyIndex);\n            value = DynamicParamTable.getValue(keyIndex, offset);\n\n            return value;\n            //            if (StringUtils.isEmpty(value)) {\n            //                // Forward compatible, make sure key dynamic increment can work.\n            //                // In that case, some values which are proceed before increment will set in EXTRA_PARAMS.\n            //                return EXTRA_PARAMS.get(key);\n            //            } else {\n            //                return value;\n            //            }\n        }\n        return null;\n    }\n\n    private int keyIndexToIndex(BitSet key, int keyIndex) {\n        return key.get(0, keyIndex).cardinality();\n    }\n\n    private int keyIndexToOffset(int keyIndex) {\n        int arrayOffset = keyIndexToIndex(KEY, keyIndex);\n        return VALUE[arrayOffset];\n    }\n\n    /**\n     * get raw string like parameters\n     *\n     * @return raw string like parameters\n     */\n    public String getRawParam() {\n        if (StringUtils.isNotEmpty(rawParam)) {\n            return rawParam;\n        } else {\n            // empty if parameters have been modified or init by Map\n            return toString();\n        }\n    }\n\n    protected Map<String, Map<String, String>> getMethodParameters() {\n        return METHOD_PARAMETERS;\n    }\n\n    public long getTimestamp() {\n        return timestamp;\n    }\n\n    public void setTimestamp(long timestamp) {\n        this.timestamp = timestamp;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        URLParam urlParam = (URLParam) o;\n\n        if (Objects.equals(KEY, urlParam.KEY) && Arrays.equals(VALUE, urlParam.VALUE)) {\n            if (CollectionUtils.isNotEmptyMap(EXTRA_PARAMS)) {\n                if (CollectionUtils.isEmptyMap(urlParam.EXTRA_PARAMS)\n                        || EXTRA_PARAMS.size() != urlParam.EXTRA_PARAMS.size()) {\n                    return false;\n                }\n                for (Map.Entry<String, String> entry : EXTRA_PARAMS.entrySet()) {\n                    if (TIMESTAMP_KEY.equals(entry.getKey())) {\n                        continue;\n                    }\n                    if (!entry.getValue().equals(urlParam.EXTRA_PARAMS.get(entry.getKey()))) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            return CollectionUtils.isEmptyMap(urlParam.EXTRA_PARAMS);\n        }\n        return false;\n    }\n\n    private int hashCodeCache = -1;\n\n    @Override\n    public int hashCode() {\n        if (hashCodeCache == -1) {\n            for (Map.Entry<String, String> entry : EXTRA_PARAMS.entrySet()) {\n                if (!TIMESTAMP_KEY.equals(entry.getKey())) {\n                    hashCodeCache = hashCodeCache * 31 + Objects.hashCode(entry);\n                }\n            }\n            for (Integer value : VALUE) {\n                hashCodeCache = hashCodeCache * 31 + value;\n            }\n            hashCodeCache = hashCodeCache * 31 + ((KEY == null) ? 0 : KEY.hashCode());\n        }\n        return hashCodeCache;\n    }\n\n    @Override\n    public String toString() {\n        if (StringUtils.isNotEmpty(rawParam)) {\n            return rawParam;\n        }\n        if ((KEY.cardinality() + EXTRA_PARAMS.size()) == 0) {\n            return \"\";\n        }\n\n        StringJoiner stringJoiner = new StringJoiner(\"&\");\n        for (int i = KEY.nextSetBit(0); i >= 0; i = KEY.nextSetBit(i + 1)) {\n            String key = DynamicParamTable.getKey(i);\n            String value = DynamicParamTable.getValue(i, keyIndexToOffset(i));\n            value = value == null ? \"\" : value.trim();\n            stringJoiner.add(String.format(\"%s=%s\", key, value));\n        }\n        for (Map.Entry<String, String> entry : EXTRA_PARAMS.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            value = value == null ? \"\" : value.trim();\n            stringJoiner.add(String.format(\"%s=%s\", key, value));\n        }\n\n        return stringJoiner.toString();\n    }\n\n    /**\n     * Parse URLParam\n     * Init URLParam by constructor is not allowed\n     * rawParam field in result will be null while {@link URLParam#getRawParam()} will automatically create it\n     *\n     * @param params params map added into URLParam\n     * @return a new URLParam\n     */\n    public static URLParam parse(Map<String, String> params) {\n        return parse(params, null);\n    }\n\n    /**\n     * Parse URLParam\n     * Init URLParam by constructor is not allowed\n     *\n     * @param rawParam        original rawParam string\n     * @param encoded         if parameters are URL encoded\n     * @param extraParameters extra parameters to add into URLParam\n     * @return a new URLParam\n     */\n    public static URLParam parse(String rawParam, boolean encoded, Map<String, String> extraParameters) {\n        Map<String, String> parameters = URLStrParser.parseParams(rawParam, encoded);\n        if (CollectionUtils.isNotEmptyMap(extraParameters)) {\n            parameters.putAll(extraParameters);\n        }\n        return parse(parameters, rawParam);\n    }\n\n    /**\n     * Parse URLParam\n     * Init URLParam by constructor is not allowed\n     *\n     * @param rawParam original rawParam string\n     * @return a new URLParam\n     */\n    public static URLParam parse(String rawParam) {\n        String[] parts = rawParam.split(\"&\");\n\n        int capacity = (int) (parts.length / .75f) + 1;\n        BitSet keyBit = new BitSet(capacity);\n        Map<Integer, Integer> valueMap = new HashMap<>(capacity);\n        Map<String, String> extraParam = new HashMap<>(capacity);\n        Map<String, Map<String, String>> methodParameters = new HashMap<>(capacity);\n\n        for (String part : parts) {\n            part = part.trim();\n            if (part.length() > 0) {\n                int j = part.indexOf('=');\n                if (j >= 0) {\n                    String key = part.substring(0, j);\n                    String value = part.substring(j + 1);\n                    addParameter(keyBit, valueMap, extraParam, methodParameters, key, value, false);\n                    // compatible with lower versions registering \"default.\" keys\n                    if (key.startsWith(DEFAULT_KEY_PREFIX)) {\n                        addParameter(\n                                keyBit,\n                                valueMap,\n                                extraParam,\n                                methodParameters,\n                                key.substring(DEFAULT_KEY_PREFIX.length()),\n                                value,\n                                true);\n                    }\n                } else {\n                    addParameter(keyBit, valueMap, extraParam, methodParameters, part, part, false);\n                }\n            }\n        }\n        return new URLParam(keyBit, valueMap, extraParam, methodParameters, rawParam);\n    }\n\n    /**\n     * Parse URLParam\n     * Init URLParam by constructor is not allowed\n     *\n     * @param params   params map added into URLParam\n     * @param rawParam original rawParam string, directly add to rawParam field,\n     *                 will not affect real key-pairs store in URLParam.\n     *                 Please make sure it can correspond with params or will\n     *                 cause unexpected result when calling {@link URLParam#getRawParam()}\n     *                 and {@link URLParam#toString()} ()}. If you not sure, you can call\n     *                 {@link URLParam#parse(String)} to init.\n     * @return a new URLParam\n     */\n    public static URLParam parse(Map<String, String> params, String rawParam) {\n        if (CollectionUtils.isNotEmptyMap(params)) {\n            int capacity = (int) (params.size() / .75f) + 1;\n            BitSet keyBit = new BitSet(capacity);\n            Map<Integer, Integer> valueMap = new HashMap<>(capacity);\n            Map<String, String> extraParam = new HashMap<>(capacity);\n            Map<String, Map<String, String>> methodParameters = new HashMap<>(capacity);\n\n            for (Map.Entry<String, String> entry : params.entrySet()) {\n                String key = entry.getKey();\n                String value = entry.getValue();\n                addParameter(keyBit, valueMap, extraParam, methodParameters, key, value, false);\n                // compatible with lower versions registering \"default.\" keys\n                if (key.startsWith(DEFAULT_KEY_PREFIX)) {\n                    addParameter(\n                            keyBit,\n                            valueMap,\n                            extraParam,\n                            methodParameters,\n                            key.substring(DEFAULT_KEY_PREFIX.length()),\n                            value,\n                            true);\n                }\n            }\n            return new URLParam(keyBit, valueMap, extraParam, methodParameters, rawParam);\n        } else {\n            return EMPTY_PARAM;\n        }\n    }\n\n    private static void addParameter(\n            BitSet keyBit,\n            Map<Integer, Integer> valueMap,\n            Map<String, String> extraParam,\n            Map<String, Map<String, String>> methodParameters,\n            String key,\n            String value,\n            boolean skipIfPresent) {\n        int keyIndex = DynamicParamTable.getKeyIndex(true, key);\n        if (skipIfPresent) {\n            if (keyIndex < 0) {\n                if (extraParam.containsKey(key)) {\n                    return;\n                }\n            } else {\n                if (keyBit.get(keyIndex)) {\n                    return;\n                }\n            }\n        }\n\n        if (keyIndex < 0) {\n            extraParam.put(key, value);\n            String[] methodSplit = key.split(\"\\\\.\", 2);\n            if (methodSplit.length == 2) {\n                Map<String, String> methodMap =\n                        methodParameters.computeIfAbsent(methodSplit[1], (k) -> new HashMap<>());\n                methodMap.put(methodSplit[0], value);\n            }\n        } else {\n            valueMap.put(keyIndex, DynamicParamTable.getValueIndex(key, value));\n            keyBit.set(keyIndex);\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 114,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/url/component/URLParam.java",
        "line": 1076,
        "sink": "java.util.Map<String,Map<String,String>>.computeIfAbsent",
        "source": "-",
        "sourceLine": 1076,
        "qualifier": "Call to java.util.Map<String,Map<String,String>>.computeIfAbsent with untrusted data from [getQueryString(...) : String](1).\nCall to java.util.Map<String,Map<String,String>>.computeIfAbsent with untrusted data from [getRequestURL(...) : StringBuffer](2).",
        "line_number": 1076,
        "steps": [
            {
                "line": 126,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "methodName": null,
                "exampleID": 115
            },
            {
                "line": 126,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "methodName": null,
                "exampleID": 115
            },
            {
                "line": 128,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "methodName": null,
                "exampleID": 115
            },
            {
                "line": 128,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "methodName": null,
                "exampleID": 115
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java#L74",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CompatibleTypeUtils {\n\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n\n    /**\n     * the text to parse such as \"2007-12-03T10:15:30\"\n     */\n    private static final int ISO_LOCAL_DATE_TIME_MIN_LEN = 19;\n\n    private CompatibleTypeUtils() {}\n\n    /**\n     * Compatible type convert. Null value is allowed to pass in. If no conversion is needed, then the original value\n     * will be returned.\n     * <p>\n     * Supported compatible type conversions include (primary types and corresponding wrappers are not listed):\n     * <ul>\n     * <li> String -> char, enum, Date\n     * <li> byte, short, int, long -> byte, short, int, long\n     * <li> float, double -> float, double\n     * </ul>\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static Object compatibleTypeConvert(Object value, Class<?> type) {\n        if (value == null || type == null || type.isAssignableFrom(value.getClass())) {\n            return value;\n        }\n\n        if (value instanceof String) {\n            String string = (String) value;\n            if (char.class.equals(type) || Character.class.equals(type)) {\n                if (string.length() != 1) {\n                    throw new IllegalArgumentException(String.format(\n                            \"CAN NOT convert String(%s) to char!\"\n                                    + \" when convert String to char, the String MUST only 1 char.\",\n                            string));\n                }\n                return string.charAt(0);\n            }\n            if (type.isEnum()) {\n                return Enum.valueOf((Class<Enum>) type, string);\n            }\n            if (type == BigInteger.class) {\n                return new BigInteger(string);\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(string);\n            }\n            if (type == Short.class || type == short.class) {\n                return new Short(string);\n            }\n            if (type == Integer.class || type == int.class) {\n                return new Integer(string);\n            }\n            if (type == Long.class || type == long.class) {\n                return new Long(string);\n            }\n            if (type == Double.class || type == double.class) {\n                return new Double(string);\n            }\n            if (type == Float.class || type == float.class) {\n                return new Float(string);\n            }\n            if (type == Byte.class || type == byte.class) {\n                return new Byte(string);\n            }\n            if (type == Boolean.class || type == boolean.class) {\n                return Boolean.valueOf(string);\n            }\n            if (type == Date.class\n                    || type == java.sql.Date.class\n                    || type == java.sql.Timestamp.class\n                    || type == java.sql.Time.class) {\n                try {\n                    Date date = new SimpleDateFormat(DATE_FORMAT).parse(string);\n                    if (type == java.sql.Date.class) {\n                        return new java.sql.Date(date.getTime());\n                    }\n                    if (type == java.sql.Timestamp.class) {\n                        return new java.sql.Timestamp(date.getTime());\n                    }\n                    if (type == java.sql.Time.class) {\n                        return new java.sql.Time(date.getTime());\n                    }\n                    return date;\n                } catch (ParseException e) {\n                    throw new IllegalStateException(\n                            \"Failed to parse date \" + value + \" by format \" + DATE_FORMAT + \", cause: \"\n                                    + e.getMessage(),\n                            e);\n                }\n            }\n            if (type == java.time.LocalDateTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDateTime.parse(string);\n            }\n            if (type == java.time.LocalDate.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDate.parse(string);\n            }\n            if (type == java.time.LocalTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n\n                if (string.length() >= ISO_LOCAL_DATE_TIME_MIN_LEN) {\n                    return LocalDateTime.parse(string).toLocalTime();\n                } else {\n                    return LocalTime.parse(string);\n                }\n            }\n            if (type == Class.class) {\n                try {\n                    return ReflectUtils.name2class(string);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n            if (char[].class.equals(type)) {\n                // Process string to char array for generic invoke\n                // See\n                // - https://github.com/apache/dubbo/issues/2003\n                int len = string.length();\n                char[] chars = new char[len];\n                string.getChars(0, len, chars, 0);\n                return chars;\n            }\n        }\n        if (value instanceof Number) {\n            Number number = (Number) value;\n            if (type == byte.class || type == Byte.class) {\n                return number.byteValue();\n            }\n            if (type == short.class || type == Short.class) {\n                return number.shortValue();\n            }\n            if (type == int.class || type == Integer.class) {\n                return number.intValue();\n            }\n            if (type == long.class || type == Long.class) {\n                return number.longValue();\n            }\n            if (type == float.class || type == Float.class) {\n                return number.floatValue();\n            }\n            if (type == double.class || type == Double.class) {\n                return number.doubleValue();\n            }\n            if (type == BigInteger.class) {\n                return BigInteger.valueOf(number.longValue());\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(number.toString());\n            }\n            if (type == Date.class) {\n                return new Date(number.longValue());\n            }\n            if (type == boolean.class || type == Boolean.class) {\n                return 0 != number.intValue();\n            }\n        }\n        if (value instanceof Collection) {\n            Collection collection = (Collection) value;\n            if (type.isArray()) {\n                int length = collection.size();\n                Object array = Array.newInstance(type.getComponentType(), length);\n                int i = 0;\n                for (Object item : collection) {\n                    Array.set(array, i++, item);\n                }\n                return array;\n            }\n            if (!type.isInterface()) {\n                try {\n                    Collection result =\n                            (Collection) type.getDeclaredConstructor().newInstance();\n                    result.addAll(collection);\n                    return result;\n                } catch (Throwable ignored) {\n                }\n            }\n            if (type == List.class) {\n                return new ArrayList<Object>(collection);\n            }\n            if (type == Set.class) {\n                return new HashSet<Object>(collection);\n            }\n        }\n        if (value.getClass().isArray() && Collection.class.isAssignableFrom(type)) {\n            int length = Array.getLength(value);\n            Collection collection;\n            if (!type.isInterface()) {\n                try {\n                    collection = (Collection) type.getDeclaredConstructor().newInstance();\n                } catch (Exception e) {\n                    collection = new ArrayList<Object>(length);\n                }\n            } else if (type == Set.class) {\n                collection = new HashSet<Object>(Math.max((int) (length / .75f) + 1, 16));\n            } else {\n                collection = new ArrayList<Object>(length);\n            }\n            for (int i = 0; i < length; i++) {\n                collection.add(Array.get(value, i));\n            }\n            return collection;\n        }\n        return value;\n    }\n}\n",
        "methodName": null,
        "exampleID": 116,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java",
        "line": 74,
        "sink": "java.lang.Enum.valueOf",
        "source": "-",
        "sourceLine": 74,
        "qualifier": "Call to java.lang.Enum.valueOf with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.Enum.valueOf with untrusted data from [msg : String](2).",
        "line_number": 74,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 117
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 117
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 117
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 117
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java#L101",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CompatibleTypeUtils {\n\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n\n    /**\n     * the text to parse such as \"2007-12-03T10:15:30\"\n     */\n    private static final int ISO_LOCAL_DATE_TIME_MIN_LEN = 19;\n\n    private CompatibleTypeUtils() {}\n\n    /**\n     * Compatible type convert. Null value is allowed to pass in. If no conversion is needed, then the original value\n     * will be returned.\n     * <p>\n     * Supported compatible type conversions include (primary types and corresponding wrappers are not listed):\n     * <ul>\n     * <li> String -> char, enum, Date\n     * <li> byte, short, int, long -> byte, short, int, long\n     * <li> float, double -> float, double\n     * </ul>\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static Object compatibleTypeConvert(Object value, Class<?> type) {\n        if (value == null || type == null || type.isAssignableFrom(value.getClass())) {\n            return value;\n        }\n\n        if (value instanceof String) {\n            String string = (String) value;\n            if (char.class.equals(type) || Character.class.equals(type)) {\n                if (string.length() != 1) {\n                    throw new IllegalArgumentException(String.format(\n                            \"CAN NOT convert String(%s) to char!\"\n                                    + \" when convert String to char, the String MUST only 1 char.\",\n                            string));\n                }\n                return string.charAt(0);\n            }\n            if (type.isEnum()) {\n                return Enum.valueOf((Class<Enum>) type, string);\n            }\n            if (type == BigInteger.class) {\n                return new BigInteger(string);\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(string);\n            }\n            if (type == Short.class || type == short.class) {\n                return new Short(string);\n            }\n            if (type == Integer.class || type == int.class) {\n                return new Integer(string);\n            }\n            if (type == Long.class || type == long.class) {\n                return new Long(string);\n            }\n            if (type == Double.class || type == double.class) {\n                return new Double(string);\n            }\n            if (type == Float.class || type == float.class) {\n                return new Float(string);\n            }\n            if (type == Byte.class || type == byte.class) {\n                return new Byte(string);\n            }\n            if (type == Boolean.class || type == boolean.class) {\n                return Boolean.valueOf(string);\n            }\n            if (type == Date.class\n                    || type == java.sql.Date.class\n                    || type == java.sql.Timestamp.class\n                    || type == java.sql.Time.class) {\n                try {\n                    Date date = new SimpleDateFormat(DATE_FORMAT).parse(string);\n                    if (type == java.sql.Date.class) {\n                        return new java.sql.Date(date.getTime());\n                    }\n                    if (type == java.sql.Timestamp.class) {\n                        return new java.sql.Timestamp(date.getTime());\n                    }\n                    if (type == java.sql.Time.class) {\n                        return new java.sql.Time(date.getTime());\n                    }\n                    return date;\n                } catch (ParseException e) {\n                    throw new IllegalStateException(\n                            \"Failed to parse date \" + value + \" by format \" + DATE_FORMAT + \", cause: \"\n                                    + e.getMessage(),\n                            e);\n                }\n            }\n            if (type == java.time.LocalDateTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDateTime.parse(string);\n            }\n            if (type == java.time.LocalDate.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDate.parse(string);\n            }\n            if (type == java.time.LocalTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n\n                if (string.length() >= ISO_LOCAL_DATE_TIME_MIN_LEN) {\n                    return LocalDateTime.parse(string).toLocalTime();\n                } else {\n                    return LocalTime.parse(string);\n                }\n            }\n            if (type == Class.class) {\n                try {\n                    return ReflectUtils.name2class(string);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n            if (char[].class.equals(type)) {\n                // Process string to char array for generic invoke\n                // See\n                // - https://github.com/apache/dubbo/issues/2003\n                int len = string.length();\n                char[] chars = new char[len];\n                string.getChars(0, len, chars, 0);\n                return chars;\n            }\n        }\n        if (value instanceof Number) {\n            Number number = (Number) value;\n            if (type == byte.class || type == Byte.class) {\n                return number.byteValue();\n            }\n            if (type == short.class || type == Short.class) {\n                return number.shortValue();\n            }\n            if (type == int.class || type == Integer.class) {\n                return number.intValue();\n            }\n            if (type == long.class || type == Long.class) {\n                return number.longValue();\n            }\n            if (type == float.class || type == Float.class) {\n                return number.floatValue();\n            }\n            if (type == double.class || type == Double.class) {\n                return number.doubleValue();\n            }\n            if (type == BigInteger.class) {\n                return BigInteger.valueOf(number.longValue());\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(number.toString());\n            }\n            if (type == Date.class) {\n                return new Date(number.longValue());\n            }\n            if (type == boolean.class || type == Boolean.class) {\n                return 0 != number.intValue();\n            }\n        }\n        if (value instanceof Collection) {\n            Collection collection = (Collection) value;\n            if (type.isArray()) {\n                int length = collection.size();\n                Object array = Array.newInstance(type.getComponentType(), length);\n                int i = 0;\n                for (Object item : collection) {\n                    Array.set(array, i++, item);\n                }\n                return array;\n            }\n            if (!type.isInterface()) {\n                try {\n                    Collection result =\n                            (Collection) type.getDeclaredConstructor().newInstance();\n                    result.addAll(collection);\n                    return result;\n                } catch (Throwable ignored) {\n                }\n            }\n            if (type == List.class) {\n                return new ArrayList<Object>(collection);\n            }\n            if (type == Set.class) {\n                return new HashSet<Object>(collection);\n            }\n        }\n        if (value.getClass().isArray() && Collection.class.isAssignableFrom(type)) {\n            int length = Array.getLength(value);\n            Collection collection;\n            if (!type.isInterface()) {\n                try {\n                    collection = (Collection) type.getDeclaredConstructor().newInstance();\n                } catch (Exception e) {\n                    collection = new ArrayList<Object>(length);\n                }\n            } else if (type == Set.class) {\n                collection = new HashSet<Object>(Math.max((int) (length / .75f) + 1, 16));\n            } else {\n                collection = new ArrayList<Object>(length);\n            }\n            for (int i = 0; i < length; i++) {\n                collection.add(Array.get(value, i));\n            }\n            return collection;\n        }\n        return value;\n    }\n}\n",
        "methodName": null,
        "exampleID": 118,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java",
        "line": 101,
        "sink": "java.lang.Boolean.valueOf",
        "source": "-",
        "sourceLine": 101,
        "qualifier": "Call to java.lang.Boolean.valueOf with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.Boolean.valueOf with untrusted data from [msg : String](2).",
        "line_number": 101,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 119
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 119
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 119
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 119
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java#L108",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CompatibleTypeUtils {\n\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n\n    /**\n     * the text to parse such as \"2007-12-03T10:15:30\"\n     */\n    private static final int ISO_LOCAL_DATE_TIME_MIN_LEN = 19;\n\n    private CompatibleTypeUtils() {}\n\n    /**\n     * Compatible type convert. Null value is allowed to pass in. If no conversion is needed, then the original value\n     * will be returned.\n     * <p>\n     * Supported compatible type conversions include (primary types and corresponding wrappers are not listed):\n     * <ul>\n     * <li> String -> char, enum, Date\n     * <li> byte, short, int, long -> byte, short, int, long\n     * <li> float, double -> float, double\n     * </ul>\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static Object compatibleTypeConvert(Object value, Class<?> type) {\n        if (value == null || type == null || type.isAssignableFrom(value.getClass())) {\n            return value;\n        }\n\n        if (value instanceof String) {\n            String string = (String) value;\n            if (char.class.equals(type) || Character.class.equals(type)) {\n                if (string.length() != 1) {\n                    throw new IllegalArgumentException(String.format(\n                            \"CAN NOT convert String(%s) to char!\"\n                                    + \" when convert String to char, the String MUST only 1 char.\",\n                            string));\n                }\n                return string.charAt(0);\n            }\n            if (type.isEnum()) {\n                return Enum.valueOf((Class<Enum>) type, string);\n            }\n            if (type == BigInteger.class) {\n                return new BigInteger(string);\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(string);\n            }\n            if (type == Short.class || type == short.class) {\n                return new Short(string);\n            }\n            if (type == Integer.class || type == int.class) {\n                return new Integer(string);\n            }\n            if (type == Long.class || type == long.class) {\n                return new Long(string);\n            }\n            if (type == Double.class || type == double.class) {\n                return new Double(string);\n            }\n            if (type == Float.class || type == float.class) {\n                return new Float(string);\n            }\n            if (type == Byte.class || type == byte.class) {\n                return new Byte(string);\n            }\n            if (type == Boolean.class || type == boolean.class) {\n                return Boolean.valueOf(string);\n            }\n            if (type == Date.class\n                    || type == java.sql.Date.class\n                    || type == java.sql.Timestamp.class\n                    || type == java.sql.Time.class) {\n                try {\n                    Date date = new SimpleDateFormat(DATE_FORMAT).parse(string);\n                    if (type == java.sql.Date.class) {\n                        return new java.sql.Date(date.getTime());\n                    }\n                    if (type == java.sql.Timestamp.class) {\n                        return new java.sql.Timestamp(date.getTime());\n                    }\n                    if (type == java.sql.Time.class) {\n                        return new java.sql.Time(date.getTime());\n                    }\n                    return date;\n                } catch (ParseException e) {\n                    throw new IllegalStateException(\n                            \"Failed to parse date \" + value + \" by format \" + DATE_FORMAT + \", cause: \"\n                                    + e.getMessage(),\n                            e);\n                }\n            }\n            if (type == java.time.LocalDateTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDateTime.parse(string);\n            }\n            if (type == java.time.LocalDate.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDate.parse(string);\n            }\n            if (type == java.time.LocalTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n\n                if (string.length() >= ISO_LOCAL_DATE_TIME_MIN_LEN) {\n                    return LocalDateTime.parse(string).toLocalTime();\n                } else {\n                    return LocalTime.parse(string);\n                }\n            }\n            if (type == Class.class) {\n                try {\n                    return ReflectUtils.name2class(string);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n            if (char[].class.equals(type)) {\n                // Process string to char array for generic invoke\n                // See\n                // - https://github.com/apache/dubbo/issues/2003\n                int len = string.length();\n                char[] chars = new char[len];\n                string.getChars(0, len, chars, 0);\n                return chars;\n            }\n        }\n        if (value instanceof Number) {\n            Number number = (Number) value;\n            if (type == byte.class || type == Byte.class) {\n                return number.byteValue();\n            }\n            if (type == short.class || type == Short.class) {\n                return number.shortValue();\n            }\n            if (type == int.class || type == Integer.class) {\n                return number.intValue();\n            }\n            if (type == long.class || type == Long.class) {\n                return number.longValue();\n            }\n            if (type == float.class || type == Float.class) {\n                return number.floatValue();\n            }\n            if (type == double.class || type == Double.class) {\n                return number.doubleValue();\n            }\n            if (type == BigInteger.class) {\n                return BigInteger.valueOf(number.longValue());\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(number.toString());\n            }\n            if (type == Date.class) {\n                return new Date(number.longValue());\n            }\n            if (type == boolean.class || type == Boolean.class) {\n                return 0 != number.intValue();\n            }\n        }\n        if (value instanceof Collection) {\n            Collection collection = (Collection) value;\n            if (type.isArray()) {\n                int length = collection.size();\n                Object array = Array.newInstance(type.getComponentType(), length);\n                int i = 0;\n                for (Object item : collection) {\n                    Array.set(array, i++, item);\n                }\n                return array;\n            }\n            if (!type.isInterface()) {\n                try {\n                    Collection result =\n                            (Collection) type.getDeclaredConstructor().newInstance();\n                    result.addAll(collection);\n                    return result;\n                } catch (Throwable ignored) {\n                }\n            }\n            if (type == List.class) {\n                return new ArrayList<Object>(collection);\n            }\n            if (type == Set.class) {\n                return new HashSet<Object>(collection);\n            }\n        }\n        if (value.getClass().isArray() && Collection.class.isAssignableFrom(type)) {\n            int length = Array.getLength(value);\n            Collection collection;\n            if (!type.isInterface()) {\n                try {\n                    collection = (Collection) type.getDeclaredConstructor().newInstance();\n                } catch (Exception e) {\n                    collection = new ArrayList<Object>(length);\n                }\n            } else if (type == Set.class) {\n                collection = new HashSet<Object>(Math.max((int) (length / .75f) + 1, 16));\n            } else {\n                collection = new ArrayList<Object>(length);\n            }\n            for (int i = 0; i < length; i++) {\n                collection.add(Array.get(value, i));\n            }\n            return collection;\n        }\n        return value;\n    }\n}\n",
        "methodName": null,
        "exampleID": 120,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java",
        "line": 108,
        "sink": "java.text.DateFormat.parse",
        "source": "-",
        "sourceLine": 108,
        "qualifier": "Call to java.text.DateFormat.parse with untrusted data from [msg : HttpRequest](1).\nCall to java.text.DateFormat.parse with untrusted data from [msg : String](2).",
        "line_number": 108,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 121
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 121
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 121
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 121
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java#L130",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CompatibleTypeUtils {\n\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n\n    /**\n     * the text to parse such as \"2007-12-03T10:15:30\"\n     */\n    private static final int ISO_LOCAL_DATE_TIME_MIN_LEN = 19;\n\n    private CompatibleTypeUtils() {}\n\n    /**\n     * Compatible type convert. Null value is allowed to pass in. If no conversion is needed, then the original value\n     * will be returned.\n     * <p>\n     * Supported compatible type conversions include (primary types and corresponding wrappers are not listed):\n     * <ul>\n     * <li> String -> char, enum, Date\n     * <li> byte, short, int, long -> byte, short, int, long\n     * <li> float, double -> float, double\n     * </ul>\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static Object compatibleTypeConvert(Object value, Class<?> type) {\n        if (value == null || type == null || type.isAssignableFrom(value.getClass())) {\n            return value;\n        }\n\n        if (value instanceof String) {\n            String string = (String) value;\n            if (char.class.equals(type) || Character.class.equals(type)) {\n                if (string.length() != 1) {\n                    throw new IllegalArgumentException(String.format(\n                            \"CAN NOT convert String(%s) to char!\"\n                                    + \" when convert String to char, the String MUST only 1 char.\",\n                            string));\n                }\n                return string.charAt(0);\n            }\n            if (type.isEnum()) {\n                return Enum.valueOf((Class<Enum>) type, string);\n            }\n            if (type == BigInteger.class) {\n                return new BigInteger(string);\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(string);\n            }\n            if (type == Short.class || type == short.class) {\n                return new Short(string);\n            }\n            if (type == Integer.class || type == int.class) {\n                return new Integer(string);\n            }\n            if (type == Long.class || type == long.class) {\n                return new Long(string);\n            }\n            if (type == Double.class || type == double.class) {\n                return new Double(string);\n            }\n            if (type == Float.class || type == float.class) {\n                return new Float(string);\n            }\n            if (type == Byte.class || type == byte.class) {\n                return new Byte(string);\n            }\n            if (type == Boolean.class || type == boolean.class) {\n                return Boolean.valueOf(string);\n            }\n            if (type == Date.class\n                    || type == java.sql.Date.class\n                    || type == java.sql.Timestamp.class\n                    || type == java.sql.Time.class) {\n                try {\n                    Date date = new SimpleDateFormat(DATE_FORMAT).parse(string);\n                    if (type == java.sql.Date.class) {\n                        return new java.sql.Date(date.getTime());\n                    }\n                    if (type == java.sql.Timestamp.class) {\n                        return new java.sql.Timestamp(date.getTime());\n                    }\n                    if (type == java.sql.Time.class) {\n                        return new java.sql.Time(date.getTime());\n                    }\n                    return date;\n                } catch (ParseException e) {\n                    throw new IllegalStateException(\n                            \"Failed to parse date \" + value + \" by format \" + DATE_FORMAT + \", cause: \"\n                                    + e.getMessage(),\n                            e);\n                }\n            }\n            if (type == java.time.LocalDateTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDateTime.parse(string);\n            }\n            if (type == java.time.LocalDate.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDate.parse(string);\n            }\n            if (type == java.time.LocalTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n\n                if (string.length() >= ISO_LOCAL_DATE_TIME_MIN_LEN) {\n                    return LocalDateTime.parse(string).toLocalTime();\n                } else {\n                    return LocalTime.parse(string);\n                }\n            }\n            if (type == Class.class) {\n                try {\n                    return ReflectUtils.name2class(string);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n            if (char[].class.equals(type)) {\n                // Process string to char array for generic invoke\n                // See\n                // - https://github.com/apache/dubbo/issues/2003\n                int len = string.length();\n                char[] chars = new char[len];\n                string.getChars(0, len, chars, 0);\n                return chars;\n            }\n        }\n        if (value instanceof Number) {\n            Number number = (Number) value;\n            if (type == byte.class || type == Byte.class) {\n                return number.byteValue();\n            }\n            if (type == short.class || type == Short.class) {\n                return number.shortValue();\n            }\n            if (type == int.class || type == Integer.class) {\n                return number.intValue();\n            }\n            if (type == long.class || type == Long.class) {\n                return number.longValue();\n            }\n            if (type == float.class || type == Float.class) {\n                return number.floatValue();\n            }\n            if (type == double.class || type == Double.class) {\n                return number.doubleValue();\n            }\n            if (type == BigInteger.class) {\n                return BigInteger.valueOf(number.longValue());\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(number.toString());\n            }\n            if (type == Date.class) {\n                return new Date(number.longValue());\n            }\n            if (type == boolean.class || type == Boolean.class) {\n                return 0 != number.intValue();\n            }\n        }\n        if (value instanceof Collection) {\n            Collection collection = (Collection) value;\n            if (type.isArray()) {\n                int length = collection.size();\n                Object array = Array.newInstance(type.getComponentType(), length);\n                int i = 0;\n                for (Object item : collection) {\n                    Array.set(array, i++, item);\n                }\n                return array;\n            }\n            if (!type.isInterface()) {\n                try {\n                    Collection result =\n                            (Collection) type.getDeclaredConstructor().newInstance();\n                    result.addAll(collection);\n                    return result;\n                } catch (Throwable ignored) {\n                }\n            }\n            if (type == List.class) {\n                return new ArrayList<Object>(collection);\n            }\n            if (type == Set.class) {\n                return new HashSet<Object>(collection);\n            }\n        }\n        if (value.getClass().isArray() && Collection.class.isAssignableFrom(type)) {\n            int length = Array.getLength(value);\n            Collection collection;\n            if (!type.isInterface()) {\n                try {\n                    collection = (Collection) type.getDeclaredConstructor().newInstance();\n                } catch (Exception e) {\n                    collection = new ArrayList<Object>(length);\n                }\n            } else if (type == Set.class) {\n                collection = new HashSet<Object>(Math.max((int) (length / .75f) + 1, 16));\n            } else {\n                collection = new ArrayList<Object>(length);\n            }\n            for (int i = 0; i < length; i++) {\n                collection.add(Array.get(value, i));\n            }\n            return collection;\n        }\n        return value;\n    }\n}\n",
        "methodName": null,
        "exampleID": 122,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java",
        "line": 130,
        "sink": "java.time.LocalDateTime.parse",
        "source": "-",
        "sourceLine": 130,
        "qualifier": "Call to java.time.LocalDateTime.parse with untrusted data from [msg : HttpRequest](1).\nCall to java.time.LocalDateTime.parse with untrusted data from [msg : String](2).",
        "line_number": 130,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 123
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 123
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 123
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 123
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java#L136",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CompatibleTypeUtils {\n\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n\n    /**\n     * the text to parse such as \"2007-12-03T10:15:30\"\n     */\n    private static final int ISO_LOCAL_DATE_TIME_MIN_LEN = 19;\n\n    private CompatibleTypeUtils() {}\n\n    /**\n     * Compatible type convert. Null value is allowed to pass in. If no conversion is needed, then the original value\n     * will be returned.\n     * <p>\n     * Supported compatible type conversions include (primary types and corresponding wrappers are not listed):\n     * <ul>\n     * <li> String -> char, enum, Date\n     * <li> byte, short, int, long -> byte, short, int, long\n     * <li> float, double -> float, double\n     * </ul>\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static Object compatibleTypeConvert(Object value, Class<?> type) {\n        if (value == null || type == null || type.isAssignableFrom(value.getClass())) {\n            return value;\n        }\n\n        if (value instanceof String) {\n            String string = (String) value;\n            if (char.class.equals(type) || Character.class.equals(type)) {\n                if (string.length() != 1) {\n                    throw new IllegalArgumentException(String.format(\n                            \"CAN NOT convert String(%s) to char!\"\n                                    + \" when convert String to char, the String MUST only 1 char.\",\n                            string));\n                }\n                return string.charAt(0);\n            }\n            if (type.isEnum()) {\n                return Enum.valueOf((Class<Enum>) type, string);\n            }\n            if (type == BigInteger.class) {\n                return new BigInteger(string);\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(string);\n            }\n            if (type == Short.class || type == short.class) {\n                return new Short(string);\n            }\n            if (type == Integer.class || type == int.class) {\n                return new Integer(string);\n            }\n            if (type == Long.class || type == long.class) {\n                return new Long(string);\n            }\n            if (type == Double.class || type == double.class) {\n                return new Double(string);\n            }\n            if (type == Float.class || type == float.class) {\n                return new Float(string);\n            }\n            if (type == Byte.class || type == byte.class) {\n                return new Byte(string);\n            }\n            if (type == Boolean.class || type == boolean.class) {\n                return Boolean.valueOf(string);\n            }\n            if (type == Date.class\n                    || type == java.sql.Date.class\n                    || type == java.sql.Timestamp.class\n                    || type == java.sql.Time.class) {\n                try {\n                    Date date = new SimpleDateFormat(DATE_FORMAT).parse(string);\n                    if (type == java.sql.Date.class) {\n                        return new java.sql.Date(date.getTime());\n                    }\n                    if (type == java.sql.Timestamp.class) {\n                        return new java.sql.Timestamp(date.getTime());\n                    }\n                    if (type == java.sql.Time.class) {\n                        return new java.sql.Time(date.getTime());\n                    }\n                    return date;\n                } catch (ParseException e) {\n                    throw new IllegalStateException(\n                            \"Failed to parse date \" + value + \" by format \" + DATE_FORMAT + \", cause: \"\n                                    + e.getMessage(),\n                            e);\n                }\n            }\n            if (type == java.time.LocalDateTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDateTime.parse(string);\n            }\n            if (type == java.time.LocalDate.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDate.parse(string);\n            }\n            if (type == java.time.LocalTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n\n                if (string.length() >= ISO_LOCAL_DATE_TIME_MIN_LEN) {\n                    return LocalDateTime.parse(string).toLocalTime();\n                } else {\n                    return LocalTime.parse(string);\n                }\n            }\n            if (type == Class.class) {\n                try {\n                    return ReflectUtils.name2class(string);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n            if (char[].class.equals(type)) {\n                // Process string to char array for generic invoke\n                // See\n                // - https://github.com/apache/dubbo/issues/2003\n                int len = string.length();\n                char[] chars = new char[len];\n                string.getChars(0, len, chars, 0);\n                return chars;\n            }\n        }\n        if (value instanceof Number) {\n            Number number = (Number) value;\n            if (type == byte.class || type == Byte.class) {\n                return number.byteValue();\n            }\n            if (type == short.class || type == Short.class) {\n                return number.shortValue();\n            }\n            if (type == int.class || type == Integer.class) {\n                return number.intValue();\n            }\n            if (type == long.class || type == Long.class) {\n                return number.longValue();\n            }\n            if (type == float.class || type == Float.class) {\n                return number.floatValue();\n            }\n            if (type == double.class || type == Double.class) {\n                return number.doubleValue();\n            }\n            if (type == BigInteger.class) {\n                return BigInteger.valueOf(number.longValue());\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(number.toString());\n            }\n            if (type == Date.class) {\n                return new Date(number.longValue());\n            }\n            if (type == boolean.class || type == Boolean.class) {\n                return 0 != number.intValue();\n            }\n        }\n        if (value instanceof Collection) {\n            Collection collection = (Collection) value;\n            if (type.isArray()) {\n                int length = collection.size();\n                Object array = Array.newInstance(type.getComponentType(), length);\n                int i = 0;\n                for (Object item : collection) {\n                    Array.set(array, i++, item);\n                }\n                return array;\n            }\n            if (!type.isInterface()) {\n                try {\n                    Collection result =\n                            (Collection) type.getDeclaredConstructor().newInstance();\n                    result.addAll(collection);\n                    return result;\n                } catch (Throwable ignored) {\n                }\n            }\n            if (type == List.class) {\n                return new ArrayList<Object>(collection);\n            }\n            if (type == Set.class) {\n                return new HashSet<Object>(collection);\n            }\n        }\n        if (value.getClass().isArray() && Collection.class.isAssignableFrom(type)) {\n            int length = Array.getLength(value);\n            Collection collection;\n            if (!type.isInterface()) {\n                try {\n                    collection = (Collection) type.getDeclaredConstructor().newInstance();\n                } catch (Exception e) {\n                    collection = new ArrayList<Object>(length);\n                }\n            } else if (type == Set.class) {\n                collection = new HashSet<Object>(Math.max((int) (length / .75f) + 1, 16));\n            } else {\n                collection = new ArrayList<Object>(length);\n            }\n            for (int i = 0; i < length; i++) {\n                collection.add(Array.get(value, i));\n            }\n            return collection;\n        }\n        return value;\n    }\n}\n",
        "methodName": null,
        "exampleID": 124,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java",
        "line": 136,
        "sink": "java.time.LocalDate.parse",
        "source": "-",
        "sourceLine": 136,
        "qualifier": "Call to java.time.LocalDate.parse with untrusted data from [msg : HttpRequest](1).\nCall to java.time.LocalDate.parse with untrusted data from [msg : String](2).",
        "line_number": 136,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 125
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 125
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 125
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 125
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java#L144",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CompatibleTypeUtils {\n\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n\n    /**\n     * the text to parse such as \"2007-12-03T10:15:30\"\n     */\n    private static final int ISO_LOCAL_DATE_TIME_MIN_LEN = 19;\n\n    private CompatibleTypeUtils() {}\n\n    /**\n     * Compatible type convert. Null value is allowed to pass in. If no conversion is needed, then the original value\n     * will be returned.\n     * <p>\n     * Supported compatible type conversions include (primary types and corresponding wrappers are not listed):\n     * <ul>\n     * <li> String -> char, enum, Date\n     * <li> byte, short, int, long -> byte, short, int, long\n     * <li> float, double -> float, double\n     * </ul>\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static Object compatibleTypeConvert(Object value, Class<?> type) {\n        if (value == null || type == null || type.isAssignableFrom(value.getClass())) {\n            return value;\n        }\n\n        if (value instanceof String) {\n            String string = (String) value;\n            if (char.class.equals(type) || Character.class.equals(type)) {\n                if (string.length() != 1) {\n                    throw new IllegalArgumentException(String.format(\n                            \"CAN NOT convert String(%s) to char!\"\n                                    + \" when convert String to char, the String MUST only 1 char.\",\n                            string));\n                }\n                return string.charAt(0);\n            }\n            if (type.isEnum()) {\n                return Enum.valueOf((Class<Enum>) type, string);\n            }\n            if (type == BigInteger.class) {\n                return new BigInteger(string);\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(string);\n            }\n            if (type == Short.class || type == short.class) {\n                return new Short(string);\n            }\n            if (type == Integer.class || type == int.class) {\n                return new Integer(string);\n            }\n            if (type == Long.class || type == long.class) {\n                return new Long(string);\n            }\n            if (type == Double.class || type == double.class) {\n                return new Double(string);\n            }\n            if (type == Float.class || type == float.class) {\n                return new Float(string);\n            }\n            if (type == Byte.class || type == byte.class) {\n                return new Byte(string);\n            }\n            if (type == Boolean.class || type == boolean.class) {\n                return Boolean.valueOf(string);\n            }\n            if (type == Date.class\n                    || type == java.sql.Date.class\n                    || type == java.sql.Timestamp.class\n                    || type == java.sql.Time.class) {\n                try {\n                    Date date = new SimpleDateFormat(DATE_FORMAT).parse(string);\n                    if (type == java.sql.Date.class) {\n                        return new java.sql.Date(date.getTime());\n                    }\n                    if (type == java.sql.Timestamp.class) {\n                        return new java.sql.Timestamp(date.getTime());\n                    }\n                    if (type == java.sql.Time.class) {\n                        return new java.sql.Time(date.getTime());\n                    }\n                    return date;\n                } catch (ParseException e) {\n                    throw new IllegalStateException(\n                            \"Failed to parse date \" + value + \" by format \" + DATE_FORMAT + \", cause: \"\n                                    + e.getMessage(),\n                            e);\n                }\n            }\n            if (type == java.time.LocalDateTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDateTime.parse(string);\n            }\n            if (type == java.time.LocalDate.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDate.parse(string);\n            }\n            if (type == java.time.LocalTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n\n                if (string.length() >= ISO_LOCAL_DATE_TIME_MIN_LEN) {\n                    return LocalDateTime.parse(string).toLocalTime();\n                } else {\n                    return LocalTime.parse(string);\n                }\n            }\n            if (type == Class.class) {\n                try {\n                    return ReflectUtils.name2class(string);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n            if (char[].class.equals(type)) {\n                // Process string to char array for generic invoke\n                // See\n                // - https://github.com/apache/dubbo/issues/2003\n                int len = string.length();\n                char[] chars = new char[len];\n                string.getChars(0, len, chars, 0);\n                return chars;\n            }\n        }\n        if (value instanceof Number) {\n            Number number = (Number) value;\n            if (type == byte.class || type == Byte.class) {\n                return number.byteValue();\n            }\n            if (type == short.class || type == Short.class) {\n                return number.shortValue();\n            }\n            if (type == int.class || type == Integer.class) {\n                return number.intValue();\n            }\n            if (type == long.class || type == Long.class) {\n                return number.longValue();\n            }\n            if (type == float.class || type == Float.class) {\n                return number.floatValue();\n            }\n            if (type == double.class || type == Double.class) {\n                return number.doubleValue();\n            }\n            if (type == BigInteger.class) {\n                return BigInteger.valueOf(number.longValue());\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(number.toString());\n            }\n            if (type == Date.class) {\n                return new Date(number.longValue());\n            }\n            if (type == boolean.class || type == Boolean.class) {\n                return 0 != number.intValue();\n            }\n        }\n        if (value instanceof Collection) {\n            Collection collection = (Collection) value;\n            if (type.isArray()) {\n                int length = collection.size();\n                Object array = Array.newInstance(type.getComponentType(), length);\n                int i = 0;\n                for (Object item : collection) {\n                    Array.set(array, i++, item);\n                }\n                return array;\n            }\n            if (!type.isInterface()) {\n                try {\n                    Collection result =\n                            (Collection) type.getDeclaredConstructor().newInstance();\n                    result.addAll(collection);\n                    return result;\n                } catch (Throwable ignored) {\n                }\n            }\n            if (type == List.class) {\n                return new ArrayList<Object>(collection);\n            }\n            if (type == Set.class) {\n                return new HashSet<Object>(collection);\n            }\n        }\n        if (value.getClass().isArray() && Collection.class.isAssignableFrom(type)) {\n            int length = Array.getLength(value);\n            Collection collection;\n            if (!type.isInterface()) {\n                try {\n                    collection = (Collection) type.getDeclaredConstructor().newInstance();\n                } catch (Exception e) {\n                    collection = new ArrayList<Object>(length);\n                }\n            } else if (type == Set.class) {\n                collection = new HashSet<Object>(Math.max((int) (length / .75f) + 1, 16));\n            } else {\n                collection = new ArrayList<Object>(length);\n            }\n            for (int i = 0; i < length; i++) {\n                collection.add(Array.get(value, i));\n            }\n            return collection;\n        }\n        return value;\n    }\n}\n",
        "methodName": null,
        "exampleID": 126,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java",
        "line": 144,
        "sink": "java.time.LocalDateTime.parse",
        "source": "-",
        "sourceLine": 144,
        "qualifier": "Call to java.time.LocalDateTime.parse with untrusted data from [msg : HttpRequest](1).\nCall to java.time.LocalDateTime.parse with untrusted data from [msg : String](2).",
        "line_number": 144,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 127
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 127
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 127
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 127
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java#L146",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CompatibleTypeUtils {\n\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n\n    /**\n     * the text to parse such as \"2007-12-03T10:15:30\"\n     */\n    private static final int ISO_LOCAL_DATE_TIME_MIN_LEN = 19;\n\n    private CompatibleTypeUtils() {}\n\n    /**\n     * Compatible type convert. Null value is allowed to pass in. If no conversion is needed, then the original value\n     * will be returned.\n     * <p>\n     * Supported compatible type conversions include (primary types and corresponding wrappers are not listed):\n     * <ul>\n     * <li> String -> char, enum, Date\n     * <li> byte, short, int, long -> byte, short, int, long\n     * <li> float, double -> float, double\n     * </ul>\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static Object compatibleTypeConvert(Object value, Class<?> type) {\n        if (value == null || type == null || type.isAssignableFrom(value.getClass())) {\n            return value;\n        }\n\n        if (value instanceof String) {\n            String string = (String) value;\n            if (char.class.equals(type) || Character.class.equals(type)) {\n                if (string.length() != 1) {\n                    throw new IllegalArgumentException(String.format(\n                            \"CAN NOT convert String(%s) to char!\"\n                                    + \" when convert String to char, the String MUST only 1 char.\",\n                            string));\n                }\n                return string.charAt(0);\n            }\n            if (type.isEnum()) {\n                return Enum.valueOf((Class<Enum>) type, string);\n            }\n            if (type == BigInteger.class) {\n                return new BigInteger(string);\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(string);\n            }\n            if (type == Short.class || type == short.class) {\n                return new Short(string);\n            }\n            if (type == Integer.class || type == int.class) {\n                return new Integer(string);\n            }\n            if (type == Long.class || type == long.class) {\n                return new Long(string);\n            }\n            if (type == Double.class || type == double.class) {\n                return new Double(string);\n            }\n            if (type == Float.class || type == float.class) {\n                return new Float(string);\n            }\n            if (type == Byte.class || type == byte.class) {\n                return new Byte(string);\n            }\n            if (type == Boolean.class || type == boolean.class) {\n                return Boolean.valueOf(string);\n            }\n            if (type == Date.class\n                    || type == java.sql.Date.class\n                    || type == java.sql.Timestamp.class\n                    || type == java.sql.Time.class) {\n                try {\n                    Date date = new SimpleDateFormat(DATE_FORMAT).parse(string);\n                    if (type == java.sql.Date.class) {\n                        return new java.sql.Date(date.getTime());\n                    }\n                    if (type == java.sql.Timestamp.class) {\n                        return new java.sql.Timestamp(date.getTime());\n                    }\n                    if (type == java.sql.Time.class) {\n                        return new java.sql.Time(date.getTime());\n                    }\n                    return date;\n                } catch (ParseException e) {\n                    throw new IllegalStateException(\n                            \"Failed to parse date \" + value + \" by format \" + DATE_FORMAT + \", cause: \"\n                                    + e.getMessage(),\n                            e);\n                }\n            }\n            if (type == java.time.LocalDateTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDateTime.parse(string);\n            }\n            if (type == java.time.LocalDate.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDate.parse(string);\n            }\n            if (type == java.time.LocalTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n\n                if (string.length() >= ISO_LOCAL_DATE_TIME_MIN_LEN) {\n                    return LocalDateTime.parse(string).toLocalTime();\n                } else {\n                    return LocalTime.parse(string);\n                }\n            }\n            if (type == Class.class) {\n                try {\n                    return ReflectUtils.name2class(string);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n            if (char[].class.equals(type)) {\n                // Process string to char array for generic invoke\n                // See\n                // - https://github.com/apache/dubbo/issues/2003\n                int len = string.length();\n                char[] chars = new char[len];\n                string.getChars(0, len, chars, 0);\n                return chars;\n            }\n        }\n        if (value instanceof Number) {\n            Number number = (Number) value;\n            if (type == byte.class || type == Byte.class) {\n                return number.byteValue();\n            }\n            if (type == short.class || type == Short.class) {\n                return number.shortValue();\n            }\n            if (type == int.class || type == Integer.class) {\n                return number.intValue();\n            }\n            if (type == long.class || type == Long.class) {\n                return number.longValue();\n            }\n            if (type == float.class || type == Float.class) {\n                return number.floatValue();\n            }\n            if (type == double.class || type == Double.class) {\n                return number.doubleValue();\n            }\n            if (type == BigInteger.class) {\n                return BigInteger.valueOf(number.longValue());\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(number.toString());\n            }\n            if (type == Date.class) {\n                return new Date(number.longValue());\n            }\n            if (type == boolean.class || type == Boolean.class) {\n                return 0 != number.intValue();\n            }\n        }\n        if (value instanceof Collection) {\n            Collection collection = (Collection) value;\n            if (type.isArray()) {\n                int length = collection.size();\n                Object array = Array.newInstance(type.getComponentType(), length);\n                int i = 0;\n                for (Object item : collection) {\n                    Array.set(array, i++, item);\n                }\n                return array;\n            }\n            if (!type.isInterface()) {\n                try {\n                    Collection result =\n                            (Collection) type.getDeclaredConstructor().newInstance();\n                    result.addAll(collection);\n                    return result;\n                } catch (Throwable ignored) {\n                }\n            }\n            if (type == List.class) {\n                return new ArrayList<Object>(collection);\n            }\n            if (type == Set.class) {\n                return new HashSet<Object>(collection);\n            }\n        }\n        if (value.getClass().isArray() && Collection.class.isAssignableFrom(type)) {\n            int length = Array.getLength(value);\n            Collection collection;\n            if (!type.isInterface()) {\n                try {\n                    collection = (Collection) type.getDeclaredConstructor().newInstance();\n                } catch (Exception e) {\n                    collection = new ArrayList<Object>(length);\n                }\n            } else if (type == Set.class) {\n                collection = new HashSet<Object>(Math.max((int) (length / .75f) + 1, 16));\n            } else {\n                collection = new ArrayList<Object>(length);\n            }\n            for (int i = 0; i < length; i++) {\n                collection.add(Array.get(value, i));\n            }\n            return collection;\n        }\n        return value;\n    }\n}\n",
        "methodName": null,
        "exampleID": 128,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java",
        "line": 146,
        "sink": "java.time.LocalTime.parse",
        "source": "-",
        "sourceLine": 146,
        "qualifier": "Call to java.time.LocalTime.parse with untrusted data from [msg : HttpRequest](1).\nCall to java.time.LocalTime.parse with untrusted data from [msg : String](2).",
        "line_number": 146,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 129
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 129
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 129
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 129
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java#L206",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class CompatibleTypeUtils {\n\n    private static final String DATE_FORMAT = \"yyyy-MM-dd HH:mm:ss\";\n\n    /**\n     * the text to parse such as \"2007-12-03T10:15:30\"\n     */\n    private static final int ISO_LOCAL_DATE_TIME_MIN_LEN = 19;\n\n    private CompatibleTypeUtils() {}\n\n    /**\n     * Compatible type convert. Null value is allowed to pass in. If no conversion is needed, then the original value\n     * will be returned.\n     * <p>\n     * Supported compatible type conversions include (primary types and corresponding wrappers are not listed):\n     * <ul>\n     * <li> String -> char, enum, Date\n     * <li> byte, short, int, long -> byte, short, int, long\n     * <li> float, double -> float, double\n     * </ul>\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    public static Object compatibleTypeConvert(Object value, Class<?> type) {\n        if (value == null || type == null || type.isAssignableFrom(value.getClass())) {\n            return value;\n        }\n\n        if (value instanceof String) {\n            String string = (String) value;\n            if (char.class.equals(type) || Character.class.equals(type)) {\n                if (string.length() != 1) {\n                    throw new IllegalArgumentException(String.format(\n                            \"CAN NOT convert String(%s) to char!\"\n                                    + \" when convert String to char, the String MUST only 1 char.\",\n                            string));\n                }\n                return string.charAt(0);\n            }\n            if (type.isEnum()) {\n                return Enum.valueOf((Class<Enum>) type, string);\n            }\n            if (type == BigInteger.class) {\n                return new BigInteger(string);\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(string);\n            }\n            if (type == Short.class || type == short.class) {\n                return new Short(string);\n            }\n            if (type == Integer.class || type == int.class) {\n                return new Integer(string);\n            }\n            if (type == Long.class || type == long.class) {\n                return new Long(string);\n            }\n            if (type == Double.class || type == double.class) {\n                return new Double(string);\n            }\n            if (type == Float.class || type == float.class) {\n                return new Float(string);\n            }\n            if (type == Byte.class || type == byte.class) {\n                return new Byte(string);\n            }\n            if (type == Boolean.class || type == boolean.class) {\n                return Boolean.valueOf(string);\n            }\n            if (type == Date.class\n                    || type == java.sql.Date.class\n                    || type == java.sql.Timestamp.class\n                    || type == java.sql.Time.class) {\n                try {\n                    Date date = new SimpleDateFormat(DATE_FORMAT).parse(string);\n                    if (type == java.sql.Date.class) {\n                        return new java.sql.Date(date.getTime());\n                    }\n                    if (type == java.sql.Timestamp.class) {\n                        return new java.sql.Timestamp(date.getTime());\n                    }\n                    if (type == java.sql.Time.class) {\n                        return new java.sql.Time(date.getTime());\n                    }\n                    return date;\n                } catch (ParseException e) {\n                    throw new IllegalStateException(\n                            \"Failed to parse date \" + value + \" by format \" + DATE_FORMAT + \", cause: \"\n                                    + e.getMessage(),\n                            e);\n                }\n            }\n            if (type == java.time.LocalDateTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDateTime.parse(string);\n            }\n            if (type == java.time.LocalDate.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n                return LocalDate.parse(string);\n            }\n            if (type == java.time.LocalTime.class) {\n                if (StringUtils.isEmpty(string)) {\n                    return null;\n                }\n\n                if (string.length() >= ISO_LOCAL_DATE_TIME_MIN_LEN) {\n                    return LocalDateTime.parse(string).toLocalTime();\n                } else {\n                    return LocalTime.parse(string);\n                }\n            }\n            if (type == Class.class) {\n                try {\n                    return ReflectUtils.name2class(string);\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n            if (char[].class.equals(type)) {\n                // Process string to char array for generic invoke\n                // See\n                // - https://github.com/apache/dubbo/issues/2003\n                int len = string.length();\n                char[] chars = new char[len];\n                string.getChars(0, len, chars, 0);\n                return chars;\n            }\n        }\n        if (value instanceof Number) {\n            Number number = (Number) value;\n            if (type == byte.class || type == Byte.class) {\n                return number.byteValue();\n            }\n            if (type == short.class || type == Short.class) {\n                return number.shortValue();\n            }\n            if (type == int.class || type == Integer.class) {\n                return number.intValue();\n            }\n            if (type == long.class || type == Long.class) {\n                return number.longValue();\n            }\n            if (type == float.class || type == Float.class) {\n                return number.floatValue();\n            }\n            if (type == double.class || type == Double.class) {\n                return number.doubleValue();\n            }\n            if (type == BigInteger.class) {\n                return BigInteger.valueOf(number.longValue());\n            }\n            if (type == BigDecimal.class) {\n                return new BigDecimal(number.toString());\n            }\n            if (type == Date.class) {\n                return new Date(number.longValue());\n            }\n            if (type == boolean.class || type == Boolean.class) {\n                return 0 != number.intValue();\n            }\n        }\n        if (value instanceof Collection) {\n            Collection collection = (Collection) value;\n            if (type.isArray()) {\n                int length = collection.size();\n                Object array = Array.newInstance(type.getComponentType(), length);\n                int i = 0;\n                for (Object item : collection) {\n                    Array.set(array, i++, item);\n                }\n                return array;\n            }\n            if (!type.isInterface()) {\n                try {\n                    Collection result =\n                            (Collection) type.getDeclaredConstructor().newInstance();\n                    result.addAll(collection);\n                    return result;\n                } catch (Throwable ignored) {\n                }\n            }\n            if (type == List.class) {\n                return new ArrayList<Object>(collection);\n            }\n            if (type == Set.class) {\n                return new HashSet<Object>(collection);\n            }\n        }\n        if (value.getClass().isArray() && Collection.class.isAssignableFrom(type)) {\n            int length = Array.getLength(value);\n            Collection collection;\n            if (!type.isInterface()) {\n                try {\n                    collection = (Collection) type.getDeclaredConstructor().newInstance();\n                } catch (Exception e) {\n                    collection = new ArrayList<Object>(length);\n                }\n            } else if (type == Set.class) {\n                collection = new HashSet<Object>(Math.max((int) (length / .75f) + 1, 16));\n            } else {\n                collection = new ArrayList<Object>(length);\n            }\n            for (int i = 0; i < length; i++) {\n                collection.add(Array.get(value, i));\n            }\n            return collection;\n        }\n        return value;\n    }\n}\n",
        "methodName": null,
        "exampleID": 130,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/CompatibleTypeUtils.java",
        "line": 206,
        "sink": "java.lang.reflect.Array.set",
        "source": "-",
        "sourceLine": 206,
        "qualifier": "Call to java.lang.reflect.Array.set with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.reflect.Array.set with untrusted data from [msg : String](2).",
        "line_number": 206,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 131
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 131
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 131
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 131
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/DefaultSerializeClassChecker.java#L174",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Set;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_UNTRUSTED_SERIALIZE_CLASS;\n\n/**\n * Inspired by Fastjson2\n * see com.alibaba.fastjson2.filter.ContextAutoTypeBeforeHandler#apply(java.lang.String, java.lang.Class, long)\n */\npublic class DefaultSerializeClassChecker implements AllowClassNotifyListener {\n\n    private static final long MAGIC_HASH_CODE = 0xcbf29ce484222325L;\n    private static final long MAGIC_PRIME = 0x100000001b3L;\n    private static final ErrorTypeAwareLogger logger =\n            LoggerFactory.getErrorTypeAwareLogger(DefaultSerializeClassChecker.class);\n    private volatile SerializeCheckStatus checkStatus = AllowClassNotifyListener.DEFAULT_STATUS;\n    private volatile boolean checkSerializable = true;\n\n    private final SerializeSecurityManager serializeSecurityManager;\n    private volatile long[] allowPrefixes = new long[0];\n\n    private volatile long[] disAllowPrefixes = new long[0];\n\n    public DefaultSerializeClassChecker(FrameworkModel frameworkModel) {\n        serializeSecurityManager = frameworkModel.getBeanFactory().getOrRegisterBean(SerializeSecurityManager.class);\n        serializeSecurityManager.registerListener(this);\n    }\n\n    @Override\n    public synchronized void notifyPrefix(Set<String> allowedList, Set<String> disAllowedList) {\n        this.allowPrefixes = loadPrefix(allowedList);\n        this.disAllowPrefixes = loadPrefix(disAllowedList);\n    }\n\n    @Override\n    public synchronized void notifyCheckStatus(SerializeCheckStatus status) {\n        this.checkStatus = status;\n    }\n\n    @Override\n    public synchronized void notifyCheckSerializable(boolean checkSerializable) {\n        this.checkSerializable = checkSerializable;\n    }\n\n    private static long[] loadPrefix(Set<String> allowedList) {\n        long[] array = new long[allowedList.size()];\n\n        int index = 0;\n        for (String name : allowedList) {\n            if (name == null || name.isEmpty()) {\n                continue;\n            }\n\n            long hashCode = MAGIC_HASH_CODE;\n            for (int j = 0; j < name.length(); ++j) {\n                char ch = name.charAt(j);\n                if (ch == '$') {\n                    ch = '.';\n                }\n                hashCode ^= ch;\n                hashCode *= MAGIC_PRIME;\n            }\n\n            array[index++] = hashCode;\n        }\n\n        if (index != array.length) {\n            array = Arrays.copyOf(array, index);\n        }\n        Arrays.sort(array);\n        return array;\n    }\n\n    /**\n     * Try load class\n     *\n     * @param className class name\n     * @throws IllegalArgumentException if class is blocked\n     */\n    public Class<?> loadClass(ClassLoader classLoader, String className) throws ClassNotFoundException {\n        Class<?> aClass = loadClass0(classLoader, className);\n        if (!aClass.isPrimitive() && !Serializable.class.isAssignableFrom(aClass)) {\n            String msg = \"[Serialization Security] Serialized class \" + className\n                    + \" has not implement Serializable interface. \"\n                    + \"Current mode is strict check, will disallow to deserialize it by default. \";\n            if (serializeSecurityManager.getWarnedClasses().add(className)) {\n                logger.error(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\", msg);\n            }\n\n            if (checkSerializable) {\n                throw new IllegalArgumentException(msg);\n            }\n        }\n\n        return aClass;\n    }\n\n    private Class<?> loadClass0(ClassLoader classLoader, String className) throws ClassNotFoundException {\n        if (checkStatus == SerializeCheckStatus.DISABLE) {\n            return ClassUtils.forName(className, classLoader);\n        }\n\n        long hash = MAGIC_HASH_CODE;\n        for (int i = 0, typeNameLength = className.length(); i < typeNameLength; ++i) {\n            char ch = className.charAt(i);\n            if (ch == '$') {\n                ch = '.';\n            }\n            hash ^= ch;\n            hash *= MAGIC_PRIME;\n\n            if (Arrays.binarySearch(allowPrefixes, hash) >= 0) {\n                return ClassUtils.forName(className, classLoader);\n            }\n        }\n\n        if (checkStatus == SerializeCheckStatus.STRICT) {\n            String msg = \"[Serialization Security] Serialized class \" + className + \" is not in allow list. \"\n                    + \"Current mode is `STRICT`, will disallow to deserialize it by default. \"\n                    + \"Please add it into security/serialize.allowlist or follow FAQ to configure it.\";\n            if (serializeSecurityManager.getWarnedClasses().add(className)) {\n                logger.error(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\", msg);\n            }\n\n            throw new IllegalArgumentException(msg);\n        }\n\n        hash = MAGIC_HASH_CODE;\n        for (int i = 0, typeNameLength = className.length(); i < typeNameLength; ++i) {\n            char ch = className.charAt(i);\n            if (ch == '$') {\n                ch = '.';\n            }\n            hash ^= ch;\n            hash *= MAGIC_PRIME;\n\n            if (Arrays.binarySearch(disAllowPrefixes, hash) >= 0) {\n                String msg = \"[Serialization Security] Serialized class \" + className + \" is in disallow list. \"\n                        + \"Current mode is `WARN`, will disallow to deserialize it by default. \"\n                        + \"Please add it into security/serialize.allowlist or follow FAQ to configure it.\";\n                if (serializeSecurityManager.getWarnedClasses().add(className)) {\n                    logger.warn(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\", msg);\n                }\n\n                throw new IllegalArgumentException(msg);\n            }\n        }\n\n        hash = MAGIC_HASH_CODE;\n        for (int i = 0, typeNameLength = className.length(); i < typeNameLength; ++i) {\n            char ch = Character.toLowerCase(className.charAt(i));\n            if (ch == '$') {\n                ch = '.';\n            }\n            hash ^= ch;\n            hash *= MAGIC_PRIME;\n\n            if (Arrays.binarySearch(disAllowPrefixes, hash) >= 0) {\n                String msg = \"[Serialization Security] Serialized class \" + className + \" is in disallow list. \"\n                        + \"Current mode is `WARN`, will disallow to deserialize it by default. \"\n                        + \"Please add it into security/serialize.allowlist or follow FAQ to configure it.\";\n                if (serializeSecurityManager.getWarnedClasses().add(className)) {\n                    logger.warn(PROTOCOL_UNTRUSTED_SERIALIZE_CLASS, \"\", \"\", msg);\n                }\n\n                throw new IllegalArgumentException(msg);\n            }\n        }\n\n        Class<?> clazz = ClassUtils.forName(className, classLoader);\n        if (serializeSecurityManager.getWarnedClasses().add(className)) {\n            logger.warn(\n                    PROTOCOL_UNTRUSTED_SERIALIZE_CLASS,\n                    \"\",\n                    \"\",\n                    \"[Serialization Security] Serialized class \" + className + \" is not in allow list. \"\n                            + \"Current mode is `WARN`, will allow to deserialize it by default. \"\n                            + \"Dubbo will set to `STRICT` mode by default in the future. \"\n                            + \"Please add it into security/serialize.allowlist or follow FAQ to configure it.\");\n        }\n        return clazz;\n    }\n\n    public static DefaultSerializeClassChecker getInstance() {\n        return FrameworkModel.defaultModel().getBeanFactory().getBean(DefaultSerializeClassChecker.class);\n    }\n\n    public boolean isCheckSerializable() {\n        return checkSerializable;\n    }\n}\n",
        "methodName": null,
        "exampleID": 132,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/DefaultSerializeClassChecker.java",
        "line": 174,
        "sink": "java.lang.Character.toLowerCase",
        "source": "-",
        "sourceLine": 174,
        "qualifier": "Call to java.lang.Character.toLowerCase with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.Character.toLowerCase with untrusted data from [msg : String](2).",
        "line_number": 174,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 133
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 133
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 133
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 133
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java#L207",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport java.beans.BeanInfo;\nimport java.beans.Introspector;\nimport java.beans.MethodDescriptor;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.net.URL;\nimport java.security.CodeSource;\nimport java.security.ProtectionDomain;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.Future;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\nimport javassist.CtMethod;\nimport javassist.NotFoundException;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.unmodifiableSet;\nimport static org.apache.dubbo.common.utils.ArrayUtils.isEmpty;\n\n/**\n * ReflectUtils\n */\npublic final class ReflectUtils {\n\n    /**\n     * void(V).\n     */\n    public static final char JVM_VOID = 'V';\n\n    /**\n     * boolean(Z).\n     */\n    public static final char JVM_BOOLEAN = 'Z';\n\n    /**\n     * byte(B).\n     */\n    public static final char JVM_BYTE = 'B';\n\n    /**\n     * char(C).\n     */\n    public static final char JVM_CHAR = 'C';\n\n    /**\n     * double(D).\n     */\n    public static final char JVM_DOUBLE = 'D';\n\n    /**\n     * float(F).\n     */\n    public static final char JVM_FLOAT = 'F';\n\n    /**\n     * int(I).\n     */\n    public static final char JVM_INT = 'I';\n\n    /**\n     * long(J).\n     */\n    public static final char JVM_LONG = 'J';\n\n    /**\n     * short(S).\n     */\n    public static final char JVM_SHORT = 'S';\n\n    public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];\n\n    public static final String JAVA_IDENT_REGEX = \"(?:[_$a-zA-Z][_$a-zA-Z0-9]*)\";\n\n    public static final String JAVA_NAME_REGEX = \"(?:\" + JAVA_IDENT_REGEX + \"(?:\\\\.\" + JAVA_IDENT_REGEX + \")*)\";\n\n    public static final String CLASS_DESC = \"(?:L\" + JAVA_IDENT_REGEX + \"(?:\\\\/\" + JAVA_IDENT_REGEX + \")*;)\";\n\n    public static final String ARRAY_DESC = \"(?:\\\\[+(?:(?:[VZBCDFIJS])|\" + CLASS_DESC + \"))\";\n\n    public static final String DESC_REGEX = \"(?:(?:[VZBCDFIJS])|\" + CLASS_DESC + \"|\" + ARRAY_DESC + \")\";\n\n    public static final Pattern DESC_PATTERN = Pattern.compile(DESC_REGEX);\n\n    public static final String METHOD_DESC_REGEX =\n            \"(?:(\" + JAVA_IDENT_REGEX + \")?\\\\((\" + DESC_REGEX + \"*)\\\\)(\" + DESC_REGEX + \")?)\";\n\n    public static final Pattern METHOD_DESC_PATTERN = Pattern.compile(METHOD_DESC_REGEX);\n\n    public static final Pattern GETTER_METHOD_DESC_PATTERN =\n            Pattern.compile(\"get([A-Z][_a-zA-Z0-9]*)\\\\(\\\\)(\" + DESC_REGEX + \")\");\n\n    public static final Pattern SETTER_METHOD_DESC_PATTERN =\n            Pattern.compile(\"set([A-Z][_a-zA-Z0-9]*)\\\\((\" + DESC_REGEX + \")\\\\)V\");\n\n    public static final Pattern IS_HAS_CAN_METHOD_DESC_PATTERN =\n            Pattern.compile(\"(?:is|has|can)([A-Z][_a-zA-Z0-9]*)\\\\(\\\\)Z\");\n\n    private static Map<Class<?>, Object> primitiveDefaults = new HashMap<>();\n\n    static {\n        primitiveDefaults.put(int.class, 0);\n        primitiveDefaults.put(long.class, 0L);\n        primitiveDefaults.put(byte.class, (byte) 0);\n        primitiveDefaults.put(char.class, (char) 0);\n        primitiveDefaults.put(short.class, (short) 0);\n        primitiveDefaults.put(float.class, (float) 0);\n        primitiveDefaults.put(double.class, (double) 0);\n        primitiveDefaults.put(boolean.class, false);\n        primitiveDefaults.put(void.class, null);\n    }\n\n    private ReflectUtils() {}\n\n    public static boolean isPrimitives(Class<?> cls) {\n        while (cls.isArray()) {\n            cls = cls.getComponentType();\n        }\n        return isPrimitive(cls);\n    }\n\n    public static boolean isPrimitive(Class<?> cls) {\n        return cls.isPrimitive()\n                || cls == String.class\n                || cls == Boolean.class\n                || cls == Character.class\n                || Number.class.isAssignableFrom(cls)\n                || Date.class.isAssignableFrom(cls);\n    }\n\n    public static Class<?> getBoxedClass(Class<?> c) {\n        if (c == int.class) {\n            c = Integer.class;\n        } else if (c == boolean.class) {\n            c = Boolean.class;\n        } else if (c == long.class) {\n            c = Long.class;\n        } else if (c == float.class) {\n            c = Float.class;\n        } else if (c == double.class) {\n            c = Double.class;\n        } else if (c == char.class) {\n            c = Character.class;\n        } else if (c == byte.class) {\n            c = Byte.class;\n        } else if (c == short.class) {\n            c = Short.class;\n        }\n        return c;\n    }\n\n    /**\n     * is compatible.\n     *\n     * @param c class.\n     * @param o instance.\n     * @return compatible or not.\n     */\n    public static boolean isCompatible(Class<?> c, Object o) {\n        boolean pt = c.isPrimitive();\n        if (o == null) {\n            return !pt;\n        }\n\n        if (pt) {\n            c = getBoxedClass(c);\n        }\n\n        return c == o.getClass() || c.isInstance(o);\n    }\n\n    /**\n     * is compatible.\n     *\n     * @param cs class array.\n     * @param os object array.\n     * @return compatible or not.\n     */\n    public static boolean isCompatible(Class<?>[] cs, Object[] os) {\n        int len = cs.length;\n        if (len != os.length) {\n            return false;\n        }\n        if (len == 0) {\n            return true;\n        }\n        for (int i = 0; i < len; i++) {\n            if (!isCompatible(cs[i], os[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static String getCodeBase(Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n        ProtectionDomain domain = cls.getProtectionDomain();\n        if (domain == null) {\n            return null;\n        }\n        CodeSource source = domain.getCodeSource();\n        if (source == null) {\n            return null;\n        }\n        URL location = source.getLocation();\n        if (location == null) {\n            return null;\n        }\n        return location.getFile();\n    }\n\n    /**\n     * get name.\n     * java.lang.Object[][].class => \"java.lang.Object[][]\"\n     *\n     * @param c class.\n     * @return name.\n     */\n    public static String getName(Class<?> c) {\n        if (c.isArray()) {\n            StringBuilder sb = new StringBuilder();\n            do {\n                sb.append(\"[]\");\n                c = c.getComponentType();\n            } while (c.isArray());\n\n            return c.getName() + sb.toString();\n        }\n        return c.getName();\n    }\n\n    public static Class<?> getGenericClass(Class<?> cls) {\n        return getGenericClass(cls, 0);\n    }\n\n    public static Class<?> getGenericClass(Class<?> cls, int i) {\n        try {\n            ParameterizedType parameterizedType = ((ParameterizedType) cls.getGenericInterfaces()[0]);\n            Object genericClass = parameterizedType.getActualTypeArguments()[i];\n\n            // handle nested generic type\n            if (genericClass instanceof ParameterizedType) {\n                return (Class<?>) ((ParameterizedType) genericClass).getRawType();\n            }\n\n            // handle array generic type\n            if (genericClass instanceof GenericArrayType) {\n                return (Class<?>) ((GenericArrayType) genericClass).getGenericComponentType();\n            }\n\n            // Requires JDK 7 or higher, Foo<int[]> is no longer GenericArrayType\n            if (((Class) genericClass).isArray()) {\n                return ((Class) genericClass).getComponentType();\n            }\n            return (Class<?>) genericClass;\n        } catch (Throwable e) {\n            throw new IllegalArgumentException(cls.getName() + \" generic type undefined!\", e);\n        }\n    }\n\n    /**\n     * get method name.\n     * \"void do(int)\", \"void do()\", \"int do(java.lang.String,boolean)\"\n     *\n     * @param m method.\n     * @return name.\n     */\n    public static String getName(final Method m) {\n        StringBuilder ret = new StringBuilder();\n        ret.append(getName(m.getReturnType())).append(' ');\n        ret.append(m.getName()).append('(');\n        Class<?>[] parameterTypes = m.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            if (i > 0) {\n                ret.append(',');\n            }\n            ret.append(getName(parameterTypes[i]));\n        }\n        ret.append(')');\n        return ret.toString();\n    }\n\n    public static String getSignature(String methodName, Class<?>[] parameterTypes) {\n        StringBuilder sb = new StringBuilder(methodName);\n        sb.append('(');\n        if (parameterTypes != null && parameterTypes.length > 0) {\n            boolean first = true;\n            for (Class<?> type : parameterTypes) {\n                if (first) {\n                    first = false;\n                } else {\n                    sb.append(',');\n                }\n                sb.append(type.getName());\n            }\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n\n    /**\n     * get constructor name.\n     * \"()\", \"(java.lang.String,int)\"\n     *\n     * @param c constructor.\n     * @return name.\n     */\n    public static String getName(final Constructor<?> c) {\n        StringBuilder ret = new StringBuilder(\"(\");\n        Class<?>[] parameterTypes = c.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            if (i > 0) {\n                ret.append(',');\n            }\n            ret.append(getName(parameterTypes[i]));\n        }\n        ret.append(')');\n        return ret.toString();\n    }\n\n    /**\n     * get class desc.\n     * boolean[].class => \"[Z\"\n     * Object.class => \"Ljava/lang/Object;\"\n     *\n     * @param c class.\n     * @return desc.\n     * @throws NotFoundException\n     */\n    public static String getDesc(Class<?> c) {\n        StringBuilder ret = new StringBuilder();\n\n        while (c.isArray()) {\n            ret.append('[');\n            c = c.getComponentType();\n        }\n\n        if (c.isPrimitive()) {\n            String t = c.getName();\n            if (\"void\".equals(t)) {\n                ret.append(JVM_VOID);\n            } else if (\"boolean\".equals(t)) {\n                ret.append(JVM_BOOLEAN);\n            } else if (\"byte\".equals(t)) {\n                ret.append(JVM_BYTE);\n            } else if (\"char\".equals(t)) {\n                ret.append(JVM_CHAR);\n            } else if (\"double\".equals(t)) {\n                ret.append(JVM_DOUBLE);\n            } else if (\"float\".equals(t)) {\n                ret.append(JVM_FLOAT);\n            } else if (\"int\".equals(t)) {\n                ret.append(JVM_INT);\n            } else if (\"long\".equals(t)) {\n                ret.append(JVM_LONG);\n            } else if (\"short\".equals(t)) {\n                ret.append(JVM_SHORT);\n            }\n        } else {\n            ret.append('L');\n            ret.append(c.getName().replace('.', '/'));\n            ret.append(';');\n        }\n        return ret.toString();\n    }\n\n    /**\n     * get class array desc.\n     * [int.class, boolean[].class, Object.class] => \"I[ZLjava/lang/Object;\"\n     *\n     * @param cs class array.\n     * @return desc.\n     * @throws NotFoundException\n     */\n    public static String getDesc(final Class<?>[] cs) {\n        if (cs.length == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(64);\n        for (Class<?> c : cs) {\n            sb.append(getDesc(c));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * get method desc.\n     * int do(int arg1) => \"do(I)I\"\n     * void do(String arg1,boolean arg2) => \"do(Ljava/lang/String;Z)V\"\n     *\n     * @param m method.\n     * @return desc.\n     */\n    public static String getDesc(final Method m) {\n        StringBuilder ret = new StringBuilder(m.getName()).append('(');\n        Class<?>[] parameterTypes = m.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            ret.append(getDesc(parameterTypes[i]));\n        }\n        ret.append(')').append(getDesc(m.getReturnType()));\n        return ret.toString();\n    }\n\n    public static String[] getDescArray(final Method m) {\n        Class<?>[] parameterTypes = m.getParameterTypes();\n        String[] arr = new String[parameterTypes.length];\n\n        for (int i = 0; i < parameterTypes.length; i++) {\n            arr[i] = getDesc(parameterTypes[i]);\n        }\n        return arr;\n    }\n\n    /**\n     * get constructor desc.\n     * \"()V\", \"(Ljava/lang/String;I)V\"\n     *\n     * @param c constructor.\n     * @return desc\n     */\n    public static String getDesc(final Constructor<?> c) {\n        StringBuilder ret = new StringBuilder(\"(\");\n        Class<?>[] parameterTypes = c.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            ret.append(getDesc(parameterTypes[i]));\n        }\n        ret.append(')').append('V');\n        return ret.toString();\n    }\n\n    /**\n     * get method desc.\n     * \"(I)I\", \"()V\", \"(Ljava/lang/String;Z)V\"\n     *\n     * @param m method.\n     * @return desc.\n     */\n    public static String getDescWithoutMethodName(Method m) {\n        StringBuilder ret = new StringBuilder();\n        ret.append('(');\n        Class<?>[] parameterTypes = m.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            ret.append(getDesc(parameterTypes[i]));\n        }\n        ret.append(')').append(getDesc(m.getReturnType()));\n        return ret.toString();\n    }\n\n    /**\n     * get class desc.\n     * Object.class => \"Ljava/lang/Object;\"\n     * boolean[].class => \"[Z\"\n     *\n     * @param c class.\n     * @return desc.\n     * @throws NotFoundException\n     */\n    public static String getDesc(final CtClass c) throws NotFoundException {\n        StringBuilder ret = new StringBuilder();\n        if (c.isArray()) {\n            ret.append('[');\n            ret.append(getDesc(c.getComponentType()));\n        } else if (c.isPrimitive()) {\n            String t = c.getName();\n            if (\"void\".equals(t)) {\n                ret.append(JVM_VOID);\n            } else if (\"boolean\".equals(t)) {\n                ret.append(JVM_BOOLEAN);\n            } else if (\"byte\".equals(t)) {\n                ret.append(JVM_BYTE);\n            } else if (\"char\".equals(t)) {\n                ret.append(JVM_CHAR);\n            } else if (\"double\".equals(t)) {\n                ret.append(JVM_DOUBLE);\n            } else if (\"float\".equals(t)) {\n                ret.append(JVM_FLOAT);\n            } else if (\"int\".equals(t)) {\n                ret.append(JVM_INT);\n            } else if (\"long\".equals(t)) {\n                ret.append(JVM_LONG);\n            } else if (\"short\".equals(t)) {\n                ret.append(JVM_SHORT);\n            }\n        } else {\n            ret.append('L');\n            ret.append(c.getName().replace('.', '/'));\n            ret.append(';');\n        }\n        return ret.toString();\n    }\n\n    /**\n     * get method desc.\n     * \"do(I)I\", \"do()V\", \"do(Ljava/lang/String;Z)V\"\n     *\n     * @param m method.\n     * @return desc.\n     */\n    public static String getDesc(final CtMethod m) throws NotFoundException {\n        StringBuilder ret = new StringBuilder(m.getName()).append('(');\n        CtClass[] parameterTypes = m.getParameterTypes();\n        for (CtClass parameterType : parameterTypes) {\n            ret.append(getDesc(parameterType));\n        }\n        ret.append(')').append(getDesc(m.getReturnType()));\n        return ret.toString();\n    }\n\n    /**\n     * get constructor desc.\n     * \"()V\", \"(Ljava/lang/String;I)V\"\n     *\n     * @param c constructor.\n     * @return desc\n     */\n    public static String getDesc(final CtConstructor c) throws NotFoundException {\n        StringBuilder ret = new StringBuilder(\"(\");\n        CtClass[] parameterTypes = c.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            ret.append(getDesc(parameterTypes[i]));\n        }\n        ret.append(')').append('V');\n        return ret.toString();\n    }\n\n    /**\n     * get method desc.\n     * \"(I)I\", \"()V\", \"(Ljava/lang/String;Z)V\".\n     *\n     * @param m method.\n     * @return desc.\n     */\n    public static String getDescWithoutMethodName(final CtMethod m) throws NotFoundException {\n        StringBuilder ret = new StringBuilder();\n        ret.append('(');\n        CtClass[] parameterTypes = m.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            ret.append(getDesc(parameterTypes[i]));\n        }\n        ret.append(')').append(getDesc(m.getReturnType()));\n        return ret.toString();\n    }\n\n    /**\n     * name to desc.\n     * java.util.Map[][] => \"[[Ljava/util/Map;\"\n     *\n     * @param name name.\n     * @return desc.\n     */\n    public static String name2desc(String name) {\n        StringBuilder sb = new StringBuilder();\n        int c = 0, index = name.indexOf('[');\n        if (index > 0) {\n            c = (name.length() - index) / 2;\n            name = name.substring(0, index);\n        }\n        while (c-- > 0) {\n            sb.append('[');\n        }\n        if (\"void\".equals(name)) {\n            sb.append(JVM_VOID);\n        } else if (\"boolean\".equals(name)) {\n            sb.append(JVM_BOOLEAN);\n        } else if (\"byte\".equals(name)) {\n            sb.append(JVM_BYTE);\n        } else if (\"char\".equals(name)) {\n            sb.append(JVM_CHAR);\n        } else if (\"double\".equals(name)) {\n            sb.append(JVM_DOUBLE);\n        } else if (\"float\".equals(name)) {\n            sb.append(JVM_FLOAT);\n        } else if (\"int\".equals(name)) {\n            sb.append(JVM_INT);\n        } else if (\"long\".equals(name)) {\n            sb.append(JVM_LONG);\n        } else if (\"short\".equals(name)) {\n            sb.append(JVM_SHORT);\n        } else {\n            sb.append('L').append(name.replace('.', '/')).append(';');\n        }\n        return sb.toString();\n    }\n\n    /**\n     * desc to name.\n     * \"[[I\" => \"int[][]\"\n     *\n     * @param desc desc.\n     * @return name.\n     */\n    public static String desc2name(String desc) {\n        StringBuilder sb = new StringBuilder();\n        int c = desc.lastIndexOf('[') + 1;\n        if (desc.length() == c + 1) {\n            switch (desc.charAt(c)) {\n                case JVM_VOID: {\n                    sb.append(\"void\");\n                    break;\n                }\n                case JVM_BOOLEAN: {\n                    sb.append(\"boolean\");\n                    break;\n                }\n                case JVM_BYTE: {\n                    sb.append(\"byte\");\n                    break;\n                }\n                case JVM_CHAR: {\n                    sb.append(\"char\");\n                    break;\n                }\n                case JVM_DOUBLE: {\n                    sb.append(\"double\");\n                    break;\n                }\n                case JVM_FLOAT: {\n                    sb.append(\"float\");\n                    break;\n                }\n                case JVM_INT: {\n                    sb.append(\"int\");\n                    break;\n                }\n                case JVM_LONG: {\n                    sb.append(\"long\");\n                    break;\n                }\n                case JVM_SHORT: {\n                    sb.append(\"short\");\n                    break;\n                }\n                default:\n                    throw new RuntimeException();\n            }\n        } else {\n            sb.append(desc.substring(c + 1, desc.length() - 1).replace('/', '.'));\n        }\n        while (c-- > 0) {\n            sb.append(\"[]\");\n        }\n        return sb.toString();\n    }\n\n    public static Class<?> forName(String name) {\n        try {\n            return name2class(name);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(\"Not found class \" + name + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    public static Class<?> forName(ClassLoader cl, String name) {\n        try {\n            return name2class(cl, name);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(\"Not found class \" + name + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * name to class.\n     * \"boolean\" => boolean.class\n     * \"java.util.Map[][]\" => java.util.Map[][].class\n     *\n     * @param name name.\n     * @return Class instance.\n     */\n    public static Class<?> name2class(String name) throws ClassNotFoundException {\n        return name2class(ClassUtils.getClassLoader(), name);\n    }\n\n    /**\n     * name to class.\n     * \"boolean\" => boolean.class\n     * \"java.util.Map[][]\" => java.util.Map[][].class\n     *\n     * @param cl   ClassLoader instance.\n     * @param name name.\n     * @return Class instance.\n     */\n    private static Class<?> name2class(ClassLoader cl, String name) throws ClassNotFoundException {\n        int c = 0, index = name.indexOf('[');\n        if (index > 0) {\n            c = (name.length() - index) / 2;\n            name = name.substring(0, index);\n        }\n        if (c > 0) {\n            StringBuilder sb = new StringBuilder();\n            while (c-- > 0) {\n                sb.append('[');\n            }\n\n            if (\"void\".equals(name)) {\n                sb.append(JVM_VOID);\n            } else if (\"boolean\".equals(name)) {\n                sb.append(JVM_BOOLEAN);\n            } else if (\"byte\".equals(name)) {\n                sb.append(JVM_BYTE);\n            } else if (\"char\".equals(name)) {\n                sb.append(JVM_CHAR);\n            } else if (\"double\".equals(name)) {\n                sb.append(JVM_DOUBLE);\n            } else if (\"float\".equals(name)) {\n                sb.append(JVM_FLOAT);\n            } else if (\"int\".equals(name)) {\n                sb.append(JVM_INT);\n            } else if (\"long\".equals(name)) {\n                sb.append(JVM_LONG);\n            } else if (\"short\".equals(name)) {\n                sb.append(JVM_SHORT);\n            } else {\n                // \"java.lang.Object\" ==> \"Ljava.lang.Object;\"\n                sb.append('L').append(name).append(';');\n            }\n            name = sb.toString();\n        } else {\n            if (\"void\".equals(name)) {\n                return void.class;\n            }\n            if (\"boolean\".equals(name)) {\n                return boolean.class;\n            }\n            if (\"byte\".equals(name)) {\n                return byte.class;\n            }\n            if (\"char\".equals(name)) {\n                return char.class;\n            }\n            if (\"double\".equals(name)) {\n                return double.class;\n            }\n            if (\"float\".equals(name)) {\n                return float.class;\n            }\n            if (\"int\".equals(name)) {\n                return int.class;\n            }\n            if (\"long\".equals(name)) {\n                return long.class;\n            }\n            if (\"short\".equals(name)) {\n                return short.class;\n            }\n        }\n\n        if (cl == null) {\n            cl = ClassUtils.getClassLoader();\n        }\n        return Class.forName(name, true, cl);\n    }\n\n    /**\n     * desc to class.\n     * \"[Z\" => boolean[].class\n     * \"[[Ljava/util/Map;\" => java.util.Map[][].class\n     *\n     * @param desc desc.\n     * @return Class instance.\n     * @throws ClassNotFoundException\n     */\n    public static Class<?> desc2class(String desc) throws ClassNotFoundException {\n        return desc2class(ClassUtils.getClassLoader(), desc);\n    }\n\n    /**\n     * desc to class.\n     * \"[Z\" => boolean[].class\n     * \"[[Ljava/util/Map;\" => java.util.Map[][].class\n     *\n     * @param cl   ClassLoader instance.\n     * @param desc desc.\n     * @return Class instance.\n     * @throws ClassNotFoundException\n     */\n    private static Class<?> desc2class(ClassLoader cl, String desc) throws ClassNotFoundException {\n        switch (desc.charAt(0)) {\n            case JVM_VOID:\n                return void.class;\n            case JVM_BOOLEAN:\n                return boolean.class;\n            case JVM_BYTE:\n                return byte.class;\n            case JVM_CHAR:\n                return char.class;\n            case JVM_DOUBLE:\n                return double.class;\n            case JVM_FLOAT:\n                return float.class;\n            case JVM_INT:\n                return int.class;\n            case JVM_LONG:\n                return long.class;\n            case JVM_SHORT:\n                return short.class;\n            case 'L':\n                // \"Ljava/lang/Object;\" ==> \"java.lang.Object\"\n                desc = desc.substring(1, desc.length() - 1).replace('/', '.');\n                break;\n            case '[':\n                // \"[[Ljava/lang/Object;\" ==> \"[[Ljava.lang.Object;\"\n                desc = desc.replace('/', '.');\n                break;\n            default:\n                throw new ClassNotFoundException(\"Class not found: \" + desc);\n        }\n\n        if (cl == null) {\n            cl = ClassUtils.getClassLoader();\n        }\n        return Class.forName(desc, true, cl);\n    }\n\n    /**\n     * get class array instance.\n     *\n     * @param desc desc.\n     * @return Class class array.\n     * @throws ClassNotFoundException\n     */\n    public static Class<?>[] desc2classArray(String desc) throws ClassNotFoundException {\n        Class<?>[] ret = desc2classArray(ClassUtils.getClassLoader(), desc);\n        return ret;\n    }\n\n    /**\n     * get class array instance.\n     *\n     * @param cl   ClassLoader instance.\n     * @param desc desc.\n     * @return Class[] class array.\n     * @throws ClassNotFoundException\n     */\n    private static Class<?>[] desc2classArray(ClassLoader cl, String desc) throws ClassNotFoundException {\n        if (desc.length() == 0) {\n            return EMPTY_CLASS_ARRAY;\n        }\n\n        List<Class<?>> cs = new ArrayList<>();\n        Matcher m = DESC_PATTERN.matcher(desc);\n        while (m.find()) {\n            cs.add(desc2class(cl, m.group()));\n        }\n        return cs.toArray(EMPTY_CLASS_ARRAY);\n    }\n\n    /**\n     * Find method from method signature\n     *\n     * @param clazz      Target class to find method\n     * @param methodName Method signature, e.g.: method1(int, String). It is allowed to provide method name only, e.g.: method2\n     * @return target method\n     * @throws NoSuchMethodException\n     * @throws ClassNotFoundException\n     * @throws IllegalStateException  when multiple methods are found (overridden method when parameter info is not provided)\n     * @deprecated Recommend {@link MethodUtils#findMethod(Class, String, Class[])}\n     */\n    @Deprecated\n    public static Method findMethodByMethodSignature(Class<?> clazz, String methodName, String[] parameterTypes)\n            throws NoSuchMethodException, ClassNotFoundException {\n        Method method;\n        if (parameterTypes == null) {\n            List<Method> finded = new ArrayList<>();\n            for (Method m : clazz.getMethods()) {\n                if (m.getName().equals(methodName)) {\n                    finded.add(m);\n                }\n            }\n            if (finded.isEmpty()) {\n                throw new NoSuchMethodException(\"No such method \" + methodName + \" in class \" + clazz);\n            }\n            if (finded.size() > 1) {\n                String msg = String.format(\n                        \"Not unique method for method name(%s) in class(%s), find %d methods.\",\n                        methodName, clazz.getName(), finded.size());\n                throw new IllegalStateException(msg);\n            }\n            method = finded.get(0);\n        } else {\n            Class<?>[] types = new Class<?>[parameterTypes.length];\n            for (int i = 0; i < parameterTypes.length; i++) {\n                types[i] = ReflectUtils.name2class(parameterTypes[i]);\n            }\n            method = clazz.getMethod(methodName, types);\n        }\n        return method;\n    }\n\n    /**\n     * @param clazz      Target class to find method\n     * @param methodName Method signature, e.g.: method1(int, String). It is allowed to provide method name only, e.g.: method2\n     * @return target method\n     * @throws NoSuchMethodException\n     * @throws ClassNotFoundException\n     * @throws IllegalStateException  when multiple methods are found (overridden method when parameter info is not provided)\n     * @deprecated Recommend {@link MethodUtils#findMethod(Class, String, Class[])}\n     */\n    @Deprecated\n    public static Method findMethodByMethodName(Class<?> clazz, String methodName)\n            throws NoSuchMethodException, ClassNotFoundException {\n        return findMethodByMethodSignature(clazz, methodName, null);\n    }\n\n    public static Constructor<?> findConstructor(Class<?> clazz, Class<?> paramType) throws NoSuchMethodException {\n        Constructor<?> targetConstructor;\n        try {\n            targetConstructor = clazz.getConstructor(new Class<?>[] {paramType});\n        } catch (NoSuchMethodException e) {\n            targetConstructor = null;\n            Constructor<?>[] constructors = clazz.getConstructors();\n            for (Constructor<?> constructor : constructors) {\n                if (Modifier.isPublic(constructor.getModifiers())\n                        && constructor.getParameterTypes().length == 1\n                        && constructor.getParameterTypes()[0].isAssignableFrom(paramType)) {\n                    targetConstructor = constructor;\n                    break;\n                }\n            }\n            if (targetConstructor == null) {\n                throw e;\n            }\n        }\n        return targetConstructor;\n    }\n\n    /**\n     * Check if one object is the implementation for a given interface.\n     * <p>\n     * This method will not trigger classloading for the given interface, therefore it will not lead to error when\n     * the given interface is not visible by the classloader\n     *\n     * @param obj                Object to examine\n     * @param interfaceClazzName The given interface\n     * @return true if the object implements the given interface, otherwise return false\n     */\n    public static boolean isInstance(Object obj, String interfaceClazzName) {\n        for (Class<?> clazz = obj.getClass();\n                clazz != null && !clazz.equals(Object.class);\n                clazz = clazz.getSuperclass()) {\n            Class<?>[] interfaces = clazz.getInterfaces();\n            for (Class<?> itf : interfaces) {\n                if (itf.getName().equals(interfaceClazzName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static Object getEmptyObject(Class<?> returnType) {\n        return getEmptyObject(returnType, new HashMap<>(), 0);\n    }\n\n    private static Object getEmptyObject(Class<?> returnType, Map<Class<?>, Object> emptyInstances, int level) {\n        if (level > 2) {\n            return null;\n        }\n        if (returnType == null) {\n            return null;\n        }\n        if (returnType == boolean.class || returnType == Boolean.class) {\n            return false;\n        }\n        if (returnType == char.class || returnType == Character.class) {\n            return '\\0';\n        }\n        if (returnType == byte.class || returnType == Byte.class) {\n            return (byte) 0;\n        }\n        if (returnType == short.class || returnType == Short.class) {\n            return (short) 0;\n        }\n        if (returnType == int.class || returnType == Integer.class) {\n            return 0;\n        }\n        if (returnType == long.class || returnType == Long.class) {\n            return 0L;\n        }\n        if (returnType == float.class || returnType == Float.class) {\n            return 0F;\n        }\n        if (returnType == double.class || returnType == Double.class) {\n            return 0D;\n        }\n        if (returnType.isArray()) {\n            return Array.newInstance(returnType.getComponentType(), 0);\n        }\n        if (returnType.isAssignableFrom(ArrayList.class)) {\n            return new ArrayList<>(0);\n        }\n        if (returnType.isAssignableFrom(HashSet.class)) {\n            return new HashSet<>(0);\n        }\n        if (returnType.isAssignableFrom(HashMap.class)) {\n            return new HashMap<>(0);\n        }\n        if (String.class.equals(returnType)) {\n            return \"\";\n        }\n        if (returnType.isInterface()) {\n            return null;\n        }\n\n        try {\n            Object value = emptyInstances.get(returnType);\n            if (value == null) {\n                value = returnType.getDeclaredConstructor().newInstance();\n                emptyInstances.put(returnType, value);\n            }\n            Class<?> cls = value.getClass();\n            while (cls != null && cls != Object.class) {\n                Field[] fields = cls.getDeclaredFields();\n                for (Field field : fields) {\n                    if (field.isSynthetic()) {\n                        continue;\n                    }\n                    Object property = getEmptyObject(field.getType(), emptyInstances, level + 1);\n                    if (property != null) {\n                        try {\n                            if (!field.isAccessible()) {\n                                field.setAccessible(true);\n                            }\n                            field.set(value, property);\n                        } catch (Throwable ignored) {\n                        }\n                    }\n                }\n                cls = cls.getSuperclass();\n            }\n            return value;\n        } catch (Throwable e) {\n            return null;\n        }\n    }\n\n    public static Object defaultReturn(Method m) {\n        if (m.getReturnType().isPrimitive()) {\n            return primitiveDefaults.get(m.getReturnType());\n        } else {\n            return null;\n        }\n    }\n\n    public static Object defaultReturn(Class<?> classType) {\n        if (classType != null && classType.isPrimitive()) {\n            return primitiveDefaults.get(classType);\n        } else {\n            return null;\n        }\n    }\n\n    public static boolean isBeanPropertyReadMethod(Method method) {\n        return method != null\n                && Modifier.isPublic(method.getModifiers())\n                && !Modifier.isStatic(method.getModifiers())\n                && method.getReturnType() != void.class\n                && method.getDeclaringClass() != Object.class\n                && method.getParameterTypes().length == 0\n                && ((method.getName().startsWith(\"get\") && method.getName().length() > 3)\n                        || (method.getName().startsWith(\"is\")\n                                && method.getName().length() > 2));\n    }\n\n    public static String getPropertyNameFromBeanReadMethod(Method method) {\n        if (isBeanPropertyReadMethod(method)) {\n            if (method.getName().startsWith(\"get\")) {\n                return method.getName().substring(3, 4).toLowerCase()\n                        + method.getName().substring(4);\n            }\n            if (method.getName().startsWith(\"is\")) {\n                return method.getName().substring(2, 3).toLowerCase()\n                        + method.getName().substring(3);\n            }\n        }\n        return null;\n    }\n\n    public static boolean isBeanPropertyWriteMethod(Method method) {\n        return method != null\n                && Modifier.isPublic(method.getModifiers())\n                && !Modifier.isStatic(method.getModifiers())\n                && method.getDeclaringClass() != Object.class\n                && method.getParameterTypes().length == 1\n                && method.getName().startsWith(\"set\")\n                && method.getName().length() > 3;\n    }\n\n    public static String getPropertyNameFromBeanWriteMethod(Method method) {\n        if (isBeanPropertyWriteMethod(method)) {\n            return method.getName().substring(3, 4).toLowerCase()\n                    + method.getName().substring(4);\n        }\n        return null;\n    }\n\n    public static boolean isPublicInstanceField(Field field) {\n        return Modifier.isPublic(field.getModifiers())\n                && !Modifier.isStatic(field.getModifiers())\n                && !Modifier.isFinal(field.getModifiers())\n                && !field.isSynthetic();\n    }\n\n    public static Map<String, Field> getBeanPropertyFields(Class cl) {\n        Map<String, Field> properties = new HashMap<>();\n        for (; cl != null; cl = cl.getSuperclass()) {\n            Field[] fields = cl.getDeclaredFields();\n            for (Field field : fields) {\n                if (Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {\n                    continue;\n                }\n\n                field.setAccessible(true);\n\n                properties.put(field.getName(), field);\n            }\n        }\n\n        return properties;\n    }\n\n    public static Map<String, Method> getBeanPropertyReadMethods(Class cl) {\n        Map<String, Method> properties = new HashMap<>();\n        for (; cl != null; cl = cl.getSuperclass()) {\n            Method[] methods = cl.getDeclaredMethods();\n            for (Method method : methods) {\n                if (isBeanPropertyReadMethod(method)) {\n                    method.setAccessible(true);\n                    String property = getPropertyNameFromBeanReadMethod(method);\n                    properties.put(property, method);\n                }\n            }\n        }\n\n        return properties;\n    }\n\n    public static Type[] getReturnTypes(Method method) {\n        Class<?> returnType = method.getReturnType();\n        Type genericReturnType = method.getGenericReturnType();\n        if (Future.class.isAssignableFrom(returnType)) {\n            if (genericReturnType instanceof ParameterizedType) {\n                Type actualArgType = ((ParameterizedType) genericReturnType).getActualTypeArguments()[0];\n                if (actualArgType instanceof ParameterizedType) {\n                    returnType = (Class<?>) ((ParameterizedType) actualArgType).getRawType();\n                    genericReturnType = actualArgType;\n                } else if (actualArgType instanceof TypeVariable) {\n                    returnType = (Class<?>) ((TypeVariable<?>) actualArgType).getBounds()[0];\n                    genericReturnType = actualArgType;\n                } else {\n                    returnType = (Class<?>) actualArgType;\n                    genericReturnType = returnType;\n                }\n            } else {\n                returnType = null;\n                genericReturnType = null;\n            }\n        }\n        return new Type[] {returnType, genericReturnType};\n    }\n\n    /**\n     * Find the {@link Set} of {@link ParameterizedType}\n     *\n     * @param sourceClass the source {@link Class class}\n     * @return non-null read-only {@link Set}\n     * @since 2.7.5\n     */\n    public static Set<ParameterizedType> findParameterizedTypes(Class<?> sourceClass) {\n        // Add Generic Interfaces\n        List<Type> genericTypes = new LinkedList<>(asList(sourceClass.getGenericInterfaces()));\n        // Add Generic Super Class\n        genericTypes.add(sourceClass.getGenericSuperclass());\n\n        Set<ParameterizedType> parameterizedTypes = genericTypes.stream()\n                .filter(type -> type instanceof ParameterizedType) // filter ParameterizedType\n                .map(ParameterizedType.class::cast) // cast to ParameterizedType\n                .collect(Collectors.toSet());\n\n        if (parameterizedTypes.isEmpty()) { // If not found, try to search super types recursively\n            genericTypes.stream()\n                    .filter(type -> type instanceof Class)\n                    .map(Class.class::cast)\n                    .forEach(superClass -> parameterizedTypes.addAll(findParameterizedTypes(superClass)));\n        }\n\n        return unmodifiableSet(parameterizedTypes); // build as a Set\n    }\n\n    /**\n     * Find the hierarchical types from the source {@link Class class} by specified {@link Class type}.\n     *\n     * @param sourceClass the source {@link Class class}\n     * @param matchType   the type to match\n     * @param <T>         the type to match\n     * @return non-null read-only {@link Set}\n     * @since 2.7.5\n     */\n    public static <T> Set<Class<T>> findHierarchicalTypes(Class<?> sourceClass, Class<T> matchType) {\n        if (sourceClass == null) {\n            return Collections.emptySet();\n        }\n\n        Set<Class<T>> hierarchicalTypes = new LinkedHashSet<>();\n\n        if (matchType.isAssignableFrom(sourceClass)) {\n            hierarchicalTypes.add((Class<T>) sourceClass);\n        }\n\n        // Find all super classes\n        hierarchicalTypes.addAll(findHierarchicalTypes(sourceClass.getSuperclass(), matchType));\n\n        return unmodifiableSet(hierarchicalTypes);\n    }\n\n    /**\n     * Get the value from the specified bean and its getter method.\n     *\n     * @param bean       the bean instance\n     * @param methodName the name of getter\n     * @param <T>        the type of property value\n     * @return\n     * @since 2.7.5\n     */\n    public static <T> T getProperty(Object bean, String methodName) {\n        Class<?> beanClass = bean.getClass();\n        BeanInfo beanInfo = null;\n        T propertyValue = null;\n\n        try {\n            beanInfo = Introspector.getBeanInfo(beanClass);\n            propertyValue = (T) Stream.of(beanInfo.getMethodDescriptors())\n                    .filter(methodDescriptor -> methodName.equals(methodDescriptor.getName()))\n                    .findFirst()\n                    .map(method -> {\n                        try {\n                            return method.getMethod().invoke(bean);\n                        } catch (Exception e) {\n                            // ignore\n                        }\n                        return null;\n                    })\n                    .get();\n        } catch (Exception e) {\n\n        }\n        return propertyValue;\n    }\n\n    /**\n     * Check target bean class whether has specify method\n     * @param beanClass\n     * @param methodName\n     * @return\n     */\n    public static boolean hasMethod(Class<?> beanClass, String methodName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(beanClass);\n            Optional<MethodDescriptor> descriptor = Stream.of(beanInfo.getMethodDescriptors())\n                    .filter(methodDescriptor -> methodName.equals(methodDescriptor.getName()))\n                    .findFirst();\n            return descriptor.isPresent();\n        } catch (Exception e) {\n\n        }\n        return false;\n    }\n\n    /**\n     * Resolve the types of the specified values\n     *\n     * @param values the values\n     * @return If can't be resolved, return {@link ReflectUtils#EMPTY_CLASS_ARRAY empty class array}\n     * @since 2.7.6\n     */\n    public static Class[] resolveTypes(Object... values) {\n\n        if (isEmpty(values)) {\n            return EMPTY_CLASS_ARRAY;\n        }\n\n        int size = values.length;\n\n        Class[] types = new Class[size];\n\n        for (int i = 0; i < size; i++) {\n            Object value = values[i];\n            types[i] = value == null ? null : value.getClass();\n        }\n\n        return types;\n    }\n\n    public static boolean checkZeroArgConstructor(Class clazz) {\n        try {\n            clazz.getDeclaredConstructor();\n            return true;\n        } catch (NoSuchMethodException e) {\n            return false;\n        }\n    }\n\n    public static boolean isJdk(Class clazz) {\n        return clazz.getName().startsWith(\"java.\") || clazz.getName().startsWith(\"javax.\");\n    }\n\n    /**\n     * Copy from org.springframework.util.ReflectionUtils.\n     * Make the given method accessible, explicitly setting it accessible if\n     * necessary. The {@code setAccessible(true)} method is only called\n     * when actually necessary, to avoid unnecessary conflicts with a JVM\n     * SecurityManager (if active).\n     * @param method the method to make accessible\n     * @see java.lang.reflect.Method#setAccessible\n     */\n    @SuppressWarnings(\"deprecation\") // on JDK 9\n    public static void makeAccessible(Method method) {\n        if ((!Modifier.isPublic(method.getModifiers())\n                        || !Modifier.isPublic(method.getDeclaringClass().getModifiers()))\n                && !method.isAccessible()) {\n            method.setAccessible(true);\n        }\n    }\n\n    /**\n     * Get all field names of target type\n     * @param type\n     * @return\n     */\n    public static Set<String> getAllFieldNames(Class<?> type) {\n\n        Set<String> fieldNames = new HashSet<>();\n        for (Field field : type.getDeclaredFields()) {\n            fieldNames.add(field.getName());\n        }\n\n        Set<Class<?>> allSuperClasses = ClassUtils.getAllSuperClasses(type);\n        for (Class<?> aClass : allSuperClasses) {\n            for (Field field : aClass.getDeclaredFields()) {\n                fieldNames.add(field.getName());\n            }\n        }\n        return fieldNames;\n    }\n\n    public static <T> T getFieldValue(Object obj, String fieldName) throws RuntimeException {\n        if (obj == null) {\n            throw new IllegalArgumentException(\"object is null\");\n        }\n        try {\n            Field field = obj.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n            return (T) field.get(obj);\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 134,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java",
        "line": 207,
        "sink": "java.lang.Class<?>.isInstance",
        "source": "-",
        "sourceLine": 207,
        "qualifier": "Call to java.lang.Class<?>.isInstance with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.Class<?>.isInstance with untrusted data from [msg : String](2).",
        "line_number": 207,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 135
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 135
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 135
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 135
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java#L420",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport org.apache.dubbo.common.io.UnsafeStringWriter;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\n\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static java.lang.String.valueOf;\nimport static java.util.Collections.emptySet;\nimport static java.util.Collections.unmodifiableSet;\nimport static org.apache.dubbo.common.constants.CommonConstants.COMMA_SEPARATOR;\nimport static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;\nimport static org.apache.dubbo.common.constants.CommonConstants.DOT_REGEX;\nimport static org.apache.dubbo.common.constants.CommonConstants.GROUP_KEY;\nimport static org.apache.dubbo.common.constants.CommonConstants.HIDE_KEY_PREFIX;\nimport static org.apache.dubbo.common.constants.CommonConstants.INTERFACE_KEY;\nimport static org.apache.dubbo.common.constants.CommonConstants.SEPARATOR_REGEX;\nimport static org.apache.dubbo.common.constants.CommonConstants.UNDERLINE_SEPARATOR;\nimport static org.apache.dubbo.common.constants.CommonConstants.VERSION_KEY;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_JSON_CONVERT_EXCEPTION;\n\n/**\n * StringUtils\n */\npublic final class StringUtils {\n\n    public static final String EMPTY_STRING = \"\";\n    public static final int INDEX_NOT_FOUND = -1;\n    public static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(StringUtils.class);\n    private static final Pattern KVP_PATTERN =\n            Pattern.compile(\"([_.a-zA-Z0-9][-_.a-zA-Z0-9]*)[=](.*)\"); // key value pair pattern.\n    private static final Pattern NUM_PATTERN = Pattern.compile(\"^\\\\d+$\");\n    private static final Pattern PARAMETERS_PATTERN =\n            Pattern.compile(\"^\\\\[((\\\\s*\\\\{\\\\s*[\\\\w_\\\\-\\\\.]+\\\\s*:\\\\s*.+?\\\\s*\\\\}\\\\s*,?\\\\s*)+)\\\\s*\\\\]$\");\n    private static final Pattern PAIR_PARAMETERS_PATTERN =\n            Pattern.compile(\"^\\\\{\\\\s*([\\\\w-_\\\\.]+)\\\\s*:\\\\s*(.+)\\\\s*\\\\}$\");\n    private static final int PAD_LIMIT = 8192;\n    private static final byte[] HEX2B;\n\n    /**\n     * @since 2.7.5\n     */\n    public static final char EQUAL_CHAR = '=';\n\n    public static final String EQUAL = valueOf(EQUAL_CHAR);\n\n    public static final char AND_CHAR = '&';\n\n    public static final String AND = valueOf(AND_CHAR);\n\n    public static final char SEMICOLON_CHAR = ';';\n\n    public static final String SEMICOLON = valueOf(SEMICOLON_CHAR);\n\n    public static final char QUESTION_MASK_CHAR = '?';\n\n    public static final String QUESTION_MASK = valueOf(QUESTION_MASK_CHAR);\n\n    public static final char SLASH_CHAR = '/';\n\n    public static final String SLASH = valueOf(SLASH_CHAR);\n\n    public static final char HYPHEN_CHAR = '-';\n\n    public static final String HYPHEN = valueOf(HYPHEN_CHAR);\n\n    static {\n        HEX2B = new byte[128];\n        Arrays.fill(HEX2B, (byte) -1);\n        HEX2B['0'] = (byte) 0;\n        HEX2B['1'] = (byte) 1;\n        HEX2B['2'] = (byte) 2;\n        HEX2B['3'] = (byte) 3;\n        HEX2B['4'] = (byte) 4;\n        HEX2B['5'] = (byte) 5;\n        HEX2B['6'] = (byte) 6;\n        HEX2B['7'] = (byte) 7;\n        HEX2B['8'] = (byte) 8;\n        HEX2B['9'] = (byte) 9;\n        HEX2B['A'] = (byte) 10;\n        HEX2B['B'] = (byte) 11;\n        HEX2B['C'] = (byte) 12;\n        HEX2B['D'] = (byte) 13;\n        HEX2B['E'] = (byte) 14;\n        HEX2B['F'] = (byte) 15;\n        HEX2B['a'] = (byte) 10;\n        HEX2B['b'] = (byte) 11;\n        HEX2B['c'] = (byte) 12;\n        HEX2B['d'] = (byte) 13;\n        HEX2B['e'] = (byte) 14;\n        HEX2B['f'] = (byte) 15;\n    }\n\n    private StringUtils() {}\n\n    /**\n     * Gets a CharSequence length or {@code 0} if the CharSequence is\n     * {@code null}.\n     *\n     * @param cs a CharSequence or {@code null}\n     * @return CharSequence length or {@code 0} if the CharSequence is\n     * {@code null}.\n     */\n    public static int length(final CharSequence cs) {\n        return cs == null ? 0 : cs.length();\n    }\n\n    /**\n     * <p>Repeat a String {@code repeat} times to form a\n     * new String.</p>\n     *\n     * <pre>\n     * StringUtils.repeat(null, 2) = null\n     * StringUtils.repeat(\"\", 0)   = \"\"\n     * StringUtils.repeat(\"\", 2)   = \"\"\n     * StringUtils.repeat(\"a\", 3)  = \"aaa\"\n     * StringUtils.repeat(\"ab\", 2) = \"abab\"\n     * StringUtils.repeat(\"a\", -2) = \"\"\n     * </pre>\n     *\n     * @param str    the String to repeat, may be null\n     * @param repeat number of times to repeat str, negative treated as zero\n     * @return a new String consisting of the original String repeated,\n     * {@code null} if null String input\n     */\n    public static String repeat(final String str, final int repeat) {\n        // Performance tuned for 2.0 (JDK1.4)\n\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY_STRING;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1:\n                return repeat(str.charAt(0), repeat);\n            case 2:\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default:\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }\n\n    /**\n     * <p>Repeat a String {@code repeat} times to form a\n     * new String, with a String separator injected each time. </p>\n     *\n     * <pre>\n     * StringUtils.repeat(null, null, 2) = null\n     * StringUtils.repeat(null, \"x\", 2)  = null\n     * StringUtils.repeat(\"\", null, 0)   = \"\"\n     * StringUtils.repeat(\"\", \"\", 2)     = \"\"\n     * StringUtils.repeat(\"\", \"x\", 3)    = \"xxx\"\n     * StringUtils.repeat(\"?\", \", \", 3)  = \"?, ?, ?\"\n     * </pre>\n     *\n     * @param str       the String to repeat, may be null\n     * @param separator the String to inject, may be null\n     * @param repeat    number of times to repeat str, negative treated as zero\n     * @return a new String consisting of the original String repeated,\n     * {@code null} if null String input\n     * @since 2.5\n     */\n    public static String repeat(final String str, final String separator, final int repeat) {\n        if (str == null || separator == null) {\n            return repeat(str, repeat);\n        }\n        // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it\n        final String result = repeat(str + separator, repeat);\n        return removeEnd(result, separator);\n    }\n\n    /**\n     * <p>Removes a substring only if it is at the end of a source string,\n     * otherwise returns the source string.</p>\n     *\n     * <p>A {@code null} source string will return {@code null}.\n     * An empty (\"\") source string will return the empty string.\n     * A {@code null} search string will return the source string.</p>\n     *\n     * <pre>\n     * StringUtils.removeEnd(null, *)      = null\n     * StringUtils.removeEnd(\"\", *)        = \"\"\n     * StringUtils.removeEnd(*, null)      = *\n     * StringUtils.removeEnd(\"www.domain.com\", \".com.\")  = \"www.domain.com\"\n     * StringUtils.removeEnd(\"www.domain.com\", \".com\")   = \"www.domain\"\n     * StringUtils.removeEnd(\"www.domain.com\", \"domain\") = \"www.domain.com\"\n     * StringUtils.removeEnd(\"abc\", \"\")    = \"abc\"\n     * </pre>\n     *\n     * @param str    the source String to search, may be null\n     * @param remove the String to search for and remove, may be null\n     * @return the substring with the string removed if found,\n     * {@code null} if null String input\n     */\n    public static String removeEnd(final String str, final String remove) {\n        if (isAnyEmpty(str, remove)) {\n            return str;\n        }\n        if (str.endsWith(remove)) {\n            return str.substring(0, str.length() - remove.length());\n        }\n        return str;\n    }\n\n    /**\n     * <p>Returns padding using the specified delimiter repeated\n     * to a given length.</p>\n     *\n     * <pre>\n     * StringUtils.repeat('e', 0)  = \"\"\n     * StringUtils.repeat('e', 3)  = \"eee\"\n     * StringUtils.repeat('e', -2) = \"\"\n     * </pre>\n     *\n     * <p>Note: this method doesn't not support padding with\n     * <a href=\"http://www.unicode.org/glossary/#supplementary_character\">Unicode Supplementary Characters</a>\n     * as they require a pair of {@code char}s to be represented.\n     * If you are needing to support full I18N of your applications\n     * consider using {@link #repeat(String, int)} instead.\n     * </p>\n     *\n     * @param ch     character to repeat\n     * @param repeat number of times to repeat char, negative treated as zero\n     * @return String with repeated character\n     * @see #repeat(String, int)\n     */\n    public static String repeat(final char ch, final int repeat) {\n        final char[] buf = new char[repeat];\n        for (int i = repeat - 1; i >= 0; i--) {\n            buf[i] = ch;\n        }\n        return new String(buf);\n    }\n\n    /**\n     * <p>Strips any of a set of characters from the end of a String.</p>\n     *\n     * <p>A {@code null} input String returns {@code null}.\n     * An empty string (\"\") input returns the empty string.</p>\n     *\n     * <p>If the stripChars String is {@code null}, whitespace is\n     * stripped as defined by {@link Character#isWhitespace(char)}.</p>\n     *\n     * <pre>\n     * StringUtils.stripEnd(null, *)          = null\n     * StringUtils.stripEnd(\"\", *)            = \"\"\n     * StringUtils.stripEnd(\"abc\", \"\")        = \"abc\"\n     * StringUtils.stripEnd(\"abc\", null)      = \"abc\"\n     * StringUtils.stripEnd(\"  abc\", null)    = \"  abc\"\n     * StringUtils.stripEnd(\"abc  \", null)    = \"abc\"\n     * StringUtils.stripEnd(\" abc \", null)    = \" abc\"\n     * StringUtils.stripEnd(\"  abcyx\", \"xyz\") = \"  abc\"\n     * StringUtils.stripEnd(\"120.00\", \".0\")   = \"12\"\n     * </pre>\n     *\n     * @param str        the String to remove characters from, may be null\n     * @param stripChars the set of characters to remove, null treated as whitespace\n     * @return the stripped String, {@code null} if null String input\n     */\n    public static String stripEnd(final String str, final String stripChars) {\n        int end;\n        if (str == null || (end = str.length()) == 0) {\n            return str;\n        }\n\n        if (stripChars == null) {\n            while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {\n                end--;\n            }\n        } else if (stripChars.isEmpty()) {\n            return str;\n        } else {\n            while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {\n                end--;\n            }\n        }\n        return str.substring(0, end);\n    }\n\n    /**\n     * <p>Replaces all occurrences of a String within another String.</p>\n     *\n     * <p>A {@code null} reference passed to this method is a no-op.</p>\n     *\n     * <pre>\n     * StringUtils.replace(null, *, *)        = null\n     * StringUtils.replace(\"\", *, *)          = \"\"\n     * StringUtils.replace(\"any\", null, *)    = \"any\"\n     * StringUtils.replace(\"any\", *, null)    = \"any\"\n     * StringUtils.replace(\"any\", \"\", *)      = \"any\"\n     * StringUtils.replace(\"aba\", \"a\", null)  = \"aba\"\n     * StringUtils.replace(\"aba\", \"a\", \"\")    = \"b\"\n     * StringUtils.replace(\"aba\", \"a\", \"z\")   = \"zbz\"\n     * </pre>\n     *\n     * @param text         text to search and replace in, may be null\n     * @param searchString the String to search for, may be null\n     * @param replacement  the String to replace it with, may be null\n     * @return the text with any replacements processed,\n     * {@code null} if null String input\n     * @see #replace(String text, String searchString, String replacement, int max)\n     */\n    public static String replace(final String text, final String searchString, final String replacement) {\n        return replace(text, searchString, replacement, -1);\n    }\n\n    /**\n     * <p>Replaces a String with another String inside a larger String,\n     * for the first {@code max} values of the search String.</p>\n     *\n     * <p>A {@code null} reference passed to this method is a no-op.</p>\n     *\n     * <pre>\n     * StringUtils.replace(null, *, *, *)         = null\n     * StringUtils.replace(\"\", *, *, *)           = \"\"\n     * StringUtils.replace(\"any\", null, *, *)     = \"any\"\n     * StringUtils.replace(\"any\", *, null, *)     = \"any\"\n     * StringUtils.replace(\"any\", \"\", *, *)       = \"any\"\n     * StringUtils.replace(\"any\", *, *, 0)        = \"any\"\n     * StringUtils.replace(\"abaa\", \"a\", null, -1) = \"abaa\"\n     * StringUtils.replace(\"abaa\", \"a\", \"\", -1)   = \"b\"\n     * StringUtils.replace(\"abaa\", \"a\", \"z\", 0)   = \"abaa\"\n     * StringUtils.replace(\"abaa\", \"a\", \"z\", 1)   = \"zbaa\"\n     * StringUtils.replace(\"abaa\", \"a\", \"z\", 2)   = \"zbza\"\n     * StringUtils.replace(\"abaa\", \"a\", \"z\", -1)  = \"zbzz\"\n     * </pre>\n     *\n     * @param text         text to search and replace in, may be null\n     * @param searchString the String to search for, may be null\n     * @param replacement  the String to replace it with, may be null\n     * @param max          maximum number of values to replace, or {@code -1} if no maximum\n     * @return the text with any replacements processed,\n     * {@code null} if null String input\n     */\n    public static String replace(final String text, final String searchString, final String replacement, int max) {\n        if (isAnyEmpty(text, searchString) || replacement == null || max == 0) {\n            return text;\n        }\n        int start = 0;\n        int end = text.indexOf(searchString, start);\n        if (end == INDEX_NOT_FOUND) {\n            return text;\n        }\n        final int replLength = searchString.length();\n        int increase = replacement.length() - replLength;\n        increase = increase < 0 ? 0 : increase;\n        increase *= max < 0 ? 16 : max > 64 ? 64 : max;\n        final StringBuilder buf = new StringBuilder(text.length() + increase);\n        while (end != INDEX_NOT_FOUND) {\n            buf.append(text, start, end).append(replacement);\n            start = end + replLength;\n            if (--max == 0) {\n                break;\n            }\n            end = text.indexOf(searchString, start);\n        }\n        buf.append(text.substring(start));\n        return buf.toString();\n    }\n\n    public static boolean isBlank(CharSequence cs) {\n        int strLen;\n        if (cs == null || (strLen = cs.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(cs.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * is not blank string.\n     *\n     * @param cs source string.\n     * @return is not blank.\n     */\n    public static boolean isNotBlank(CharSequence cs) {\n        return !isBlank(cs);\n    }\n\n    /**\n     * Check the cs String whether contains non whitespace characters.\n     *\n     * @param cs\n     * @return\n     */\n    public static boolean hasText(CharSequence cs) {\n        return !isBlank(cs);\n    }\n\n    /**\n     * is empty string.\n     *\n     * @param str source string.\n     * @return is empty.\n     */\n    public static boolean isEmpty(String str) {\n        return str == null || str.isEmpty();\n    }\n\n    /**\n     * <p>Checks if the strings contain empty or null elements. <p/>\n     *\n     * <pre>\n     * StringUtils.isNoneEmpty(null)            = false\n     * StringUtils.isNoneEmpty(\"\")              = false\n     * StringUtils.isNoneEmpty(\" \")             = true\n     * StringUtils.isNoneEmpty(\"abc\")           = true\n     * StringUtils.isNoneEmpty(\"abc\", \"def\")    = true\n     * StringUtils.isNoneEmpty(\"abc\", null)     = false\n     * StringUtils.isNoneEmpty(\"abc\", \"\")       = false\n     * StringUtils.isNoneEmpty(\"abc\", \" \")      = true\n     * </pre>\n     *\n     * @param ss the strings to check\n     * @return {@code true} if all strings are not empty or null\n     */\n    public static boolean isNoneEmpty(final String... ss) {\n        if (ArrayUtils.isEmpty(ss)) {\n            return false;\n        }\n        for (final String s : ss) {\n            if (isEmpty(s)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks if the strings contain at least on empty or null element. <p/>\n     *\n     * <pre>\n     * StringUtils.isAnyEmpty(null)            = true\n     * StringUtils.isAnyEmpty(\"\")              = true\n     * StringUtils.isAnyEmpty(\" \")             = false\n     * StringUtils.isAnyEmpty(\"abc\")           = false\n     * StringUtils.isAnyEmpty(\"abc\", \"def\")    = false\n     * StringUtils.isAnyEmpty(\"abc\", null)     = true\n     * StringUtils.isAnyEmpty(\"abc\", \"\")       = true\n     * StringUtils.isAnyEmpty(\"abc\", \" \")      = false\n     * </pre>\n     *\n     * @param ss the strings to check\n     * @return {@code true} if at least one in the strings is empty or null\n     */\n    public static boolean isAnyEmpty(final String... ss) {\n        return !isNoneEmpty(ss);\n    }\n\n    /**\n     * is not empty string.\n     *\n     * @param str source string.\n     * @return is not empty.\n     */\n    public static boolean isNotEmpty(String str) {\n        return !isEmpty(str);\n    }\n\n    /**\n     * if s1 is null and s2 is null, then return true\n     *\n     * @param s1 str1\n     * @param s2 str2\n     * @return equals\n     */\n    public static boolean isEquals(String s1, String s2) {\n        if (s1 == null && s2 == null) {\n            return true;\n        }\n        if (s1 == null || s2 == null) {\n            return false;\n        }\n        return s1.equals(s2);\n    }\n\n    /**\n     * is positive integer or zero string.\n     *\n     * @param str a string\n     * @return is positive integer or zero\n     */\n    public static boolean isNumber(String str) {\n        return isNotEmpty(str) && NUM_PATTERN.matcher(str).matches();\n    }\n\n    /**\n     * parse str to Integer(if str is not number or n < 0, then return 0)\n     *\n     * @param str a number str\n     * @return positive integer or zero\n     */\n    public static int parseInteger(String str) {\n        return isNumber(str) ? Integer.parseInt(str) : 0;\n    }\n\n    /**\n     * parse str to Long(if str is not number or n < 0, then return 0)\n     *\n     * @param str a number str\n     * @return positive long or zero\n     */\n    public static long parseLong(String str) {\n        return isNumber(str) ? Long.parseLong(str) : 0;\n    }\n\n    /**\n     * Returns true if s is a legal Java identifier.<p>\n     * <a href=\"http://www.exampledepot.com/egs/java.lang/IsJavaId.html\">more info.</a>\n     */\n    public static boolean isJavaIdentifier(String s) {\n        if (isEmpty(s) || !Character.isJavaIdentifierStart(s.charAt(0))) {\n            return false;\n        }\n        for (int i = 1; i < s.length(); i++) {\n            if (!Character.isJavaIdentifierPart(s.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean isContains(String values, String value) {\n        return isNotEmpty(values) && isContains(COMMA_SPLIT_PATTERN.split(values), value);\n    }\n\n    public static boolean isContains(String str, char ch) {\n        return isNotEmpty(str) && str.indexOf(ch) >= 0;\n    }\n\n    public static boolean isNotContains(String str, char ch) {\n        return !isContains(str, ch);\n    }\n\n    /**\n     * @param values\n     * @param value\n     * @return contains\n     */\n    public static boolean isContains(String[] values, String value) {\n        if (isNotEmpty(value) && ArrayUtils.isNotEmpty(values)) {\n            for (String v : values) {\n                if (value.equals(v)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static boolean isNumeric(String str, boolean allowDot) {\n        if (str == null || str.isEmpty()) {\n            return false;\n        }\n        boolean hasDot = false;\n        int sz = str.length();\n        for (int i = 0; i < sz; i++) {\n            if (str.charAt(i) == '.') {\n                if (hasDot || !allowDot) {\n                    return false;\n                }\n                hasDot = true;\n                continue;\n            }\n            if (!Character.isDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param e\n     * @return string\n     */\n    public static String toString(Throwable e) {\n        UnsafeStringWriter w = new UnsafeStringWriter();\n        PrintWriter p = new PrintWriter(w);\n        p.print(e.getClass().getName());\n        if (e.getMessage() != null) {\n            p.print(\": \" + e.getMessage());\n        }\n        p.println();\n        try {\n            e.printStackTrace(p);\n            return w.toString();\n        } finally {\n            p.close();\n        }\n    }\n\n    /**\n     * @param msg\n     * @param e\n     * @return string\n     */\n    public static String toString(String msg, Throwable e) {\n        UnsafeStringWriter w = new UnsafeStringWriter();\n        w.write(msg + \"\\n\");\n        PrintWriter p = new PrintWriter(w);\n        try {\n            e.printStackTrace(p);\n            return w.toString();\n        } finally {\n            p.close();\n        }\n    }\n\n    /**\n     * translate.\n     *\n     * @param src  source string.\n     * @param from src char table.\n     * @param to   target char table.\n     * @return String.\n     */\n    public static String translate(String src, String from, String to) {\n        if (isEmpty(src)) {\n            return src;\n        }\n        StringBuilder sb = null;\n        int ix;\n        char c;\n        for (int i = 0, len = src.length(); i < len; i++) {\n            c = src.charAt(i);\n            ix = from.indexOf(c);\n            if (ix == -1) {\n                if (sb != null) {\n                    sb.append(c);\n                }\n            } else {\n                if (sb == null) {\n                    sb = new StringBuilder(len);\n                    sb.append(src, 0, i);\n                }\n                if (ix < to.length()) {\n                    sb.append(to.charAt(ix));\n                }\n            }\n        }\n        return sb == null ? src : sb.toString();\n    }\n\n    /**\n     * split.\n     *\n     * @param ch char.\n     * @return string array.\n     */\n    public static String[] split(String str, char ch) {\n        if (isEmpty(str)) {\n            return EMPTY_STRING_ARRAY;\n        }\n        return splitToList0(str, ch).toArray(EMPTY_STRING_ARRAY);\n    }\n\n    private static List<String> splitToList0(String str, char ch) {\n        List<String> result = new ArrayList<>();\n        int ix = 0, len = str.length();\n        for (int i = 0; i < len; i++) {\n            if (str.charAt(i) == ch) {\n                result.add(str.substring(ix, i));\n                ix = i + 1;\n            }\n        }\n\n        if (ix >= 0) {\n            result.add(str.substring(ix));\n        }\n        return result;\n    }\n\n    /**\n     * Splits String around matches of the given character.\n     * <p>\n     * Note: Compare with {@link StringUtils#split(String, char)}, this method reduce memory copy.\n     */\n    public static List<String> splitToList(String str, char ch) {\n        if (isEmpty(str)) {\n            return Collections.emptyList();\n        }\n        return splitToList0(str, ch);\n    }\n\n    /**\n     * Split the specified value to be a {@link Set}\n     *\n     * @param value         the content to be split\n     * @param separatorChar a char to separate\n     * @return non-null read-only {@link Set}\n     * @since 2.7.8\n     */\n    public static Set<String> splitToSet(String value, char separatorChar) {\n        return splitToSet(value, separatorChar, false);\n    }\n\n    /**\n     * Split the specified value to be a {@link Set}\n     *\n     * @param value         the content to be split\n     * @param separatorChar a char to separate\n     * @param trimElements  require to trim the elements or not\n     * @return non-null read-only {@link Set}\n     * @since 2.7.8\n     */\n    public static Set<String> splitToSet(String value, char separatorChar, boolean trimElements) {\n        List<String> values = splitToList(value, separatorChar);\n        int size = values.size();\n\n        if (size < 1) { // empty condition\n            return emptySet();\n        }\n\n        if (!trimElements) { // Do not require to trim the elements\n            return new LinkedHashSet(values);\n        }\n\n        return unmodifiableSet(values.stream().map(String::trim).collect(LinkedHashSet::new, Set::add, Set::addAll));\n    }\n\n    /**\n     * join string.\n     *\n     * @param array String array.\n     * @return String.\n     */\n    public static String join(String[] array) {\n        if (ArrayUtils.isEmpty(array)) {\n            return EMPTY_STRING;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (String s : array) {\n            sb.append(s);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * join string like javascript.\n     *\n     * @param array String array.\n     * @param split split\n     * @return String.\n     */\n    public static String join(String[] array, char split) {\n        if (ArrayUtils.isEmpty(array)) {\n            return EMPTY_STRING;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < array.length; i++) {\n            if (i > 0) {\n                sb.append(split);\n            }\n            sb.append(array[i]);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * join string like javascript.\n     *\n     * @param array String array.\n     * @param split split\n     * @return String.\n     */\n    public static String join(String[] array, String split) {\n        if (ArrayUtils.isEmpty(array)) {\n            return EMPTY_STRING;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < array.length; i++) {\n            if (i > 0) {\n                sb.append(split);\n            }\n            sb.append(array[i]);\n        }\n        return sb.toString();\n    }\n\n    public static String join(Collection<String> coll, String split) {\n        if (CollectionUtils.isEmpty(coll)) {\n            return EMPTY_STRING;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        boolean isFirst = true;\n        for (String s : coll) {\n            if (isFirst) {\n                isFirst = false;\n            } else {\n                sb.append(split);\n            }\n            sb.append(s);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * parse key-value pair.\n     *\n     * @param str           string.\n     * @param itemSeparator item separator.\n     * @return key-value map;\n     */\n    private static Map<String, String> parseKeyValuePair(String str, String itemSeparator) {\n        String[] tmp = str.split(itemSeparator);\n        Map<String, String> map = new HashMap<>(tmp.length);\n        for (int i = 0; i < tmp.length; i++) {\n            Matcher matcher = KVP_PATTERN.matcher(tmp[i]);\n            if (!matcher.matches()) {\n                continue;\n            }\n            map.put(matcher.group(1), matcher.group(2));\n        }\n        return map;\n    }\n\n    public static String getQueryStringValue(String qs, String key) {\n        Map<String, String> map = parseQueryString(qs);\n        return map.get(key);\n    }\n\n    /**\n     * parse query string to Parameters.\n     *\n     * @param qs query string.\n     * @return Parameters instance.\n     */\n    public static Map<String, String> parseQueryString(String qs) {\n        if (isEmpty(qs)) {\n            return new HashMap<>();\n        }\n        return parseKeyValuePair(qs, \"\\\\&\");\n    }\n\n    public static String getServiceKey(Map<String, String> ps) {\n        StringBuilder buf = new StringBuilder();\n        String group = ps.get(GROUP_KEY);\n        if (isNotEmpty(group)) {\n            buf.append(group).append('/');\n        }\n        buf.append(ps.get(INTERFACE_KEY));\n        String version = ps.get(VERSION_KEY);\n        if (isNotEmpty(group)) {\n            buf.append(':').append(version);\n        }\n        return buf.toString();\n    }\n\n    public static String toQueryString(Map<String, String> ps) {\n        StringBuilder buf = new StringBuilder();\n        if (ps != null && ps.size() > 0) {\n            for (Map.Entry<String, String> entry : new TreeMap<String, String>(ps).entrySet()) {\n                String key = entry.getKey();\n                String value = entry.getValue();\n                if (isNoneEmpty(key, value)) {\n                    if (buf.length() > 0) {\n                        buf.append('&');\n                    }\n                    buf.append(key);\n                    buf.append('=');\n                    buf.append(value);\n                }\n            }\n        }\n        return buf.toString();\n    }\n\n    public static String camelToSplitName(String camelName, String split) {\n        if (isEmpty(camelName)) {\n            return camelName;\n        }\n        if (!isWord(camelName)) {\n            // convert Ab-Cd-Ef to ab-cd-ef\n            if (isSplitCase(camelName, split.charAt(0))) {\n                return camelName.toLowerCase();\n            }\n            // not camel case\n            return camelName;\n        }\n\n        StringBuilder buf = null;\n        for (int i = 0; i < camelName.length(); i++) {\n            char ch = camelName.charAt(i);\n            if (ch >= 'A' && ch <= 'Z') {\n                if (buf == null) {\n                    buf = new StringBuilder();\n                    if (i > 0) {\n                        buf.append(camelName, 0, i);\n                    }\n                }\n                if (i > 0) {\n                    buf.append(split);\n                }\n                buf.append(Character.toLowerCase(ch));\n            } else if (buf != null) {\n                buf.append(ch);\n            }\n        }\n        return buf == null ? camelName.toLowerCase() : buf.toString().toLowerCase();\n    }\n\n    private static boolean isSplitCase(String str, char separator) {\n        if (str == null) {\n            return false;\n        }\n        return str.chars().allMatch(ch -> (ch == separator) || isWord((char) ch));\n    }\n\n    private static boolean isWord(String str) {\n        if (str == null) {\n            return false;\n        }\n        return str.chars().allMatch(ch -> isWord((char) ch));\n    }\n\n    private static boolean isWord(char ch) {\n        if ((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9')) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Convert snake_case or SNAKE_CASE to kebab-case.\n     * <p>\n     * NOTE: Return itself if it's not a snake case.\n     *\n     * @param snakeName\n     * @param split\n     * @return\n     */\n    public static String snakeToSplitName(String snakeName, String split) {\n        String lowerCase = snakeName.toLowerCase();\n        if (isSnakeCase(snakeName)) {\n            return replace(lowerCase, \"_\", split);\n        }\n        return snakeName;\n    }\n\n    protected static boolean isSnakeCase(String str) {\n        return str.contains(\"_\") || str.equals(str.toLowerCase()) || str.equals(str.toUpperCase());\n    }\n\n    /**\n     * Convert camelCase or snake_case/SNAKE_CASE to kebab-case\n     *\n     * @param str\n     * @param split\n     * @return\n     */\n    public static String convertToSplitName(String str, String split) {\n        if (isSnakeCase(str)) {\n            return snakeToSplitName(str, split);\n        } else {\n            return camelToSplitName(str, split);\n        }\n    }\n\n    public static String toArgumentString(Object[] args) {\n        StringBuilder buf = new StringBuilder();\n        for (Object arg : args) {\n            if (buf.length() > 0) {\n                buf.append(COMMA_SEPARATOR);\n            }\n            if (arg == null || ReflectUtils.isPrimitives(arg.getClass())) {\n                buf.append(arg);\n            } else {\n                try {\n                    buf.append(JsonUtils.toJson(arg));\n                } catch (Exception e) {\n                    logger.warn(COMMON_JSON_CONVERT_EXCEPTION, \"\", \"\", e.getMessage(), e);\n                    buf.append(arg);\n                }\n            }\n        }\n        return buf.toString();\n    }\n\n    public static String trim(String str) {\n        return str == null ? null : str.trim();\n    }\n\n    public static String toURLKey(String key) {\n        return key.toLowerCase().replaceAll(SEPARATOR_REGEX, HIDE_KEY_PREFIX);\n    }\n\n    public static String toOSStyleKey(String key) {\n        key = key.toUpperCase().replaceAll(DOT_REGEX, UNDERLINE_SEPARATOR);\n        if (!key.startsWith(\"DUBBO_\")) {\n            key = \"DUBBO_\" + key;\n        }\n        return key;\n    }\n\n    public static boolean isAllUpperCase(String str) {\n        if (str != null && !isEmpty(str)) {\n            int sz = str.length();\n\n            for (int i = 0; i < sz; ++i) {\n                if (!Character.isUpperCase(str.charAt(i))) {\n                    return false;\n                }\n            }\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public static String[] delimitedListToStringArray(String str, String delimiter) {\n        return delimitedListToStringArray(str, delimiter, (String) null);\n    }\n\n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {\n        if (str == null) {\n            return new String[0];\n        } else if (delimiter == null) {\n            return new String[] {str};\n        } else {\n            List<String> result = new ArrayList();\n            int pos;\n            if (\"\".equals(delimiter)) {\n                for (pos = 0; pos < str.length(); ++pos) {\n                    result.add(deleteAny(str.substring(pos, pos + 1), charsToDelete));\n                }\n            } else {\n                int delPos;\n                for (pos = 0; (delPos = str.indexOf(delimiter, pos)) != -1; pos = delPos + delimiter.length()) {\n                    result.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n                }\n\n                if (str.length() > 0 && pos <= str.length()) {\n                    result.add(deleteAny(str.substring(pos), charsToDelete));\n                }\n            }\n\n            return toStringArray((Collection) result);\n        }\n    }\n\n    public static String arrayToDelimitedString(Object[] arr, String delim) {\n        if (ArrayUtils.isEmpty(arr)) {\n            return \"\";\n        } else if (arr.length == 1) {\n            return nullSafeToString(arr[0]);\n        } else {\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i < arr.length; ++i) {\n                if (i > 0) {\n                    sb.append(delim);\n                }\n\n                sb.append(arr[i]);\n            }\n\n            return sb.toString();\n        }\n    }\n\n    public static String deleteAny(String inString, String charsToDelete) {\n        if (isNotEmpty(inString) && isNotEmpty(charsToDelete)) {\n            StringBuilder sb = new StringBuilder(inString.length());\n\n            for (int i = 0; i < inString.length(); ++i) {\n                char c = inString.charAt(i);\n                if (charsToDelete.indexOf(c) == -1) {\n                    sb.append(c);\n                }\n            }\n\n            return sb.toString();\n        } else {\n            return inString;\n        }\n    }\n\n    public static String[] toStringArray(Collection<String> collection) {\n        return (String[]) collection.toArray(new String[0]);\n    }\n\n    public static String nullSafeToString(Object obj) {\n        if (obj == null) {\n            return \"null\";\n        } else if (obj instanceof String) {\n            return (String) obj;\n        } else {\n            String str = obj.toString();\n            return str != null ? str : \"\";\n        }\n    }\n\n    /**\n     * Decode parameters string to map\n     *\n     * @param rawParameters format like '[{a:b},{c:d}]'\n     * @return\n     */\n    public static Map<String, String> parseParameters(String rawParameters) {\n        if (StringUtils.isBlank(rawParameters)) {\n            return Collections.emptyMap();\n        }\n        Matcher matcher = PARAMETERS_PATTERN.matcher(rawParameters);\n        if (!matcher.matches()) {\n            return Collections.emptyMap();\n        }\n\n        String pairs = matcher.group(1);\n        String[] pairArr = pairs.split(\"\\\\s*,\\\\s*\");\n\n        Map<String, String> parameters = new HashMap<>();\n        for (String pair : pairArr) {\n            Matcher pairMatcher = PAIR_PARAMETERS_PATTERN.matcher(pair);\n            if (pairMatcher.matches()) {\n                parameters.put(pairMatcher.group(1), pairMatcher.group(2));\n            }\n        }\n        return parameters;\n    }\n\n    /**\n     * Encode parameters map to string, like '[{a:b},{c:d}]'\n     *\n     * @param params\n     * @return\n     */\n    public static String encodeParameters(Map<String, String> params) {\n        if (params == null || params.isEmpty()) {\n            return null;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append('[');\n        params.forEach((key, value) -> {\n            // {key:value},\n            if (hasText(value)) {\n                sb.append('{').append(key).append(':').append(value).append(\"},\");\n            }\n        });\n        // delete last separator ','\n        if (sb.charAt(sb.length() - 1) == ',') {\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        sb.append(']');\n        return sb.toString();\n    }\n\n    public static int decodeHexNibble(final char c) {\n        // Character.digit() is not used here, as it addresses a larger\n        // set of characters (both ASCII and full-width latin letters).\n        byte[] hex2b = HEX2B;\n        return c < hex2b.length ? hex2b[c] : -1;\n    }\n\n    /**\n     * Decode a 2-digit hex byte from within a string.\n     */\n    public static byte decodeHexByte(CharSequence s, int pos) {\n        int hi = decodeHexNibble(s.charAt(pos));\n        int lo = decodeHexNibble(s.charAt(pos + 1));\n        if (hi == -1 || lo == -1) {\n            throw new IllegalArgumentException(\n                    String.format(\"invalid hex byte '%s' at index %d of '%s'\", s.subSequence(pos, pos + 2), pos, s));\n        }\n        return (byte) ((hi << 4) + lo);\n    }\n\n    /**\n     * Create the common-delimited {@link String} by one or more {@link String} members\n     *\n     * @param one    one {@link String}\n     * @param others others {@link String}\n     * @return <code>null</code> if <code>one</code> or <code>others</code> is <code>null</code>\n     * @since 2.7.8\n     */\n    public static String toCommaDelimitedString(String one, String... others) {\n        String another = arrayToDelimitedString(others, COMMA_SEPARATOR);\n        return isEmpty(another) ? one : one + COMMA_SEPARATOR + another;\n    }\n\n    /**\n     * Test str whether starts with the prefix ignore case.\n     *\n     * @param str\n     * @param prefix\n     * @return\n     */\n    public static boolean startsWithIgnoreCase(String str, String prefix) {\n        if (str == null || prefix == null || str.length() < prefix.length()) {\n            return false;\n        }\n        // return str.substring(0, prefix.length()).equalsIgnoreCase(prefix);\n        return str.regionMatches(true, 0, prefix, 0, prefix.length());\n    }\n}\n",
        "methodName": null,
        "exampleID": 136,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/StringUtils.java",
        "line": 420,
        "sink": "java.lang.Character.isWhitespace",
        "source": "-",
        "sourceLine": 420,
        "qualifier": "Call to java.lang.Character.isWhitespace with untrusted data from [msg : String](1).\nCall to java.lang.Character.isWhitespace with untrusted data from [getQueryString(...) : String](2).\nCall to java.lang.Character.isWhitespace with untrusted data from [getRequestURL(...) : StringBuffer](3).",
        "line_number": 420,
        "steps": [
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 137
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 137
            },
            {
                "line": 126,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "methodName": null,
                "exampleID": 137
            },
            {
                "line": 128,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/PageServlet.java",
                "methodName": null,
                "exampleID": 137
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java#L791",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport java.beans.BeanInfo;\nimport java.beans.Introspector;\nimport java.beans.MethodDescriptor;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.net.URL;\nimport java.security.CodeSource;\nimport java.security.ProtectionDomain;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.Future;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\nimport javassist.CtMethod;\nimport javassist.NotFoundException;\n\nimport static java.util.Arrays.asList;\nimport static java.util.Collections.unmodifiableSet;\nimport static org.apache.dubbo.common.utils.ArrayUtils.isEmpty;\n\n/**\n * ReflectUtils\n */\npublic final class ReflectUtils {\n\n    /**\n     * void(V).\n     */\n    public static final char JVM_VOID = 'V';\n\n    /**\n     * boolean(Z).\n     */\n    public static final char JVM_BOOLEAN = 'Z';\n\n    /**\n     * byte(B).\n     */\n    public static final char JVM_BYTE = 'B';\n\n    /**\n     * char(C).\n     */\n    public static final char JVM_CHAR = 'C';\n\n    /**\n     * double(D).\n     */\n    public static final char JVM_DOUBLE = 'D';\n\n    /**\n     * float(F).\n     */\n    public static final char JVM_FLOAT = 'F';\n\n    /**\n     * int(I).\n     */\n    public static final char JVM_INT = 'I';\n\n    /**\n     * long(J).\n     */\n    public static final char JVM_LONG = 'J';\n\n    /**\n     * short(S).\n     */\n    public static final char JVM_SHORT = 'S';\n\n    public static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];\n\n    public static final String JAVA_IDENT_REGEX = \"(?:[_$a-zA-Z][_$a-zA-Z0-9]*)\";\n\n    public static final String JAVA_NAME_REGEX = \"(?:\" + JAVA_IDENT_REGEX + \"(?:\\\\.\" + JAVA_IDENT_REGEX + \")*)\";\n\n    public static final String CLASS_DESC = \"(?:L\" + JAVA_IDENT_REGEX + \"(?:\\\\/\" + JAVA_IDENT_REGEX + \")*;)\";\n\n    public static final String ARRAY_DESC = \"(?:\\\\[+(?:(?:[VZBCDFIJS])|\" + CLASS_DESC + \"))\";\n\n    public static final String DESC_REGEX = \"(?:(?:[VZBCDFIJS])|\" + CLASS_DESC + \"|\" + ARRAY_DESC + \")\";\n\n    public static final Pattern DESC_PATTERN = Pattern.compile(DESC_REGEX);\n\n    public static final String METHOD_DESC_REGEX =\n            \"(?:(\" + JAVA_IDENT_REGEX + \")?\\\\((\" + DESC_REGEX + \"*)\\\\)(\" + DESC_REGEX + \")?)\";\n\n    public static final Pattern METHOD_DESC_PATTERN = Pattern.compile(METHOD_DESC_REGEX);\n\n    public static final Pattern GETTER_METHOD_DESC_PATTERN =\n            Pattern.compile(\"get([A-Z][_a-zA-Z0-9]*)\\\\(\\\\)(\" + DESC_REGEX + \")\");\n\n    public static final Pattern SETTER_METHOD_DESC_PATTERN =\n            Pattern.compile(\"set([A-Z][_a-zA-Z0-9]*)\\\\((\" + DESC_REGEX + \")\\\\)V\");\n\n    public static final Pattern IS_HAS_CAN_METHOD_DESC_PATTERN =\n            Pattern.compile(\"(?:is|has|can)([A-Z][_a-zA-Z0-9]*)\\\\(\\\\)Z\");\n\n    private static Map<Class<?>, Object> primitiveDefaults = new HashMap<>();\n\n    static {\n        primitiveDefaults.put(int.class, 0);\n        primitiveDefaults.put(long.class, 0L);\n        primitiveDefaults.put(byte.class, (byte) 0);\n        primitiveDefaults.put(char.class, (char) 0);\n        primitiveDefaults.put(short.class, (short) 0);\n        primitiveDefaults.put(float.class, (float) 0);\n        primitiveDefaults.put(double.class, (double) 0);\n        primitiveDefaults.put(boolean.class, false);\n        primitiveDefaults.put(void.class, null);\n    }\n\n    private ReflectUtils() {}\n\n    public static boolean isPrimitives(Class<?> cls) {\n        while (cls.isArray()) {\n            cls = cls.getComponentType();\n        }\n        return isPrimitive(cls);\n    }\n\n    public static boolean isPrimitive(Class<?> cls) {\n        return cls.isPrimitive()\n                || cls == String.class\n                || cls == Boolean.class\n                || cls == Character.class\n                || Number.class.isAssignableFrom(cls)\n                || Date.class.isAssignableFrom(cls);\n    }\n\n    public static Class<?> getBoxedClass(Class<?> c) {\n        if (c == int.class) {\n            c = Integer.class;\n        } else if (c == boolean.class) {\n            c = Boolean.class;\n        } else if (c == long.class) {\n            c = Long.class;\n        } else if (c == float.class) {\n            c = Float.class;\n        } else if (c == double.class) {\n            c = Double.class;\n        } else if (c == char.class) {\n            c = Character.class;\n        } else if (c == byte.class) {\n            c = Byte.class;\n        } else if (c == short.class) {\n            c = Short.class;\n        }\n        return c;\n    }\n\n    /**\n     * is compatible.\n     *\n     * @param c class.\n     * @param o instance.\n     * @return compatible or not.\n     */\n    public static boolean isCompatible(Class<?> c, Object o) {\n        boolean pt = c.isPrimitive();\n        if (o == null) {\n            return !pt;\n        }\n\n        if (pt) {\n            c = getBoxedClass(c);\n        }\n\n        return c == o.getClass() || c.isInstance(o);\n    }\n\n    /**\n     * is compatible.\n     *\n     * @param cs class array.\n     * @param os object array.\n     * @return compatible or not.\n     */\n    public static boolean isCompatible(Class<?>[] cs, Object[] os) {\n        int len = cs.length;\n        if (len != os.length) {\n            return false;\n        }\n        if (len == 0) {\n            return true;\n        }\n        for (int i = 0; i < len; i++) {\n            if (!isCompatible(cs[i], os[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static String getCodeBase(Class<?> cls) {\n        if (cls == null) {\n            return null;\n        }\n        ProtectionDomain domain = cls.getProtectionDomain();\n        if (domain == null) {\n            return null;\n        }\n        CodeSource source = domain.getCodeSource();\n        if (source == null) {\n            return null;\n        }\n        URL location = source.getLocation();\n        if (location == null) {\n            return null;\n        }\n        return location.getFile();\n    }\n\n    /**\n     * get name.\n     * java.lang.Object[][].class => \"java.lang.Object[][]\"\n     *\n     * @param c class.\n     * @return name.\n     */\n    public static String getName(Class<?> c) {\n        if (c.isArray()) {\n            StringBuilder sb = new StringBuilder();\n            do {\n                sb.append(\"[]\");\n                c = c.getComponentType();\n            } while (c.isArray());\n\n            return c.getName() + sb.toString();\n        }\n        return c.getName();\n    }\n\n    public static Class<?> getGenericClass(Class<?> cls) {\n        return getGenericClass(cls, 0);\n    }\n\n    public static Class<?> getGenericClass(Class<?> cls, int i) {\n        try {\n            ParameterizedType parameterizedType = ((ParameterizedType) cls.getGenericInterfaces()[0]);\n            Object genericClass = parameterizedType.getActualTypeArguments()[i];\n\n            // handle nested generic type\n            if (genericClass instanceof ParameterizedType) {\n                return (Class<?>) ((ParameterizedType) genericClass).getRawType();\n            }\n\n            // handle array generic type\n            if (genericClass instanceof GenericArrayType) {\n                return (Class<?>) ((GenericArrayType) genericClass).getGenericComponentType();\n            }\n\n            // Requires JDK 7 or higher, Foo<int[]> is no longer GenericArrayType\n            if (((Class) genericClass).isArray()) {\n                return ((Class) genericClass).getComponentType();\n            }\n            return (Class<?>) genericClass;\n        } catch (Throwable e) {\n            throw new IllegalArgumentException(cls.getName() + \" generic type undefined!\", e);\n        }\n    }\n\n    /**\n     * get method name.\n     * \"void do(int)\", \"void do()\", \"int do(java.lang.String,boolean)\"\n     *\n     * @param m method.\n     * @return name.\n     */\n    public static String getName(final Method m) {\n        StringBuilder ret = new StringBuilder();\n        ret.append(getName(m.getReturnType())).append(' ');\n        ret.append(m.getName()).append('(');\n        Class<?>[] parameterTypes = m.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            if (i > 0) {\n                ret.append(',');\n            }\n            ret.append(getName(parameterTypes[i]));\n        }\n        ret.append(')');\n        return ret.toString();\n    }\n\n    public static String getSignature(String methodName, Class<?>[] parameterTypes) {\n        StringBuilder sb = new StringBuilder(methodName);\n        sb.append('(');\n        if (parameterTypes != null && parameterTypes.length > 0) {\n            boolean first = true;\n            for (Class<?> type : parameterTypes) {\n                if (first) {\n                    first = false;\n                } else {\n                    sb.append(',');\n                }\n                sb.append(type.getName());\n            }\n        }\n        sb.append(')');\n        return sb.toString();\n    }\n\n    /**\n     * get constructor name.\n     * \"()\", \"(java.lang.String,int)\"\n     *\n     * @param c constructor.\n     * @return name.\n     */\n    public static String getName(final Constructor<?> c) {\n        StringBuilder ret = new StringBuilder(\"(\");\n        Class<?>[] parameterTypes = c.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            if (i > 0) {\n                ret.append(',');\n            }\n            ret.append(getName(parameterTypes[i]));\n        }\n        ret.append(')');\n        return ret.toString();\n    }\n\n    /**\n     * get class desc.\n     * boolean[].class => \"[Z\"\n     * Object.class => \"Ljava/lang/Object;\"\n     *\n     * @param c class.\n     * @return desc.\n     * @throws NotFoundException\n     */\n    public static String getDesc(Class<?> c) {\n        StringBuilder ret = new StringBuilder();\n\n        while (c.isArray()) {\n            ret.append('[');\n            c = c.getComponentType();\n        }\n\n        if (c.isPrimitive()) {\n            String t = c.getName();\n            if (\"void\".equals(t)) {\n                ret.append(JVM_VOID);\n            } else if (\"boolean\".equals(t)) {\n                ret.append(JVM_BOOLEAN);\n            } else if (\"byte\".equals(t)) {\n                ret.append(JVM_BYTE);\n            } else if (\"char\".equals(t)) {\n                ret.append(JVM_CHAR);\n            } else if (\"double\".equals(t)) {\n                ret.append(JVM_DOUBLE);\n            } else if (\"float\".equals(t)) {\n                ret.append(JVM_FLOAT);\n            } else if (\"int\".equals(t)) {\n                ret.append(JVM_INT);\n            } else if (\"long\".equals(t)) {\n                ret.append(JVM_LONG);\n            } else if (\"short\".equals(t)) {\n                ret.append(JVM_SHORT);\n            }\n        } else {\n            ret.append('L');\n            ret.append(c.getName().replace('.', '/'));\n            ret.append(';');\n        }\n        return ret.toString();\n    }\n\n    /**\n     * get class array desc.\n     * [int.class, boolean[].class, Object.class] => \"I[ZLjava/lang/Object;\"\n     *\n     * @param cs class array.\n     * @return desc.\n     * @throws NotFoundException\n     */\n    public static String getDesc(final Class<?>[] cs) {\n        if (cs.length == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(64);\n        for (Class<?> c : cs) {\n            sb.append(getDesc(c));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * get method desc.\n     * int do(int arg1) => \"do(I)I\"\n     * void do(String arg1,boolean arg2) => \"do(Ljava/lang/String;Z)V\"\n     *\n     * @param m method.\n     * @return desc.\n     */\n    public static String getDesc(final Method m) {\n        StringBuilder ret = new StringBuilder(m.getName()).append('(');\n        Class<?>[] parameterTypes = m.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            ret.append(getDesc(parameterTypes[i]));\n        }\n        ret.append(')').append(getDesc(m.getReturnType()));\n        return ret.toString();\n    }\n\n    public static String[] getDescArray(final Method m) {\n        Class<?>[] parameterTypes = m.getParameterTypes();\n        String[] arr = new String[parameterTypes.length];\n\n        for (int i = 0; i < parameterTypes.length; i++) {\n            arr[i] = getDesc(parameterTypes[i]);\n        }\n        return arr;\n    }\n\n    /**\n     * get constructor desc.\n     * \"()V\", \"(Ljava/lang/String;I)V\"\n     *\n     * @param c constructor.\n     * @return desc\n     */\n    public static String getDesc(final Constructor<?> c) {\n        StringBuilder ret = new StringBuilder(\"(\");\n        Class<?>[] parameterTypes = c.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            ret.append(getDesc(parameterTypes[i]));\n        }\n        ret.append(')').append('V');\n        return ret.toString();\n    }\n\n    /**\n     * get method desc.\n     * \"(I)I\", \"()V\", \"(Ljava/lang/String;Z)V\"\n     *\n     * @param m method.\n     * @return desc.\n     */\n    public static String getDescWithoutMethodName(Method m) {\n        StringBuilder ret = new StringBuilder();\n        ret.append('(');\n        Class<?>[] parameterTypes = m.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            ret.append(getDesc(parameterTypes[i]));\n        }\n        ret.append(')').append(getDesc(m.getReturnType()));\n        return ret.toString();\n    }\n\n    /**\n     * get class desc.\n     * Object.class => \"Ljava/lang/Object;\"\n     * boolean[].class => \"[Z\"\n     *\n     * @param c class.\n     * @return desc.\n     * @throws NotFoundException\n     */\n    public static String getDesc(final CtClass c) throws NotFoundException {\n        StringBuilder ret = new StringBuilder();\n        if (c.isArray()) {\n            ret.append('[');\n            ret.append(getDesc(c.getComponentType()));\n        } else if (c.isPrimitive()) {\n            String t = c.getName();\n            if (\"void\".equals(t)) {\n                ret.append(JVM_VOID);\n            } else if (\"boolean\".equals(t)) {\n                ret.append(JVM_BOOLEAN);\n            } else if (\"byte\".equals(t)) {\n                ret.append(JVM_BYTE);\n            } else if (\"char\".equals(t)) {\n                ret.append(JVM_CHAR);\n            } else if (\"double\".equals(t)) {\n                ret.append(JVM_DOUBLE);\n            } else if (\"float\".equals(t)) {\n                ret.append(JVM_FLOAT);\n            } else if (\"int\".equals(t)) {\n                ret.append(JVM_INT);\n            } else if (\"long\".equals(t)) {\n                ret.append(JVM_LONG);\n            } else if (\"short\".equals(t)) {\n                ret.append(JVM_SHORT);\n            }\n        } else {\n            ret.append('L');\n            ret.append(c.getName().replace('.', '/'));\n            ret.append(';');\n        }\n        return ret.toString();\n    }\n\n    /**\n     * get method desc.\n     * \"do(I)I\", \"do()V\", \"do(Ljava/lang/String;Z)V\"\n     *\n     * @param m method.\n     * @return desc.\n     */\n    public static String getDesc(final CtMethod m) throws NotFoundException {\n        StringBuilder ret = new StringBuilder(m.getName()).append('(');\n        CtClass[] parameterTypes = m.getParameterTypes();\n        for (CtClass parameterType : parameterTypes) {\n            ret.append(getDesc(parameterType));\n        }\n        ret.append(')').append(getDesc(m.getReturnType()));\n        return ret.toString();\n    }\n\n    /**\n     * get constructor desc.\n     * \"()V\", \"(Ljava/lang/String;I)V\"\n     *\n     * @param c constructor.\n     * @return desc\n     */\n    public static String getDesc(final CtConstructor c) throws NotFoundException {\n        StringBuilder ret = new StringBuilder(\"(\");\n        CtClass[] parameterTypes = c.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            ret.append(getDesc(parameterTypes[i]));\n        }\n        ret.append(')').append('V');\n        return ret.toString();\n    }\n\n    /**\n     * get method desc.\n     * \"(I)I\", \"()V\", \"(Ljava/lang/String;Z)V\".\n     *\n     * @param m method.\n     * @return desc.\n     */\n    public static String getDescWithoutMethodName(final CtMethod m) throws NotFoundException {\n        StringBuilder ret = new StringBuilder();\n        ret.append('(');\n        CtClass[] parameterTypes = m.getParameterTypes();\n        for (int i = 0; i < parameterTypes.length; i++) {\n            ret.append(getDesc(parameterTypes[i]));\n        }\n        ret.append(')').append(getDesc(m.getReturnType()));\n        return ret.toString();\n    }\n\n    /**\n     * name to desc.\n     * java.util.Map[][] => \"[[Ljava/util/Map;\"\n     *\n     * @param name name.\n     * @return desc.\n     */\n    public static String name2desc(String name) {\n        StringBuilder sb = new StringBuilder();\n        int c = 0, index = name.indexOf('[');\n        if (index > 0) {\n            c = (name.length() - index) / 2;\n            name = name.substring(0, index);\n        }\n        while (c-- > 0) {\n            sb.append('[');\n        }\n        if (\"void\".equals(name)) {\n            sb.append(JVM_VOID);\n        } else if (\"boolean\".equals(name)) {\n            sb.append(JVM_BOOLEAN);\n        } else if (\"byte\".equals(name)) {\n            sb.append(JVM_BYTE);\n        } else if (\"char\".equals(name)) {\n            sb.append(JVM_CHAR);\n        } else if (\"double\".equals(name)) {\n            sb.append(JVM_DOUBLE);\n        } else if (\"float\".equals(name)) {\n            sb.append(JVM_FLOAT);\n        } else if (\"int\".equals(name)) {\n            sb.append(JVM_INT);\n        } else if (\"long\".equals(name)) {\n            sb.append(JVM_LONG);\n        } else if (\"short\".equals(name)) {\n            sb.append(JVM_SHORT);\n        } else {\n            sb.append('L').append(name.replace('.', '/')).append(';');\n        }\n        return sb.toString();\n    }\n\n    /**\n     * desc to name.\n     * \"[[I\" => \"int[][]\"\n     *\n     * @param desc desc.\n     * @return name.\n     */\n    public static String desc2name(String desc) {\n        StringBuilder sb = new StringBuilder();\n        int c = desc.lastIndexOf('[') + 1;\n        if (desc.length() == c + 1) {\n            switch (desc.charAt(c)) {\n                case JVM_VOID: {\n                    sb.append(\"void\");\n                    break;\n                }\n                case JVM_BOOLEAN: {\n                    sb.append(\"boolean\");\n                    break;\n                }\n                case JVM_BYTE: {\n                    sb.append(\"byte\");\n                    break;\n                }\n                case JVM_CHAR: {\n                    sb.append(\"char\");\n                    break;\n                }\n                case JVM_DOUBLE: {\n                    sb.append(\"double\");\n                    break;\n                }\n                case JVM_FLOAT: {\n                    sb.append(\"float\");\n                    break;\n                }\n                case JVM_INT: {\n                    sb.append(\"int\");\n                    break;\n                }\n                case JVM_LONG: {\n                    sb.append(\"long\");\n                    break;\n                }\n                case JVM_SHORT: {\n                    sb.append(\"short\");\n                    break;\n                }\n                default:\n                    throw new RuntimeException();\n            }\n        } else {\n            sb.append(desc.substring(c + 1, desc.length() - 1).replace('/', '.'));\n        }\n        while (c-- > 0) {\n            sb.append(\"[]\");\n        }\n        return sb.toString();\n    }\n\n    public static Class<?> forName(String name) {\n        try {\n            return name2class(name);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(\"Not found class \" + name + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    public static Class<?> forName(ClassLoader cl, String name) {\n        try {\n            return name2class(cl, name);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalStateException(\"Not found class \" + name + \", cause: \" + e.getMessage(), e);\n        }\n    }\n\n    /**\n     * name to class.\n     * \"boolean\" => boolean.class\n     * \"java.util.Map[][]\" => java.util.Map[][].class\n     *\n     * @param name name.\n     * @return Class instance.\n     */\n    public static Class<?> name2class(String name) throws ClassNotFoundException {\n        return name2class(ClassUtils.getClassLoader(), name);\n    }\n\n    /**\n     * name to class.\n     * \"boolean\" => boolean.class\n     * \"java.util.Map[][]\" => java.util.Map[][].class\n     *\n     * @param cl   ClassLoader instance.\n     * @param name name.\n     * @return Class instance.\n     */\n    private static Class<?> name2class(ClassLoader cl, String name) throws ClassNotFoundException {\n        int c = 0, index = name.indexOf('[');\n        if (index > 0) {\n            c = (name.length() - index) / 2;\n            name = name.substring(0, index);\n        }\n        if (c > 0) {\n            StringBuilder sb = new StringBuilder();\n            while (c-- > 0) {\n                sb.append('[');\n            }\n\n            if (\"void\".equals(name)) {\n                sb.append(JVM_VOID);\n            } else if (\"boolean\".equals(name)) {\n                sb.append(JVM_BOOLEAN);\n            } else if (\"byte\".equals(name)) {\n                sb.append(JVM_BYTE);\n            } else if (\"char\".equals(name)) {\n                sb.append(JVM_CHAR);\n            } else if (\"double\".equals(name)) {\n                sb.append(JVM_DOUBLE);\n            } else if (\"float\".equals(name)) {\n                sb.append(JVM_FLOAT);\n            } else if (\"int\".equals(name)) {\n                sb.append(JVM_INT);\n            } else if (\"long\".equals(name)) {\n                sb.append(JVM_LONG);\n            } else if (\"short\".equals(name)) {\n                sb.append(JVM_SHORT);\n            } else {\n                // \"java.lang.Object\" ==> \"Ljava.lang.Object;\"\n                sb.append('L').append(name).append(';');\n            }\n            name = sb.toString();\n        } else {\n            if (\"void\".equals(name)) {\n                return void.class;\n            }\n            if (\"boolean\".equals(name)) {\n                return boolean.class;\n            }\n            if (\"byte\".equals(name)) {\n                return byte.class;\n            }\n            if (\"char\".equals(name)) {\n                return char.class;\n            }\n            if (\"double\".equals(name)) {\n                return double.class;\n            }\n            if (\"float\".equals(name)) {\n                return float.class;\n            }\n            if (\"int\".equals(name)) {\n                return int.class;\n            }\n            if (\"long\".equals(name)) {\n                return long.class;\n            }\n            if (\"short\".equals(name)) {\n                return short.class;\n            }\n        }\n\n        if (cl == null) {\n            cl = ClassUtils.getClassLoader();\n        }\n        return Class.forName(name, true, cl);\n    }\n\n    /**\n     * desc to class.\n     * \"[Z\" => boolean[].class\n     * \"[[Ljava/util/Map;\" => java.util.Map[][].class\n     *\n     * @param desc desc.\n     * @return Class instance.\n     * @throws ClassNotFoundException\n     */\n    public static Class<?> desc2class(String desc) throws ClassNotFoundException {\n        return desc2class(ClassUtils.getClassLoader(), desc);\n    }\n\n    /**\n     * desc to class.\n     * \"[Z\" => boolean[].class\n     * \"[[Ljava/util/Map;\" => java.util.Map[][].class\n     *\n     * @param cl   ClassLoader instance.\n     * @param desc desc.\n     * @return Class instance.\n     * @throws ClassNotFoundException\n     */\n    private static Class<?> desc2class(ClassLoader cl, String desc) throws ClassNotFoundException {\n        switch (desc.charAt(0)) {\n            case JVM_VOID:\n                return void.class;\n            case JVM_BOOLEAN:\n                return boolean.class;\n            case JVM_BYTE:\n                return byte.class;\n            case JVM_CHAR:\n                return char.class;\n            case JVM_DOUBLE:\n                return double.class;\n            case JVM_FLOAT:\n                return float.class;\n            case JVM_INT:\n                return int.class;\n            case JVM_LONG:\n                return long.class;\n            case JVM_SHORT:\n                return short.class;\n            case 'L':\n                // \"Ljava/lang/Object;\" ==> \"java.lang.Object\"\n                desc = desc.substring(1, desc.length() - 1).replace('/', '.');\n                break;\n            case '[':\n                // \"[[Ljava/lang/Object;\" ==> \"[[Ljava.lang.Object;\"\n                desc = desc.replace('/', '.');\n                break;\n            default:\n                throw new ClassNotFoundException(\"Class not found: \" + desc);\n        }\n\n        if (cl == null) {\n            cl = ClassUtils.getClassLoader();\n        }\n        return Class.forName(desc, true, cl);\n    }\n\n    /**\n     * get class array instance.\n     *\n     * @param desc desc.\n     * @return Class class array.\n     * @throws ClassNotFoundException\n     */\n    public static Class<?>[] desc2classArray(String desc) throws ClassNotFoundException {\n        Class<?>[] ret = desc2classArray(ClassUtils.getClassLoader(), desc);\n        return ret;\n    }\n\n    /**\n     * get class array instance.\n     *\n     * @param cl   ClassLoader instance.\n     * @param desc desc.\n     * @return Class[] class array.\n     * @throws ClassNotFoundException\n     */\n    private static Class<?>[] desc2classArray(ClassLoader cl, String desc) throws ClassNotFoundException {\n        if (desc.length() == 0) {\n            return EMPTY_CLASS_ARRAY;\n        }\n\n        List<Class<?>> cs = new ArrayList<>();\n        Matcher m = DESC_PATTERN.matcher(desc);\n        while (m.find()) {\n            cs.add(desc2class(cl, m.group()));\n        }\n        return cs.toArray(EMPTY_CLASS_ARRAY);\n    }\n\n    /**\n     * Find method from method signature\n     *\n     * @param clazz      Target class to find method\n     * @param methodName Method signature, e.g.: method1(int, String). It is allowed to provide method name only, e.g.: method2\n     * @return target method\n     * @throws NoSuchMethodException\n     * @throws ClassNotFoundException\n     * @throws IllegalStateException  when multiple methods are found (overridden method when parameter info is not provided)\n     * @deprecated Recommend {@link MethodUtils#findMethod(Class, String, Class[])}\n     */\n    @Deprecated\n    public static Method findMethodByMethodSignature(Class<?> clazz, String methodName, String[] parameterTypes)\n            throws NoSuchMethodException, ClassNotFoundException {\n        Method method;\n        if (parameterTypes == null) {\n            List<Method> finded = new ArrayList<>();\n            for (Method m : clazz.getMethods()) {\n                if (m.getName().equals(methodName)) {\n                    finded.add(m);\n                }\n            }\n            if (finded.isEmpty()) {\n                throw new NoSuchMethodException(\"No such method \" + methodName + \" in class \" + clazz);\n            }\n            if (finded.size() > 1) {\n                String msg = String.format(\n                        \"Not unique method for method name(%s) in class(%s), find %d methods.\",\n                        methodName, clazz.getName(), finded.size());\n                throw new IllegalStateException(msg);\n            }\n            method = finded.get(0);\n        } else {\n            Class<?>[] types = new Class<?>[parameterTypes.length];\n            for (int i = 0; i < parameterTypes.length; i++) {\n                types[i] = ReflectUtils.name2class(parameterTypes[i]);\n            }\n            method = clazz.getMethod(methodName, types);\n        }\n        return method;\n    }\n\n    /**\n     * @param clazz      Target class to find method\n     * @param methodName Method signature, e.g.: method1(int, String). It is allowed to provide method name only, e.g.: method2\n     * @return target method\n     * @throws NoSuchMethodException\n     * @throws ClassNotFoundException\n     * @throws IllegalStateException  when multiple methods are found (overridden method when parameter info is not provided)\n     * @deprecated Recommend {@link MethodUtils#findMethod(Class, String, Class[])}\n     */\n    @Deprecated\n    public static Method findMethodByMethodName(Class<?> clazz, String methodName)\n            throws NoSuchMethodException, ClassNotFoundException {\n        return findMethodByMethodSignature(clazz, methodName, null);\n    }\n\n    public static Constructor<?> findConstructor(Class<?> clazz, Class<?> paramType) throws NoSuchMethodException {\n        Constructor<?> targetConstructor;\n        try {\n            targetConstructor = clazz.getConstructor(new Class<?>[] {paramType});\n        } catch (NoSuchMethodException e) {\n            targetConstructor = null;\n            Constructor<?>[] constructors = clazz.getConstructors();\n            for (Constructor<?> constructor : constructors) {\n                if (Modifier.isPublic(constructor.getModifiers())\n                        && constructor.getParameterTypes().length == 1\n                        && constructor.getParameterTypes()[0].isAssignableFrom(paramType)) {\n                    targetConstructor = constructor;\n                    break;\n                }\n            }\n            if (targetConstructor == null) {\n                throw e;\n            }\n        }\n        return targetConstructor;\n    }\n\n    /**\n     * Check if one object is the implementation for a given interface.\n     * <p>\n     * This method will not trigger classloading for the given interface, therefore it will not lead to error when\n     * the given interface is not visible by the classloader\n     *\n     * @param obj                Object to examine\n     * @param interfaceClazzName The given interface\n     * @return true if the object implements the given interface, otherwise return false\n     */\n    public static boolean isInstance(Object obj, String interfaceClazzName) {\n        for (Class<?> clazz = obj.getClass();\n                clazz != null && !clazz.equals(Object.class);\n                clazz = clazz.getSuperclass()) {\n            Class<?>[] interfaces = clazz.getInterfaces();\n            for (Class<?> itf : interfaces) {\n                if (itf.getName().equals(interfaceClazzName)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static Object getEmptyObject(Class<?> returnType) {\n        return getEmptyObject(returnType, new HashMap<>(), 0);\n    }\n\n    private static Object getEmptyObject(Class<?> returnType, Map<Class<?>, Object> emptyInstances, int level) {\n        if (level > 2) {\n            return null;\n        }\n        if (returnType == null) {\n            return null;\n        }\n        if (returnType == boolean.class || returnType == Boolean.class) {\n            return false;\n        }\n        if (returnType == char.class || returnType == Character.class) {\n            return '\\0';\n        }\n        if (returnType == byte.class || returnType == Byte.class) {\n            return (byte) 0;\n        }\n        if (returnType == short.class || returnType == Short.class) {\n            return (short) 0;\n        }\n        if (returnType == int.class || returnType == Integer.class) {\n            return 0;\n        }\n        if (returnType == long.class || returnType == Long.class) {\n            return 0L;\n        }\n        if (returnType == float.class || returnType == Float.class) {\n            return 0F;\n        }\n        if (returnType == double.class || returnType == Double.class) {\n            return 0D;\n        }\n        if (returnType.isArray()) {\n            return Array.newInstance(returnType.getComponentType(), 0);\n        }\n        if (returnType.isAssignableFrom(ArrayList.class)) {\n            return new ArrayList<>(0);\n        }\n        if (returnType.isAssignableFrom(HashSet.class)) {\n            return new HashSet<>(0);\n        }\n        if (returnType.isAssignableFrom(HashMap.class)) {\n            return new HashMap<>(0);\n        }\n        if (String.class.equals(returnType)) {\n            return \"\";\n        }\n        if (returnType.isInterface()) {\n            return null;\n        }\n\n        try {\n            Object value = emptyInstances.get(returnType);\n            if (value == null) {\n                value = returnType.getDeclaredConstructor().newInstance();\n                emptyInstances.put(returnType, value);\n            }\n            Class<?> cls = value.getClass();\n            while (cls != null && cls != Object.class) {\n                Field[] fields = cls.getDeclaredFields();\n                for (Field field : fields) {\n                    if (field.isSynthetic()) {\n                        continue;\n                    }\n                    Object property = getEmptyObject(field.getType(), emptyInstances, level + 1);\n                    if (property != null) {\n                        try {\n                            if (!field.isAccessible()) {\n                                field.setAccessible(true);\n                            }\n                            field.set(value, property);\n                        } catch (Throwable ignored) {\n                        }\n                    }\n                }\n                cls = cls.getSuperclass();\n            }\n            return value;\n        } catch (Throwable e) {\n            return null;\n        }\n    }\n\n    public static Object defaultReturn(Method m) {\n        if (m.getReturnType().isPrimitive()) {\n            return primitiveDefaults.get(m.getReturnType());\n        } else {\n            return null;\n        }\n    }\n\n    public static Object defaultReturn(Class<?> classType) {\n        if (classType != null && classType.isPrimitive()) {\n            return primitiveDefaults.get(classType);\n        } else {\n            return null;\n        }\n    }\n\n    public static boolean isBeanPropertyReadMethod(Method method) {\n        return method != null\n                && Modifier.isPublic(method.getModifiers())\n                && !Modifier.isStatic(method.getModifiers())\n                && method.getReturnType() != void.class\n                && method.getDeclaringClass() != Object.class\n                && method.getParameterTypes().length == 0\n                && ((method.getName().startsWith(\"get\") && method.getName().length() > 3)\n                        || (method.getName().startsWith(\"is\")\n                                && method.getName().length() > 2));\n    }\n\n    public static String getPropertyNameFromBeanReadMethod(Method method) {\n        if (isBeanPropertyReadMethod(method)) {\n            if (method.getName().startsWith(\"get\")) {\n                return method.getName().substring(3, 4).toLowerCase()\n                        + method.getName().substring(4);\n            }\n            if (method.getName().startsWith(\"is\")) {\n                return method.getName().substring(2, 3).toLowerCase()\n                        + method.getName().substring(3);\n            }\n        }\n        return null;\n    }\n\n    public static boolean isBeanPropertyWriteMethod(Method method) {\n        return method != null\n                && Modifier.isPublic(method.getModifiers())\n                && !Modifier.isStatic(method.getModifiers())\n                && method.getDeclaringClass() != Object.class\n                && method.getParameterTypes().length == 1\n                && method.getName().startsWith(\"set\")\n                && method.getName().length() > 3;\n    }\n\n    public static String getPropertyNameFromBeanWriteMethod(Method method) {\n        if (isBeanPropertyWriteMethod(method)) {\n            return method.getName().substring(3, 4).toLowerCase()\n                    + method.getName().substring(4);\n        }\n        return null;\n    }\n\n    public static boolean isPublicInstanceField(Field field) {\n        return Modifier.isPublic(field.getModifiers())\n                && !Modifier.isStatic(field.getModifiers())\n                && !Modifier.isFinal(field.getModifiers())\n                && !field.isSynthetic();\n    }\n\n    public static Map<String, Field> getBeanPropertyFields(Class cl) {\n        Map<String, Field> properties = new HashMap<>();\n        for (; cl != null; cl = cl.getSuperclass()) {\n            Field[] fields = cl.getDeclaredFields();\n            for (Field field : fields) {\n                if (Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {\n                    continue;\n                }\n\n                field.setAccessible(true);\n\n                properties.put(field.getName(), field);\n            }\n        }\n\n        return properties;\n    }\n\n    public static Map<String, Method> getBeanPropertyReadMethods(Class cl) {\n        Map<String, Method> properties = new HashMap<>();\n        for (; cl != null; cl = cl.getSuperclass()) {\n            Method[] methods = cl.getDeclaredMethods();\n            for (Method method : methods) {\n                if (isBeanPropertyReadMethod(method)) {\n                    method.setAccessible(true);\n                    String property = getPropertyNameFromBeanReadMethod(method);\n                    properties.put(property, method);\n                }\n            }\n        }\n\n        return properties;\n    }\n\n    public static Type[] getReturnTypes(Method method) {\n        Class<?> returnType = method.getReturnType();\n        Type genericReturnType = method.getGenericReturnType();\n        if (Future.class.isAssignableFrom(returnType)) {\n            if (genericReturnType instanceof ParameterizedType) {\n                Type actualArgType = ((ParameterizedType) genericReturnType).getActualTypeArguments()[0];\n                if (actualArgType instanceof ParameterizedType) {\n                    returnType = (Class<?>) ((ParameterizedType) actualArgType).getRawType();\n                    genericReturnType = actualArgType;\n                } else if (actualArgType instanceof TypeVariable) {\n                    returnType = (Class<?>) ((TypeVariable<?>) actualArgType).getBounds()[0];\n                    genericReturnType = actualArgType;\n                } else {\n                    returnType = (Class<?>) actualArgType;\n                    genericReturnType = returnType;\n                }\n            } else {\n                returnType = null;\n                genericReturnType = null;\n            }\n        }\n        return new Type[] {returnType, genericReturnType};\n    }\n\n    /**\n     * Find the {@link Set} of {@link ParameterizedType}\n     *\n     * @param sourceClass the source {@link Class class}\n     * @return non-null read-only {@link Set}\n     * @since 2.7.5\n     */\n    public static Set<ParameterizedType> findParameterizedTypes(Class<?> sourceClass) {\n        // Add Generic Interfaces\n        List<Type> genericTypes = new LinkedList<>(asList(sourceClass.getGenericInterfaces()));\n        // Add Generic Super Class\n        genericTypes.add(sourceClass.getGenericSuperclass());\n\n        Set<ParameterizedType> parameterizedTypes = genericTypes.stream()\n                .filter(type -> type instanceof ParameterizedType) // filter ParameterizedType\n                .map(ParameterizedType.class::cast) // cast to ParameterizedType\n                .collect(Collectors.toSet());\n\n        if (parameterizedTypes.isEmpty()) { // If not found, try to search super types recursively\n            genericTypes.stream()\n                    .filter(type -> type instanceof Class)\n                    .map(Class.class::cast)\n                    .forEach(superClass -> parameterizedTypes.addAll(findParameterizedTypes(superClass)));\n        }\n\n        return unmodifiableSet(parameterizedTypes); // build as a Set\n    }\n\n    /**\n     * Find the hierarchical types from the source {@link Class class} by specified {@link Class type}.\n     *\n     * @param sourceClass the source {@link Class class}\n     * @param matchType   the type to match\n     * @param <T>         the type to match\n     * @return non-null read-only {@link Set}\n     * @since 2.7.5\n     */\n    public static <T> Set<Class<T>> findHierarchicalTypes(Class<?> sourceClass, Class<T> matchType) {\n        if (sourceClass == null) {\n            return Collections.emptySet();\n        }\n\n        Set<Class<T>> hierarchicalTypes = new LinkedHashSet<>();\n\n        if (matchType.isAssignableFrom(sourceClass)) {\n            hierarchicalTypes.add((Class<T>) sourceClass);\n        }\n\n        // Find all super classes\n        hierarchicalTypes.addAll(findHierarchicalTypes(sourceClass.getSuperclass(), matchType));\n\n        return unmodifiableSet(hierarchicalTypes);\n    }\n\n    /**\n     * Get the value from the specified bean and its getter method.\n     *\n     * @param bean       the bean instance\n     * @param methodName the name of getter\n     * @param <T>        the type of property value\n     * @return\n     * @since 2.7.5\n     */\n    public static <T> T getProperty(Object bean, String methodName) {\n        Class<?> beanClass = bean.getClass();\n        BeanInfo beanInfo = null;\n        T propertyValue = null;\n\n        try {\n            beanInfo = Introspector.getBeanInfo(beanClass);\n            propertyValue = (T) Stream.of(beanInfo.getMethodDescriptors())\n                    .filter(methodDescriptor -> methodName.equals(methodDescriptor.getName()))\n                    .findFirst()\n                    .map(method -> {\n                        try {\n                            return method.getMethod().invoke(bean);\n                        } catch (Exception e) {\n                            // ignore\n                        }\n                        return null;\n                    })\n                    .get();\n        } catch (Exception e) {\n\n        }\n        return propertyValue;\n    }\n\n    /**\n     * Check target bean class whether has specify method\n     * @param beanClass\n     * @param methodName\n     * @return\n     */\n    public static boolean hasMethod(Class<?> beanClass, String methodName) {\n        try {\n            BeanInfo beanInfo = Introspector.getBeanInfo(beanClass);\n            Optional<MethodDescriptor> descriptor = Stream.of(beanInfo.getMethodDescriptors())\n                    .filter(methodDescriptor -> methodName.equals(methodDescriptor.getName()))\n                    .findFirst();\n            return descriptor.isPresent();\n        } catch (Exception e) {\n\n        }\n        return false;\n    }\n\n    /**\n     * Resolve the types of the specified values\n     *\n     * @param values the values\n     * @return If can't be resolved, return {@link ReflectUtils#EMPTY_CLASS_ARRAY empty class array}\n     * @since 2.7.6\n     */\n    public static Class[] resolveTypes(Object... values) {\n\n        if (isEmpty(values)) {\n            return EMPTY_CLASS_ARRAY;\n        }\n\n        int size = values.length;\n\n        Class[] types = new Class[size];\n\n        for (int i = 0; i < size; i++) {\n            Object value = values[i];\n            types[i] = value == null ? null : value.getClass();\n        }\n\n        return types;\n    }\n\n    public static boolean checkZeroArgConstructor(Class clazz) {\n        try {\n            clazz.getDeclaredConstructor();\n            return true;\n        } catch (NoSuchMethodException e) {\n            return false;\n        }\n    }\n\n    public static boolean isJdk(Class clazz) {\n        return clazz.getName().startsWith(\"java.\") || clazz.getName().startsWith(\"javax.\");\n    }\n\n    /**\n     * Copy from org.springframework.util.ReflectionUtils.\n     * Make the given method accessible, explicitly setting it accessible if\n     * necessary. The {@code setAccessible(true)} method is only called\n     * when actually necessary, to avoid unnecessary conflicts with a JVM\n     * SecurityManager (if active).\n     * @param method the method to make accessible\n     * @see java.lang.reflect.Method#setAccessible\n     */\n    @SuppressWarnings(\"deprecation\") // on JDK 9\n    public static void makeAccessible(Method method) {\n        if ((!Modifier.isPublic(method.getModifiers())\n                        || !Modifier.isPublic(method.getDeclaringClass().getModifiers()))\n                && !method.isAccessible()) {\n            method.setAccessible(true);\n        }\n    }\n\n    /**\n     * Get all field names of target type\n     * @param type\n     * @return\n     */\n    public static Set<String> getAllFieldNames(Class<?> type) {\n\n        Set<String> fieldNames = new HashSet<>();\n        for (Field field : type.getDeclaredFields()) {\n            fieldNames.add(field.getName());\n        }\n\n        Set<Class<?>> allSuperClasses = ClassUtils.getAllSuperClasses(type);\n        for (Class<?> aClass : allSuperClasses) {\n            for (Field field : aClass.getDeclaredFields()) {\n                fieldNames.add(field.getName());\n            }\n        }\n        return fieldNames;\n    }\n\n    public static <T> T getFieldValue(Object obj, String fieldName) throws RuntimeException {\n        if (obj == null) {\n            throw new IllegalArgumentException(\"object is null\");\n        }\n        try {\n            Field field = obj.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n            return (T) field.get(obj);\n        } catch (Exception e) {\n            throw new RuntimeException(e.getMessage(), e);\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 138,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/ReflectUtils.java",
        "line": 791,
        "sink": "java.lang.Class.forName",
        "source": "-",
        "sourceLine": 791,
        "qualifier": "Call to java.lang.Class.forName with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.Class.forName with untrusted data from [msg : String](2).\nCall to java.lang.Class.forName with untrusted data from [msg : Http2StreamFrame](3).\nCall to java.lang.Class.forName with untrusted data from [msg : Object](4).",
        "line_number": 791,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 139
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 139
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 139
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 139
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java#L362",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport org.apache.dubbo.common.config.ConfigurationUtils;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.IdentityHashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Properties;\nimport java.util.TreeMap;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_REFLECTIVE_OPERATION_FAILED;\nimport static org.apache.dubbo.common.utils.ClassUtils.isAssignableFrom;\n\n/**\n * PojoUtils. Travel object deeply, and convert complex type to simple type.\n * <p/>\n * Simple type below will be remained:\n * <ul>\n * <li> Primitive Type, also include <b>String</b>, <b>Number</b>(Integer, Long), <b>Date</b>\n * <li> Array of Primitive Type\n * <li> Collection, eg: List, Map, Set etc.\n * </ul>\n * <p/>\n * Other type will be covert to a map which contains the attributes and value pair of object.\n * <p>\n * TODO: exact PojoUtils to scope bean\n */\npublic class PojoUtils {\n\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(PojoUtils.class);\n    private static final ConcurrentMap<String, Method> NAME_METHODS_CACHE = new ConcurrentHashMap<>();\n    private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Field>> CLASS_FIELD_CACHE =\n            new ConcurrentHashMap<>();\n\n    private static final ConcurrentMap<String, Object> CLASS_NOT_FOUND_CACHE = new ConcurrentHashMap<>();\n\n    private static final Object NOT_FOUND_VALUE = new Object();\n    private static final boolean GENERIC_WITH_CLZ = Boolean.parseBoolean(ConfigurationUtils.getProperty(\n            ApplicationModel.defaultModel(), CommonConstants.GENERIC_WITH_CLZ_KEY, \"true\"));\n\n    private static final List<Class<?>> CLASS_CAN_BE_STRING = Arrays.asList(\n            Byte.class,\n            Short.class,\n            Integer.class,\n            Long.class,\n            Float.class,\n            Double.class,\n            Boolean.class,\n            Character.class);\n\n    public static Object[] generalize(Object[] objs) {\n        Object[] dests = new Object[objs.length];\n        for (int i = 0; i < objs.length; i++) {\n            dests[i] = generalize(objs[i]);\n        }\n        return dests;\n    }\n\n    public static Object[] realize(Object[] objs, Class<?>[] types) {\n        if (objs.length != types.length) {\n            throw new IllegalArgumentException(\"args.length != types.length\");\n        }\n\n        Object[] dests = new Object[objs.length];\n        for (int i = 0; i < objs.length; i++) {\n            dests[i] = realize(objs[i], types[i]);\n        }\n\n        return dests;\n    }\n\n    public static Object[] realize(Object[] objs, Class<?>[] types, Type[] gtypes) {\n        if (objs.length != types.length || objs.length != gtypes.length) {\n            throw new IllegalArgumentException(\"args.length != types.length\");\n        }\n        Object[] dests = new Object[objs.length];\n        for (int i = 0; i < objs.length; i++) {\n            dests[i] = realize(objs[i], types[i], gtypes[i]);\n        }\n        return dests;\n    }\n\n    public static Object generalize(Object pojo) {\n        return generalize(pojo, new IdentityHashMap<>());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Object generalize(Object pojo, Map<Object, Object> history) {\n        if (pojo == null) {\n            return null;\n        }\n\n        if (pojo instanceof Enum<?>) {\n            return ((Enum<?>) pojo).name();\n        }\n        if (pojo.getClass().isArray()\n                && Enum.class.isAssignableFrom(pojo.getClass().getComponentType())) {\n            int len = Array.getLength(pojo);\n            String[] values = new String[len];\n            for (int i = 0; i < len; i++) {\n                values[i] = ((Enum<?>) Array.get(pojo, i)).name();\n            }\n            return values;\n        }\n\n        if (ReflectUtils.isPrimitives(pojo.getClass())) {\n            return pojo;\n        }\n\n        if (pojo instanceof LocalDate || pojo instanceof LocalDateTime || pojo instanceof LocalTime) {\n            return pojo.toString();\n        }\n\n        if (pojo instanceof Class) {\n            return ((Class) pojo).getName();\n        }\n\n        Object o = history.get(pojo);\n        if (o != null) {\n            return o;\n        }\n        history.put(pojo, pojo);\n\n        if (pojo.getClass().isArray()) {\n            int len = Array.getLength(pojo);\n            Object[] dest = new Object[len];\n            history.put(pojo, dest);\n            for (int i = 0; i < len; i++) {\n                Object obj = Array.get(pojo, i);\n                dest[i] = generalize(obj, history);\n            }\n            return dest;\n        }\n        if (pojo instanceof Collection<?>) {\n            Collection<Object> src = (Collection<Object>) pojo;\n            int len = src.size();\n            Collection<Object> dest = (pojo instanceof List<?>) ? new ArrayList<>(len) : new HashSet<>(len);\n            history.put(pojo, dest);\n            for (Object obj : src) {\n                dest.add(generalize(obj, history));\n            }\n            return dest;\n        }\n        if (pojo instanceof Map<?, ?>) {\n            Map<Object, Object> src = (Map<Object, Object>) pojo;\n            Map<Object, Object> dest = createMap(src);\n            history.put(pojo, dest);\n            for (Map.Entry<Object, Object> obj : src.entrySet()) {\n                dest.put(generalize(obj.getKey(), history), generalize(obj.getValue(), history));\n            }\n            return dest;\n        }\n        Map<String, Object> map = new HashMap<>();\n        history.put(pojo, map);\n        if (GENERIC_WITH_CLZ) {\n            map.put(\"class\", pojo.getClass().getName());\n        }\n        for (Method method : pojo.getClass().getMethods()) {\n            if (ReflectUtils.isBeanPropertyReadMethod(method)) {\n                ReflectUtils.makeAccessible(method);\n                try {\n                    map.put(\n                            ReflectUtils.getPropertyNameFromBeanReadMethod(method),\n                            generalize(method.invoke(pojo), history));\n                } catch (Exception e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n        }\n        // public field\n        for (Field field : pojo.getClass().getFields()) {\n            if (ReflectUtils.isPublicInstanceField(field)) {\n                try {\n                    Object fieldValue = field.get(pojo);\n                    if (history.containsKey(pojo)) {\n                        Object pojoGeneralizedValue = history.get(pojo);\n                        if (pojoGeneralizedValue instanceof Map\n                                && ((Map) pojoGeneralizedValue).containsKey(field.getName())) {\n                            continue;\n                        }\n                    }\n                    if (fieldValue != null) {\n                        map.put(field.getName(), generalize(fieldValue, history));\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n        }\n        return map;\n    }\n\n    public static Object realize(Object pojo, Class<?> type) {\n        return realize0(pojo, type, null, new IdentityHashMap<>());\n    }\n\n    public static Object realize(Object pojo, Class<?> type, Type genericType) {\n        return realize0(pojo, type, genericType, new IdentityHashMap<>());\n    }\n\n    private static class PojoInvocationHandler implements InvocationHandler {\n\n        private final Map<Object, Object> map;\n\n        public PojoInvocationHandler(Map<Object, Object> map) {\n            this.map = map;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            if (method.getDeclaringClass() == Object.class) {\n                return method.invoke(map, args);\n            }\n            String methodName = method.getName();\n            Object value = null;\n            if (methodName.length() > 3 && methodName.startsWith(\"get\")) {\n                value = map.get(methodName.substring(3, 4).toLowerCase() + methodName.substring(4));\n            } else if (methodName.length() > 2 && methodName.startsWith(\"is\")) {\n                value = map.get(methodName.substring(2, 3).toLowerCase() + methodName.substring(3));\n            } else {\n                value = map.get(methodName.substring(0, 1).toLowerCase() + methodName.substring(1));\n            }\n            if (value instanceof Map<?, ?> && !Map.class.isAssignableFrom(method.getReturnType())) {\n                value = realize0(value, method.getReturnType(), null, new IdentityHashMap<>());\n            }\n            return value;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Collection<Object> createCollection(Class<?> type, int len) {\n        if (type.isAssignableFrom(ArrayList.class)) {\n            return new ArrayList<>(len);\n        }\n        if (type.isAssignableFrom(HashSet.class)) {\n            return new HashSet<>(len);\n        }\n        if (!type.isInterface() && !Modifier.isAbstract(type.getModifiers())) {\n            try {\n                return (Collection<Object>) type.getDeclaredConstructor().newInstance();\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n        return new ArrayList<>();\n    }\n\n    private static Map createMap(Map src) {\n        Class<? extends Map> cl = src.getClass();\n        Map result = null;\n        if (HashMap.class == cl) {\n            result = new HashMap();\n        } else if (Hashtable.class == cl) {\n            result = new Hashtable();\n        } else if (IdentityHashMap.class == cl) {\n            result = new IdentityHashMap();\n        } else if (LinkedHashMap.class == cl) {\n            result = new LinkedHashMap();\n        } else if (Properties.class == cl) {\n            result = new Properties();\n        } else if (TreeMap.class == cl) {\n            result = new TreeMap();\n        } else if (WeakHashMap.class == cl) {\n            return new WeakHashMap();\n        } else if (ConcurrentHashMap.class == cl) {\n            result = new ConcurrentHashMap();\n        } else if (ConcurrentSkipListMap.class == cl) {\n            result = new ConcurrentSkipListMap();\n        } else {\n            try {\n                result = cl.getDeclaredConstructor().newInstance();\n            } catch (Exception e) {\n                /* ignore */\n            }\n\n            if (result == null) {\n                try {\n                    Constructor<?> constructor = cl.getConstructor(Map.class);\n                    result = (Map) constructor.newInstance(Collections.EMPTY_MAP);\n                } catch (Exception e) {\n                    /* ignore */\n                }\n            }\n        }\n\n        if (result == null) {\n            result = new HashMap<>();\n        }\n\n        return result;\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private static Object realize0(Object pojo, Class<?> type, Type genericType, final Map<Object, Object> history) {\n        return realize1(pojo, type, genericType, new HashMap<>(8), history);\n    }\n\n    private static Object realize1(\n            Object pojo,\n            Class<?> type,\n            Type genericType,\n            final Map<String, Type> mapParent,\n            final Map<Object, Object> history) {\n        if (pojo == null) {\n            return null;\n        }\n\n        if (type != null && type.isEnum() && pojo.getClass() == String.class) {\n            return Enum.valueOf((Class<Enum>) type, (String) pojo);\n        }\n\n        if (ReflectUtils.isPrimitives(pojo.getClass())\n                && !(type != null\n                        && type.isArray()\n                        && type.getComponentType().isEnum()\n                        && pojo.getClass() == String[].class)) {\n            return CompatibleTypeUtils.compatibleTypeConvert(pojo, type);\n        }\n\n        Object o = history.get(pojo);\n\n        if (o != null) {\n            return o;\n        }\n\n        history.put(pojo, pojo);\n\n        Map<String, Type> mapGeneric = new HashMap<>(8);\n        mapGeneric.putAll(mapParent);\n        TypeVariable<? extends Class<?>>[] typeParameters = type.getTypeParameters();\n        if (genericType instanceof ParameterizedType && typeParameters.length > 0) {\n            ParameterizedType parameterizedType = (ParameterizedType) genericType;\n            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n            for (int i = 0; i < typeParameters.length; i++) {\n                if (!(actualTypeArguments[i] instanceof TypeVariable)) {\n                    mapGeneric.put(typeParameters[i].getTypeName(), actualTypeArguments[i]);\n                }\n            }\n        }\n\n        if (pojo.getClass().isArray()) {\n            if (Collection.class.isAssignableFrom(type)) {\n                Class<?> ctype = pojo.getClass().getComponentType();\n                int len = Array.getLength(pojo);\n                Collection dest = createCollection(type, len);\n                history.put(pojo, dest);\n                for (int i = 0; i < len; i++) {\n                    Object obj = Array.get(pojo, i);\n                    Object value = realize1(obj, ctype, null, mapGeneric, history);\n                    dest.add(value);\n                }\n                return dest;\n            } else {\n                Class<?> ctype = (type != null && type.isArray()\n                        ? type.getComponentType()\n                        : pojo.getClass().getComponentType());\n                int len = Array.getLength(pojo);\n                Object dest = Array.newInstance(ctype, len);\n                history.put(pojo, dest);\n                for (int i = 0; i < len; i++) {\n                    Object obj = Array.get(pojo, i);\n                    Object value = realize1(obj, ctype, null, mapGeneric, history);\n                    Array.set(dest, i, value);\n                }\n                return dest;\n            }\n        }\n\n        if (pojo instanceof Collection<?>) {\n            if (type.isArray()) {\n                Class<?> ctype = type.getComponentType();\n                Collection<Object> src = (Collection<Object>) pojo;\n                int len = src.size();\n                Object dest = Array.newInstance(ctype, len);\n                history.put(pojo, dest);\n                int i = 0;\n                for (Object obj : src) {\n                    Object value = realize1(obj, ctype, null, mapGeneric, history);\n                    Array.set(dest, i, value);\n                    i++;\n                }\n                return dest;\n            } else {\n                Collection<Object> src = (Collection<Object>) pojo;\n                int len = src.size();\n                Collection<Object> dest = createCollection(type, len);\n                history.put(pojo, dest);\n                for (Object obj : src) {\n                    Type keyType = getGenericClassByIndex(genericType, 0);\n                    Class<?> keyClazz = obj == null ? null : obj.getClass();\n                    if (keyType instanceof Class) {\n                        keyClazz = (Class<?>) keyType;\n                    }\n                    Object value = realize1(obj, keyClazz, keyType, mapGeneric, history);\n                    dest.add(value);\n                }\n                return dest;\n            }\n        }\n\n        if (pojo instanceof Map<?, ?> && type != null) {\n            Object className = ((Map<Object, Object>) pojo).get(\"class\");\n            if (className instanceof String) {\n                if (!CLASS_NOT_FOUND_CACHE.containsKey(className)) {\n                    try {\n                        type = DefaultSerializeClassChecker.getInstance()\n                                .loadClass(ClassUtils.getClassLoader(), (String) className);\n                    } catch (ClassNotFoundException e) {\n                        CLASS_NOT_FOUND_CACHE.put((String) className, NOT_FOUND_VALUE);\n                    }\n                }\n            }\n\n            // special logic for enum\n            if (type.isEnum()) {\n                Object name = ((Map<Object, Object>) pojo).get(\"name\");\n                if (name != null) {\n                    if (!(name instanceof String)) {\n                        throw new IllegalArgumentException(\"`name` filed should be string!\");\n                    } else {\n                        return Enum.valueOf((Class<Enum>) type, (String) name);\n                    }\n                }\n            }\n            Map<Object, Object> map;\n            // when return type is not the subclass of return type from the signature and not an interface\n            if (!type.isInterface() && !type.isAssignableFrom(pojo.getClass())) {\n                try {\n                    map = (Map<Object, Object>) type.getDeclaredConstructor().newInstance();\n                    Map<Object, Object> mapPojo = (Map<Object, Object>) pojo;\n                    map.putAll(mapPojo);\n                    if (GENERIC_WITH_CLZ) {\n                        map.remove(\"class\");\n                    }\n                } catch (Exception e) {\n                    // ignore error\n                    map = (Map<Object, Object>) pojo;\n                }\n            } else {\n                map = (Map<Object, Object>) pojo;\n            }\n\n            if (Map.class.isAssignableFrom(type) || type == Object.class) {\n                final Map<Object, Object> result;\n                // fix issue#5939\n                Type mapKeyType = getKeyTypeForMap(map.getClass());\n                Type typeKeyType = getGenericClassByIndex(genericType, 0);\n                boolean typeMismatch = mapKeyType instanceof Class\n                        && typeKeyType instanceof Class\n                        && !typeKeyType.getTypeName().equals(mapKeyType.getTypeName());\n                if (typeMismatch) {\n                    result = createMap(new HashMap(0));\n                } else {\n                    result = createMap(map);\n                }\n\n                history.put(pojo, result);\n                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                    Type keyType = getGenericClassByIndex(genericType, 0);\n                    Type valueType = getGenericClassByIndex(genericType, 1);\n                    Class<?> keyClazz;\n                    if (keyType instanceof Class) {\n                        keyClazz = (Class<?>) keyType;\n                    } else if (keyType instanceof ParameterizedType) {\n                        keyClazz = (Class<?>) ((ParameterizedType) keyType).getRawType();\n                    } else {\n                        keyClazz =\n                                entry.getKey() == null ? null : entry.getKey().getClass();\n                    }\n                    Class<?> valueClazz;\n                    if (valueType instanceof Class) {\n                        valueClazz = (Class<?>) valueType;\n                    } else if (valueType instanceof ParameterizedType) {\n                        valueClazz = (Class<?>) ((ParameterizedType) valueType).getRawType();\n                    } else {\n                        valueClazz = entry.getValue() == null\n                                ? null\n                                : entry.getValue().getClass();\n                    }\n\n                    Object key = keyClazz == null\n                            ? entry.getKey()\n                            : realize1(entry.getKey(), keyClazz, keyType, mapGeneric, history);\n                    Object value = valueClazz == null\n                            ? entry.getValue()\n                            : realize1(entry.getValue(), valueClazz, valueType, mapGeneric, history);\n                    result.put(key, value);\n                }\n                return result;\n            } else if (type.isInterface()) {\n                Object dest = Proxy.newProxyInstance(\n                        Thread.currentThread().getContextClassLoader(),\n                        new Class<?>[] {type},\n                        new PojoInvocationHandler(map));\n                history.put(pojo, dest);\n                return dest;\n            } else {\n                Object dest;\n                if (Throwable.class.isAssignableFrom(type)) {\n                    Object message = map.get(\"message\");\n                    if (message instanceof String) {\n                        dest = newThrowableInstance(type, (String) message);\n                    } else {\n                        dest = newInstance(type);\n                    }\n                } else {\n                    dest = newInstance(type);\n                }\n\n                history.put(pojo, dest);\n\n                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                    Object key = entry.getKey();\n                    if (key instanceof String) {\n                        String name = (String) key;\n                        Object value = entry.getValue();\n                        if (value != null) {\n                            Method method = getSetterMethod(dest.getClass(), name, value.getClass());\n                            Field field = getAndCacheField(dest.getClass(), name);\n                            if (method != null) {\n                                if (!method.isAccessible()) {\n                                    method.setAccessible(true);\n                                }\n                                Type containType = Optional.ofNullable(field)\n                                        .map(Field::getGenericType)\n                                        .map(Type::getTypeName)\n                                        .map(mapGeneric::get)\n                                        .orElse(null);\n                                if (containType != null) {\n                                    // is generic\n                                    if (containType instanceof ParameterizedType) {\n                                        value = realize1(\n                                                value,\n                                                (Class<?>) ((ParameterizedType) containType).getRawType(),\n                                                containType,\n                                                mapGeneric,\n                                                history);\n                                    } else if (containType instanceof Class) {\n                                        value = realize1(\n                                                value, (Class<?>) containType, containType, mapGeneric, history);\n                                    } else {\n                                        Type ptype = method.getGenericParameterTypes()[0];\n                                        value = realize1(\n                                                value, method.getParameterTypes()[0], ptype, mapGeneric, history);\n                                    }\n                                } else {\n                                    Type ptype = method.getGenericParameterTypes()[0];\n                                    value = realize1(value, method.getParameterTypes()[0], ptype, mapGeneric, history);\n                                }\n                                try {\n                                    method.invoke(dest, value);\n                                } catch (Exception e) {\n                                    String exceptionDescription = \"Failed to set pojo \"\n                                            + dest.getClass().getSimpleName() + \" property \" + name + \" value \"\n                                            + value.getClass() + \", cause: \" + e.getMessage();\n                                    logger.error(COMMON_REFLECTIVE_OPERATION_FAILED, \"\", \"\", exceptionDescription, e);\n                                    throw new RuntimeException(exceptionDescription, e);\n                                }\n                            } else if (field != null) {\n                                value = realize1(value, field.getType(), field.getGenericType(), mapGeneric, history);\n                                try {\n                                    field.set(dest, value);\n                                } catch (IllegalAccessException e) {\n                                    throw new RuntimeException(\n                                            \"Failed to set field \" + name + \" of pojo \"\n                                                    + dest.getClass().getName() + \" : \" + e.getMessage(),\n                                            e);\n                                }\n                            }\n                        }\n                    }\n                }\n                return dest;\n            }\n        }\n        return pojo;\n    }\n\n    /**\n     * Get key type for {@link Map} directly implemented by {@code clazz}.\n     * If {@code clazz} does not implement {@link Map} directly, return {@code null}.\n     *\n     * @param clazz {@link Class}\n     * @return Return String.class for {@link com.alibaba.fastjson.JSONObject}\n     */\n    private static Type getKeyTypeForMap(Class<?> clazz) {\n        Type[] interfaces = clazz.getGenericInterfaces();\n        if (!ArrayUtils.isEmpty(interfaces)) {\n            for (Type type : interfaces) {\n                if (type instanceof ParameterizedType) {\n                    ParameterizedType t = (ParameterizedType) type;\n                    if (\"java.util.Map\".equals(t.getRawType().getTypeName())) {\n                        return t.getActualTypeArguments()[0];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get parameterized type\n     *\n     * @param genericType generic type\n     * @param index       index of the target parameterized type\n     * @return Return Person.class for List<Person>, return Person.class for Map<String, Person> when index=0\n     */\n    private static Type getGenericClassByIndex(Type genericType, int index) {\n        Type clazz = null;\n        // find parameterized type\n        if (genericType instanceof ParameterizedType) {\n            ParameterizedType t = (ParameterizedType) genericType;\n            Type[] types = t.getActualTypeArguments();\n            clazz = types[index];\n        }\n        return clazz;\n    }\n\n    private static Object newThrowableInstance(Class<?> cls, String message) {\n        try {\n            Constructor<?> messagedConstructor = cls.getDeclaredConstructor(String.class);\n            return messagedConstructor.newInstance(message);\n        } catch (Exception t) {\n            return newInstance(cls);\n        }\n    }\n\n    private static Object newInstance(Class<?> cls) {\n        try {\n            return cls.getDeclaredConstructor().newInstance();\n        } catch (Exception t) {\n            Constructor<?>[] constructors = cls.getDeclaredConstructors();\n            /*\n             From Javadoc java.lang.Class#getDeclaredConstructors\n             This method returns an array of Constructor objects reflecting all the constructors\n             declared by the class represented by this Class object.\n             This method returns an array of length 0,\n             if this Class object represents an interface, a primitive type, an array class, or void.\n            */\n            if (constructors.length == 0) {\n                throw new RuntimeException(\"Illegal constructor: \" + cls.getName());\n            }\n            Throwable lastError = null;\n            Arrays.sort(constructors, Comparator.comparingInt(a -> a.getParameterTypes().length));\n            for (Constructor<?> constructor : constructors) {\n                try {\n                    constructor.setAccessible(true);\n                    Object[] parameters = Arrays.stream(constructor.getParameterTypes())\n                            .map(PojoUtils::getDefaultValue)\n                            .toArray();\n                    return constructor.newInstance(parameters);\n                } catch (Exception e) {\n                    lastError = e;\n                }\n            }\n            throw new RuntimeException(lastError.getMessage(), lastError);\n        }\n    }\n\n    /**\n     * return init value\n     *\n     * @param parameterType\n     * @return\n     */\n    private static Object getDefaultValue(Class<?> parameterType) {\n        if (\"char\".equals(parameterType.getName())) {\n            return Character.MIN_VALUE;\n        }\n        if (\"boolean\".equals(parameterType.getName())) {\n            return false;\n        }\n        if (\"byte\".equals(parameterType.getName())) {\n            return (byte) 0;\n        }\n        if (\"short\".equals(parameterType.getName())) {\n            return (short) 0;\n        }\n        return parameterType.isPrimitive() ? 0 : null;\n    }\n\n    private static Method getSetterMethod(Class<?> cls, String property, Class<?> valueCls) {\n        String name = \"set\" + property.substring(0, 1).toUpperCase() + property.substring(1);\n        Method method = NAME_METHODS_CACHE.get(cls.getName() + \".\" + name + \"(\" + valueCls.getName() + \")\");\n        if (method == null) {\n            try {\n                method = cls.getMethod(name, valueCls);\n            } catch (NoSuchMethodException e) {\n                for (Method m : cls.getMethods()) {\n                    if (ReflectUtils.isBeanPropertyWriteMethod(m) && m.getName().equals(name)) {\n                        method = m;\n                        break;\n                    }\n                }\n            }\n            if (method != null) {\n                NAME_METHODS_CACHE.put(cls.getName() + \".\" + name + \"(\" + valueCls.getName() + \")\", method);\n            }\n        }\n        return method;\n    }\n\n    private static Field getAndCacheField(Class<?> cls, String fieldName) {\n        Field result;\n        if (CLASS_FIELD_CACHE.containsKey(cls) && CLASS_FIELD_CACHE.get(cls).containsKey(fieldName)) {\n            return CLASS_FIELD_CACHE.get(cls).get(fieldName);\n        }\n\n        result = getField(cls, fieldName);\n\n        if (result != null) {\n            ConcurrentMap<String, Field> fields =\n                    CLASS_FIELD_CACHE.computeIfAbsent(cls, k -> new ConcurrentHashMap<>());\n            fields.putIfAbsent(fieldName, result);\n        }\n        return result;\n    }\n\n    private static Field getField(Class<?> cls, String fieldName) {\n        Field result = null;\n        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n            try {\n                result = acls.getDeclaredField(fieldName);\n                if (!Modifier.isPublic(result.getModifiers())) {\n                    result.setAccessible(true);\n                }\n            } catch (NoSuchFieldException e) {\n            }\n        }\n        if (result == null && cls != null) {\n            for (Field field : cls.getFields()) {\n                if (fieldName.equals(field.getName()) && ReflectUtils.isPublicInstanceField(field)) {\n                    result = field;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static boolean isPojo(Class<?> cls) {\n        return !ReflectUtils.isPrimitives(cls)\n                && !Collection.class.isAssignableFrom(cls)\n                && !Map.class.isAssignableFrom(cls);\n    }\n\n    /**\n     * Update the property if absent\n     *\n     * @param getterMethod the getter method\n     * @param setterMethod the setter method\n     * @param newValue     the new value\n     * @param <T>          the value type\n     * @since 2.7.8\n     */\n    public static <T> void updatePropertyIfAbsent(Supplier<T> getterMethod, Consumer<T> setterMethod, T newValue) {\n        if (newValue != null && getterMethod.get() == null) {\n            setterMethod.accept(newValue);\n        }\n    }\n\n    /**\n     * convert map to a specific class instance\n     *\n     * @param map map wait for convert\n     * @param cls the specified class\n     * @param <T> the type of {@code cls}\n     * @return class instance declare in param {@code cls}\n     * @throws ReflectiveOperationException if the instance creation is failed\n     * @since 2.7.10\n     */\n    public static <T> T mapToPojo(Map<String, Object> map, Class<T> cls) throws ReflectiveOperationException {\n        T instance = cls.getDeclaredConstructor().newInstance();\n        Map<String, Field> beanPropertyFields = ReflectUtils.getBeanPropertyFields(cls);\n        for (Map.Entry<String, Field> entry : beanPropertyFields.entrySet()) {\n            String name = entry.getKey();\n            Field field = entry.getValue();\n            Object mapObject = map.get(name);\n            if (mapObject == null) {\n                continue;\n            }\n\n            Type type = field.getGenericType();\n            Object fieldObject = getFieldObject(mapObject, type);\n            field.set(instance, fieldObject);\n        }\n\n        return instance;\n    }\n\n    private static Object getFieldObject(Object mapObject, Type fieldType) throws ReflectiveOperationException {\n        if (fieldType instanceof Class<?>) {\n            return convertClassType(mapObject, (Class<?>) fieldType);\n        } else if (fieldType instanceof ParameterizedType) {\n            return convertParameterizedType(mapObject, (ParameterizedType) fieldType);\n        } else if (fieldType instanceof GenericArrayType\n                || fieldType instanceof TypeVariable<?>\n                || fieldType instanceof WildcardType) {\n            // ignore these type currently\n            return null;\n        } else {\n            throw new IllegalArgumentException(\"Unrecognized Type: \" + fieldType.toString());\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Object convertClassType(Object mapObject, Class<?> type) throws ReflectiveOperationException {\n        if (type.isPrimitive() || isAssignableFrom(type, mapObject.getClass())) {\n            return mapObject;\n        } else if (Objects.equals(type, String.class) && CLASS_CAN_BE_STRING.contains(mapObject.getClass())) {\n            // auto convert specified type to string\n            return mapObject.toString();\n        } else if (mapObject instanceof Map) {\n            return mapToPojo((Map<String, Object>) mapObject, type);\n        } else {\n            // type didn't match and mapObject is not another Map struct.\n            // we just ignore this situation.\n            return null;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Object convertParameterizedType(Object mapObject, ParameterizedType type)\n            throws ReflectiveOperationException {\n        Type rawType = type.getRawType();\n        if (!isAssignableFrom((Class<?>) rawType, mapObject.getClass())) {\n            return null;\n        }\n\n        Type[] actualTypeArguments = type.getActualTypeArguments();\n        if (isAssignableFrom(Map.class, (Class<?>) rawType)) {\n            Map<Object, Object> map = (Map<Object, Object>)\n                    mapObject.getClass().getDeclaredConstructor().newInstance();\n            for (Map.Entry<Object, Object> entry : ((Map<Object, Object>) mapObject).entrySet()) {\n                Object key = getFieldObject(entry.getKey(), actualTypeArguments[0]);\n                Object value = getFieldObject(entry.getValue(), actualTypeArguments[1]);\n                map.put(key, value);\n            }\n\n            return map;\n        } else if (isAssignableFrom(Collection.class, (Class<?>) rawType)) {\n            Collection<Object> collection = (Collection<Object>)\n                    mapObject.getClass().getDeclaredConstructor().newInstance();\n            for (Object m : (Iterable<?>) mapObject) {\n                Object ele = getFieldObject(m, actualTypeArguments[0]);\n                collection.add(ele);\n            }\n\n            return collection;\n        } else {\n            // ignore other type currently\n            return null;\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 140,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java",
        "line": 362,
        "sink": "java.lang.Enum.valueOf",
        "source": "-",
        "sourceLine": 362,
        "qualifier": "Call to java.lang.Enum.valueOf with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.Enum.valueOf with untrusted data from [msg : String](2).",
        "line_number": 362,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 141
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 141
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 141
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 141
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java#L432",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport org.apache.dubbo.common.config.ConfigurationUtils;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.IdentityHashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Properties;\nimport java.util.TreeMap;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_REFLECTIVE_OPERATION_FAILED;\nimport static org.apache.dubbo.common.utils.ClassUtils.isAssignableFrom;\n\n/**\n * PojoUtils. Travel object deeply, and convert complex type to simple type.\n * <p/>\n * Simple type below will be remained:\n * <ul>\n * <li> Primitive Type, also include <b>String</b>, <b>Number</b>(Integer, Long), <b>Date</b>\n * <li> Array of Primitive Type\n * <li> Collection, eg: List, Map, Set etc.\n * </ul>\n * <p/>\n * Other type will be covert to a map which contains the attributes and value pair of object.\n * <p>\n * TODO: exact PojoUtils to scope bean\n */\npublic class PojoUtils {\n\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(PojoUtils.class);\n    private static final ConcurrentMap<String, Method> NAME_METHODS_CACHE = new ConcurrentHashMap<>();\n    private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Field>> CLASS_FIELD_CACHE =\n            new ConcurrentHashMap<>();\n\n    private static final ConcurrentMap<String, Object> CLASS_NOT_FOUND_CACHE = new ConcurrentHashMap<>();\n\n    private static final Object NOT_FOUND_VALUE = new Object();\n    private static final boolean GENERIC_WITH_CLZ = Boolean.parseBoolean(ConfigurationUtils.getProperty(\n            ApplicationModel.defaultModel(), CommonConstants.GENERIC_WITH_CLZ_KEY, \"true\"));\n\n    private static final List<Class<?>> CLASS_CAN_BE_STRING = Arrays.asList(\n            Byte.class,\n            Short.class,\n            Integer.class,\n            Long.class,\n            Float.class,\n            Double.class,\n            Boolean.class,\n            Character.class);\n\n    public static Object[] generalize(Object[] objs) {\n        Object[] dests = new Object[objs.length];\n        for (int i = 0; i < objs.length; i++) {\n            dests[i] = generalize(objs[i]);\n        }\n        return dests;\n    }\n\n    public static Object[] realize(Object[] objs, Class<?>[] types) {\n        if (objs.length != types.length) {\n            throw new IllegalArgumentException(\"args.length != types.length\");\n        }\n\n        Object[] dests = new Object[objs.length];\n        for (int i = 0; i < objs.length; i++) {\n            dests[i] = realize(objs[i], types[i]);\n        }\n\n        return dests;\n    }\n\n    public static Object[] realize(Object[] objs, Class<?>[] types, Type[] gtypes) {\n        if (objs.length != types.length || objs.length != gtypes.length) {\n            throw new IllegalArgumentException(\"args.length != types.length\");\n        }\n        Object[] dests = new Object[objs.length];\n        for (int i = 0; i < objs.length; i++) {\n            dests[i] = realize(objs[i], types[i], gtypes[i]);\n        }\n        return dests;\n    }\n\n    public static Object generalize(Object pojo) {\n        return generalize(pojo, new IdentityHashMap<>());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Object generalize(Object pojo, Map<Object, Object> history) {\n        if (pojo == null) {\n            return null;\n        }\n\n        if (pojo instanceof Enum<?>) {\n            return ((Enum<?>) pojo).name();\n        }\n        if (pojo.getClass().isArray()\n                && Enum.class.isAssignableFrom(pojo.getClass().getComponentType())) {\n            int len = Array.getLength(pojo);\n            String[] values = new String[len];\n            for (int i = 0; i < len; i++) {\n                values[i] = ((Enum<?>) Array.get(pojo, i)).name();\n            }\n            return values;\n        }\n\n        if (ReflectUtils.isPrimitives(pojo.getClass())) {\n            return pojo;\n        }\n\n        if (pojo instanceof LocalDate || pojo instanceof LocalDateTime || pojo instanceof LocalTime) {\n            return pojo.toString();\n        }\n\n        if (pojo instanceof Class) {\n            return ((Class) pojo).getName();\n        }\n\n        Object o = history.get(pojo);\n        if (o != null) {\n            return o;\n        }\n        history.put(pojo, pojo);\n\n        if (pojo.getClass().isArray()) {\n            int len = Array.getLength(pojo);\n            Object[] dest = new Object[len];\n            history.put(pojo, dest);\n            for (int i = 0; i < len; i++) {\n                Object obj = Array.get(pojo, i);\n                dest[i] = generalize(obj, history);\n            }\n            return dest;\n        }\n        if (pojo instanceof Collection<?>) {\n            Collection<Object> src = (Collection<Object>) pojo;\n            int len = src.size();\n            Collection<Object> dest = (pojo instanceof List<?>) ? new ArrayList<>(len) : new HashSet<>(len);\n            history.put(pojo, dest);\n            for (Object obj : src) {\n                dest.add(generalize(obj, history));\n            }\n            return dest;\n        }\n        if (pojo instanceof Map<?, ?>) {\n            Map<Object, Object> src = (Map<Object, Object>) pojo;\n            Map<Object, Object> dest = createMap(src);\n            history.put(pojo, dest);\n            for (Map.Entry<Object, Object> obj : src.entrySet()) {\n                dest.put(generalize(obj.getKey(), history), generalize(obj.getValue(), history));\n            }\n            return dest;\n        }\n        Map<String, Object> map = new HashMap<>();\n        history.put(pojo, map);\n        if (GENERIC_WITH_CLZ) {\n            map.put(\"class\", pojo.getClass().getName());\n        }\n        for (Method method : pojo.getClass().getMethods()) {\n            if (ReflectUtils.isBeanPropertyReadMethod(method)) {\n                ReflectUtils.makeAccessible(method);\n                try {\n                    map.put(\n                            ReflectUtils.getPropertyNameFromBeanReadMethod(method),\n                            generalize(method.invoke(pojo), history));\n                } catch (Exception e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n        }\n        // public field\n        for (Field field : pojo.getClass().getFields()) {\n            if (ReflectUtils.isPublicInstanceField(field)) {\n                try {\n                    Object fieldValue = field.get(pojo);\n                    if (history.containsKey(pojo)) {\n                        Object pojoGeneralizedValue = history.get(pojo);\n                        if (pojoGeneralizedValue instanceof Map\n                                && ((Map) pojoGeneralizedValue).containsKey(field.getName())) {\n                            continue;\n                        }\n                    }\n                    if (fieldValue != null) {\n                        map.put(field.getName(), generalize(fieldValue, history));\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n        }\n        return map;\n    }\n\n    public static Object realize(Object pojo, Class<?> type) {\n        return realize0(pojo, type, null, new IdentityHashMap<>());\n    }\n\n    public static Object realize(Object pojo, Class<?> type, Type genericType) {\n        return realize0(pojo, type, genericType, new IdentityHashMap<>());\n    }\n\n    private static class PojoInvocationHandler implements InvocationHandler {\n\n        private final Map<Object, Object> map;\n\n        public PojoInvocationHandler(Map<Object, Object> map) {\n            this.map = map;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            if (method.getDeclaringClass() == Object.class) {\n                return method.invoke(map, args);\n            }\n            String methodName = method.getName();\n            Object value = null;\n            if (methodName.length() > 3 && methodName.startsWith(\"get\")) {\n                value = map.get(methodName.substring(3, 4).toLowerCase() + methodName.substring(4));\n            } else if (methodName.length() > 2 && methodName.startsWith(\"is\")) {\n                value = map.get(methodName.substring(2, 3).toLowerCase() + methodName.substring(3));\n            } else {\n                value = map.get(methodName.substring(0, 1).toLowerCase() + methodName.substring(1));\n            }\n            if (value instanceof Map<?, ?> && !Map.class.isAssignableFrom(method.getReturnType())) {\n                value = realize0(value, method.getReturnType(), null, new IdentityHashMap<>());\n            }\n            return value;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Collection<Object> createCollection(Class<?> type, int len) {\n        if (type.isAssignableFrom(ArrayList.class)) {\n            return new ArrayList<>(len);\n        }\n        if (type.isAssignableFrom(HashSet.class)) {\n            return new HashSet<>(len);\n        }\n        if (!type.isInterface() && !Modifier.isAbstract(type.getModifiers())) {\n            try {\n                return (Collection<Object>) type.getDeclaredConstructor().newInstance();\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n        return new ArrayList<>();\n    }\n\n    private static Map createMap(Map src) {\n        Class<? extends Map> cl = src.getClass();\n        Map result = null;\n        if (HashMap.class == cl) {\n            result = new HashMap();\n        } else if (Hashtable.class == cl) {\n            result = new Hashtable();\n        } else if (IdentityHashMap.class == cl) {\n            result = new IdentityHashMap();\n        } else if (LinkedHashMap.class == cl) {\n            result = new LinkedHashMap();\n        } else if (Properties.class == cl) {\n            result = new Properties();\n        } else if (TreeMap.class == cl) {\n            result = new TreeMap();\n        } else if (WeakHashMap.class == cl) {\n            return new WeakHashMap();\n        } else if (ConcurrentHashMap.class == cl) {\n            result = new ConcurrentHashMap();\n        } else if (ConcurrentSkipListMap.class == cl) {\n            result = new ConcurrentSkipListMap();\n        } else {\n            try {\n                result = cl.getDeclaredConstructor().newInstance();\n            } catch (Exception e) {\n                /* ignore */\n            }\n\n            if (result == null) {\n                try {\n                    Constructor<?> constructor = cl.getConstructor(Map.class);\n                    result = (Map) constructor.newInstance(Collections.EMPTY_MAP);\n                } catch (Exception e) {\n                    /* ignore */\n                }\n            }\n        }\n\n        if (result == null) {\n            result = new HashMap<>();\n        }\n\n        return result;\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private static Object realize0(Object pojo, Class<?> type, Type genericType, final Map<Object, Object> history) {\n        return realize1(pojo, type, genericType, new HashMap<>(8), history);\n    }\n\n    private static Object realize1(\n            Object pojo,\n            Class<?> type,\n            Type genericType,\n            final Map<String, Type> mapParent,\n            final Map<Object, Object> history) {\n        if (pojo == null) {\n            return null;\n        }\n\n        if (type != null && type.isEnum() && pojo.getClass() == String.class) {\n            return Enum.valueOf((Class<Enum>) type, (String) pojo);\n        }\n\n        if (ReflectUtils.isPrimitives(pojo.getClass())\n                && !(type != null\n                        && type.isArray()\n                        && type.getComponentType().isEnum()\n                        && pojo.getClass() == String[].class)) {\n            return CompatibleTypeUtils.compatibleTypeConvert(pojo, type);\n        }\n\n        Object o = history.get(pojo);\n\n        if (o != null) {\n            return o;\n        }\n\n        history.put(pojo, pojo);\n\n        Map<String, Type> mapGeneric = new HashMap<>(8);\n        mapGeneric.putAll(mapParent);\n        TypeVariable<? extends Class<?>>[] typeParameters = type.getTypeParameters();\n        if (genericType instanceof ParameterizedType && typeParameters.length > 0) {\n            ParameterizedType parameterizedType = (ParameterizedType) genericType;\n            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n            for (int i = 0; i < typeParameters.length; i++) {\n                if (!(actualTypeArguments[i] instanceof TypeVariable)) {\n                    mapGeneric.put(typeParameters[i].getTypeName(), actualTypeArguments[i]);\n                }\n            }\n        }\n\n        if (pojo.getClass().isArray()) {\n            if (Collection.class.isAssignableFrom(type)) {\n                Class<?> ctype = pojo.getClass().getComponentType();\n                int len = Array.getLength(pojo);\n                Collection dest = createCollection(type, len);\n                history.put(pojo, dest);\n                for (int i = 0; i < len; i++) {\n                    Object obj = Array.get(pojo, i);\n                    Object value = realize1(obj, ctype, null, mapGeneric, history);\n                    dest.add(value);\n                }\n                return dest;\n            } else {\n                Class<?> ctype = (type != null && type.isArray()\n                        ? type.getComponentType()\n                        : pojo.getClass().getComponentType());\n                int len = Array.getLength(pojo);\n                Object dest = Array.newInstance(ctype, len);\n                history.put(pojo, dest);\n                for (int i = 0; i < len; i++) {\n                    Object obj = Array.get(pojo, i);\n                    Object value = realize1(obj, ctype, null, mapGeneric, history);\n                    Array.set(dest, i, value);\n                }\n                return dest;\n            }\n        }\n\n        if (pojo instanceof Collection<?>) {\n            if (type.isArray()) {\n                Class<?> ctype = type.getComponentType();\n                Collection<Object> src = (Collection<Object>) pojo;\n                int len = src.size();\n                Object dest = Array.newInstance(ctype, len);\n                history.put(pojo, dest);\n                int i = 0;\n                for (Object obj : src) {\n                    Object value = realize1(obj, ctype, null, mapGeneric, history);\n                    Array.set(dest, i, value);\n                    i++;\n                }\n                return dest;\n            } else {\n                Collection<Object> src = (Collection<Object>) pojo;\n                int len = src.size();\n                Collection<Object> dest = createCollection(type, len);\n                history.put(pojo, dest);\n                for (Object obj : src) {\n                    Type keyType = getGenericClassByIndex(genericType, 0);\n                    Class<?> keyClazz = obj == null ? null : obj.getClass();\n                    if (keyType instanceof Class) {\n                        keyClazz = (Class<?>) keyType;\n                    }\n                    Object value = realize1(obj, keyClazz, keyType, mapGeneric, history);\n                    dest.add(value);\n                }\n                return dest;\n            }\n        }\n\n        if (pojo instanceof Map<?, ?> && type != null) {\n            Object className = ((Map<Object, Object>) pojo).get(\"class\");\n            if (className instanceof String) {\n                if (!CLASS_NOT_FOUND_CACHE.containsKey(className)) {\n                    try {\n                        type = DefaultSerializeClassChecker.getInstance()\n                                .loadClass(ClassUtils.getClassLoader(), (String) className);\n                    } catch (ClassNotFoundException e) {\n                        CLASS_NOT_FOUND_CACHE.put((String) className, NOT_FOUND_VALUE);\n                    }\n                }\n            }\n\n            // special logic for enum\n            if (type.isEnum()) {\n                Object name = ((Map<Object, Object>) pojo).get(\"name\");\n                if (name != null) {\n                    if (!(name instanceof String)) {\n                        throw new IllegalArgumentException(\"`name` filed should be string!\");\n                    } else {\n                        return Enum.valueOf((Class<Enum>) type, (String) name);\n                    }\n                }\n            }\n            Map<Object, Object> map;\n            // when return type is not the subclass of return type from the signature and not an interface\n            if (!type.isInterface() && !type.isAssignableFrom(pojo.getClass())) {\n                try {\n                    map = (Map<Object, Object>) type.getDeclaredConstructor().newInstance();\n                    Map<Object, Object> mapPojo = (Map<Object, Object>) pojo;\n                    map.putAll(mapPojo);\n                    if (GENERIC_WITH_CLZ) {\n                        map.remove(\"class\");\n                    }\n                } catch (Exception e) {\n                    // ignore error\n                    map = (Map<Object, Object>) pojo;\n                }\n            } else {\n                map = (Map<Object, Object>) pojo;\n            }\n\n            if (Map.class.isAssignableFrom(type) || type == Object.class) {\n                final Map<Object, Object> result;\n                // fix issue#5939\n                Type mapKeyType = getKeyTypeForMap(map.getClass());\n                Type typeKeyType = getGenericClassByIndex(genericType, 0);\n                boolean typeMismatch = mapKeyType instanceof Class\n                        && typeKeyType instanceof Class\n                        && !typeKeyType.getTypeName().equals(mapKeyType.getTypeName());\n                if (typeMismatch) {\n                    result = createMap(new HashMap(0));\n                } else {\n                    result = createMap(map);\n                }\n\n                history.put(pojo, result);\n                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                    Type keyType = getGenericClassByIndex(genericType, 0);\n                    Type valueType = getGenericClassByIndex(genericType, 1);\n                    Class<?> keyClazz;\n                    if (keyType instanceof Class) {\n                        keyClazz = (Class<?>) keyType;\n                    } else if (keyType instanceof ParameterizedType) {\n                        keyClazz = (Class<?>) ((ParameterizedType) keyType).getRawType();\n                    } else {\n                        keyClazz =\n                                entry.getKey() == null ? null : entry.getKey().getClass();\n                    }\n                    Class<?> valueClazz;\n                    if (valueType instanceof Class) {\n                        valueClazz = (Class<?>) valueType;\n                    } else if (valueType instanceof ParameterizedType) {\n                        valueClazz = (Class<?>) ((ParameterizedType) valueType).getRawType();\n                    } else {\n                        valueClazz = entry.getValue() == null\n                                ? null\n                                : entry.getValue().getClass();\n                    }\n\n                    Object key = keyClazz == null\n                            ? entry.getKey()\n                            : realize1(entry.getKey(), keyClazz, keyType, mapGeneric, history);\n                    Object value = valueClazz == null\n                            ? entry.getValue()\n                            : realize1(entry.getValue(), valueClazz, valueType, mapGeneric, history);\n                    result.put(key, value);\n                }\n                return result;\n            } else if (type.isInterface()) {\n                Object dest = Proxy.newProxyInstance(\n                        Thread.currentThread().getContextClassLoader(),\n                        new Class<?>[] {type},\n                        new PojoInvocationHandler(map));\n                history.put(pojo, dest);\n                return dest;\n            } else {\n                Object dest;\n                if (Throwable.class.isAssignableFrom(type)) {\n                    Object message = map.get(\"message\");\n                    if (message instanceof String) {\n                        dest = newThrowableInstance(type, (String) message);\n                    } else {\n                        dest = newInstance(type);\n                    }\n                } else {\n                    dest = newInstance(type);\n                }\n\n                history.put(pojo, dest);\n\n                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                    Object key = entry.getKey();\n                    if (key instanceof String) {\n                        String name = (String) key;\n                        Object value = entry.getValue();\n                        if (value != null) {\n                            Method method = getSetterMethod(dest.getClass(), name, value.getClass());\n                            Field field = getAndCacheField(dest.getClass(), name);\n                            if (method != null) {\n                                if (!method.isAccessible()) {\n                                    method.setAccessible(true);\n                                }\n                                Type containType = Optional.ofNullable(field)\n                                        .map(Field::getGenericType)\n                                        .map(Type::getTypeName)\n                                        .map(mapGeneric::get)\n                                        .orElse(null);\n                                if (containType != null) {\n                                    // is generic\n                                    if (containType instanceof ParameterizedType) {\n                                        value = realize1(\n                                                value,\n                                                (Class<?>) ((ParameterizedType) containType).getRawType(),\n                                                containType,\n                                                mapGeneric,\n                                                history);\n                                    } else if (containType instanceof Class) {\n                                        value = realize1(\n                                                value, (Class<?>) containType, containType, mapGeneric, history);\n                                    } else {\n                                        Type ptype = method.getGenericParameterTypes()[0];\n                                        value = realize1(\n                                                value, method.getParameterTypes()[0], ptype, mapGeneric, history);\n                                    }\n                                } else {\n                                    Type ptype = method.getGenericParameterTypes()[0];\n                                    value = realize1(value, method.getParameterTypes()[0], ptype, mapGeneric, history);\n                                }\n                                try {\n                                    method.invoke(dest, value);\n                                } catch (Exception e) {\n                                    String exceptionDescription = \"Failed to set pojo \"\n                                            + dest.getClass().getSimpleName() + \" property \" + name + \" value \"\n                                            + value.getClass() + \", cause: \" + e.getMessage();\n                                    logger.error(COMMON_REFLECTIVE_OPERATION_FAILED, \"\", \"\", exceptionDescription, e);\n                                    throw new RuntimeException(exceptionDescription, e);\n                                }\n                            } else if (field != null) {\n                                value = realize1(value, field.getType(), field.getGenericType(), mapGeneric, history);\n                                try {\n                                    field.set(dest, value);\n                                } catch (IllegalAccessException e) {\n                                    throw new RuntimeException(\n                                            \"Failed to set field \" + name + \" of pojo \"\n                                                    + dest.getClass().getName() + \" : \" + e.getMessage(),\n                                            e);\n                                }\n                            }\n                        }\n                    }\n                }\n                return dest;\n            }\n        }\n        return pojo;\n    }\n\n    /**\n     * Get key type for {@link Map} directly implemented by {@code clazz}.\n     * If {@code clazz} does not implement {@link Map} directly, return {@code null}.\n     *\n     * @param clazz {@link Class}\n     * @return Return String.class for {@link com.alibaba.fastjson.JSONObject}\n     */\n    private static Type getKeyTypeForMap(Class<?> clazz) {\n        Type[] interfaces = clazz.getGenericInterfaces();\n        if (!ArrayUtils.isEmpty(interfaces)) {\n            for (Type type : interfaces) {\n                if (type instanceof ParameterizedType) {\n                    ParameterizedType t = (ParameterizedType) type;\n                    if (\"java.util.Map\".equals(t.getRawType().getTypeName())) {\n                        return t.getActualTypeArguments()[0];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get parameterized type\n     *\n     * @param genericType generic type\n     * @param index       index of the target parameterized type\n     * @return Return Person.class for List<Person>, return Person.class for Map<String, Person> when index=0\n     */\n    private static Type getGenericClassByIndex(Type genericType, int index) {\n        Type clazz = null;\n        // find parameterized type\n        if (genericType instanceof ParameterizedType) {\n            ParameterizedType t = (ParameterizedType) genericType;\n            Type[] types = t.getActualTypeArguments();\n            clazz = types[index];\n        }\n        return clazz;\n    }\n\n    private static Object newThrowableInstance(Class<?> cls, String message) {\n        try {\n            Constructor<?> messagedConstructor = cls.getDeclaredConstructor(String.class);\n            return messagedConstructor.newInstance(message);\n        } catch (Exception t) {\n            return newInstance(cls);\n        }\n    }\n\n    private static Object newInstance(Class<?> cls) {\n        try {\n            return cls.getDeclaredConstructor().newInstance();\n        } catch (Exception t) {\n            Constructor<?>[] constructors = cls.getDeclaredConstructors();\n            /*\n             From Javadoc java.lang.Class#getDeclaredConstructors\n             This method returns an array of Constructor objects reflecting all the constructors\n             declared by the class represented by this Class object.\n             This method returns an array of length 0,\n             if this Class object represents an interface, a primitive type, an array class, or void.\n            */\n            if (constructors.length == 0) {\n                throw new RuntimeException(\"Illegal constructor: \" + cls.getName());\n            }\n            Throwable lastError = null;\n            Arrays.sort(constructors, Comparator.comparingInt(a -> a.getParameterTypes().length));\n            for (Constructor<?> constructor : constructors) {\n                try {\n                    constructor.setAccessible(true);\n                    Object[] parameters = Arrays.stream(constructor.getParameterTypes())\n                            .map(PojoUtils::getDefaultValue)\n                            .toArray();\n                    return constructor.newInstance(parameters);\n                } catch (Exception e) {\n                    lastError = e;\n                }\n            }\n            throw new RuntimeException(lastError.getMessage(), lastError);\n        }\n    }\n\n    /**\n     * return init value\n     *\n     * @param parameterType\n     * @return\n     */\n    private static Object getDefaultValue(Class<?> parameterType) {\n        if (\"char\".equals(parameterType.getName())) {\n            return Character.MIN_VALUE;\n        }\n        if (\"boolean\".equals(parameterType.getName())) {\n            return false;\n        }\n        if (\"byte\".equals(parameterType.getName())) {\n            return (byte) 0;\n        }\n        if (\"short\".equals(parameterType.getName())) {\n            return (short) 0;\n        }\n        return parameterType.isPrimitive() ? 0 : null;\n    }\n\n    private static Method getSetterMethod(Class<?> cls, String property, Class<?> valueCls) {\n        String name = \"set\" + property.substring(0, 1).toUpperCase() + property.substring(1);\n        Method method = NAME_METHODS_CACHE.get(cls.getName() + \".\" + name + \"(\" + valueCls.getName() + \")\");\n        if (method == null) {\n            try {\n                method = cls.getMethod(name, valueCls);\n            } catch (NoSuchMethodException e) {\n                for (Method m : cls.getMethods()) {\n                    if (ReflectUtils.isBeanPropertyWriteMethod(m) && m.getName().equals(name)) {\n                        method = m;\n                        break;\n                    }\n                }\n            }\n            if (method != null) {\n                NAME_METHODS_CACHE.put(cls.getName() + \".\" + name + \"(\" + valueCls.getName() + \")\", method);\n            }\n        }\n        return method;\n    }\n\n    private static Field getAndCacheField(Class<?> cls, String fieldName) {\n        Field result;\n        if (CLASS_FIELD_CACHE.containsKey(cls) && CLASS_FIELD_CACHE.get(cls).containsKey(fieldName)) {\n            return CLASS_FIELD_CACHE.get(cls).get(fieldName);\n        }\n\n        result = getField(cls, fieldName);\n\n        if (result != null) {\n            ConcurrentMap<String, Field> fields =\n                    CLASS_FIELD_CACHE.computeIfAbsent(cls, k -> new ConcurrentHashMap<>());\n            fields.putIfAbsent(fieldName, result);\n        }\n        return result;\n    }\n\n    private static Field getField(Class<?> cls, String fieldName) {\n        Field result = null;\n        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n            try {\n                result = acls.getDeclaredField(fieldName);\n                if (!Modifier.isPublic(result.getModifiers())) {\n                    result.setAccessible(true);\n                }\n            } catch (NoSuchFieldException e) {\n            }\n        }\n        if (result == null && cls != null) {\n            for (Field field : cls.getFields()) {\n                if (fieldName.equals(field.getName()) && ReflectUtils.isPublicInstanceField(field)) {\n                    result = field;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static boolean isPojo(Class<?> cls) {\n        return !ReflectUtils.isPrimitives(cls)\n                && !Collection.class.isAssignableFrom(cls)\n                && !Map.class.isAssignableFrom(cls);\n    }\n\n    /**\n     * Update the property if absent\n     *\n     * @param getterMethod the getter method\n     * @param setterMethod the setter method\n     * @param newValue     the new value\n     * @param <T>          the value type\n     * @since 2.7.8\n     */\n    public static <T> void updatePropertyIfAbsent(Supplier<T> getterMethod, Consumer<T> setterMethod, T newValue) {\n        if (newValue != null && getterMethod.get() == null) {\n            setterMethod.accept(newValue);\n        }\n    }\n\n    /**\n     * convert map to a specific class instance\n     *\n     * @param map map wait for convert\n     * @param cls the specified class\n     * @param <T> the type of {@code cls}\n     * @return class instance declare in param {@code cls}\n     * @throws ReflectiveOperationException if the instance creation is failed\n     * @since 2.7.10\n     */\n    public static <T> T mapToPojo(Map<String, Object> map, Class<T> cls) throws ReflectiveOperationException {\n        T instance = cls.getDeclaredConstructor().newInstance();\n        Map<String, Field> beanPropertyFields = ReflectUtils.getBeanPropertyFields(cls);\n        for (Map.Entry<String, Field> entry : beanPropertyFields.entrySet()) {\n            String name = entry.getKey();\n            Field field = entry.getValue();\n            Object mapObject = map.get(name);\n            if (mapObject == null) {\n                continue;\n            }\n\n            Type type = field.getGenericType();\n            Object fieldObject = getFieldObject(mapObject, type);\n            field.set(instance, fieldObject);\n        }\n\n        return instance;\n    }\n\n    private static Object getFieldObject(Object mapObject, Type fieldType) throws ReflectiveOperationException {\n        if (fieldType instanceof Class<?>) {\n            return convertClassType(mapObject, (Class<?>) fieldType);\n        } else if (fieldType instanceof ParameterizedType) {\n            return convertParameterizedType(mapObject, (ParameterizedType) fieldType);\n        } else if (fieldType instanceof GenericArrayType\n                || fieldType instanceof TypeVariable<?>\n                || fieldType instanceof WildcardType) {\n            // ignore these type currently\n            return null;\n        } else {\n            throw new IllegalArgumentException(\"Unrecognized Type: \" + fieldType.toString());\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Object convertClassType(Object mapObject, Class<?> type) throws ReflectiveOperationException {\n        if (type.isPrimitive() || isAssignableFrom(type, mapObject.getClass())) {\n            return mapObject;\n        } else if (Objects.equals(type, String.class) && CLASS_CAN_BE_STRING.contains(mapObject.getClass())) {\n            // auto convert specified type to string\n            return mapObject.toString();\n        } else if (mapObject instanceof Map) {\n            return mapToPojo((Map<String, Object>) mapObject, type);\n        } else {\n            // type didn't match and mapObject is not another Map struct.\n            // we just ignore this situation.\n            return null;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Object convertParameterizedType(Object mapObject, ParameterizedType type)\n            throws ReflectiveOperationException {\n        Type rawType = type.getRawType();\n        if (!isAssignableFrom((Class<?>) rawType, mapObject.getClass())) {\n            return null;\n        }\n\n        Type[] actualTypeArguments = type.getActualTypeArguments();\n        if (isAssignableFrom(Map.class, (Class<?>) rawType)) {\n            Map<Object, Object> map = (Map<Object, Object>)\n                    mapObject.getClass().getDeclaredConstructor().newInstance();\n            for (Map.Entry<Object, Object> entry : ((Map<Object, Object>) mapObject).entrySet()) {\n                Object key = getFieldObject(entry.getKey(), actualTypeArguments[0]);\n                Object value = getFieldObject(entry.getValue(), actualTypeArguments[1]);\n                map.put(key, value);\n            }\n\n            return map;\n        } else if (isAssignableFrom(Collection.class, (Class<?>) rawType)) {\n            Collection<Object> collection = (Collection<Object>)\n                    mapObject.getClass().getDeclaredConstructor().newInstance();\n            for (Object m : (Iterable<?>) mapObject) {\n                Object ele = getFieldObject(m, actualTypeArguments[0]);\n                collection.add(ele);\n            }\n\n            return collection;\n        } else {\n            // ignore other type currently\n            return null;\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 142,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java",
        "line": 432,
        "sink": "java.lang.reflect.Array.set",
        "source": "-",
        "sourceLine": 432,
        "qualifier": "Call to java.lang.reflect.Array.set with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.reflect.Array.set with untrusted data from [msg : String](2).",
        "line_number": 432,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 143
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 143
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 143
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 143
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java#L474",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport org.apache.dubbo.common.config.ConfigurationUtils;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.IdentityHashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Properties;\nimport java.util.TreeMap;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_REFLECTIVE_OPERATION_FAILED;\nimport static org.apache.dubbo.common.utils.ClassUtils.isAssignableFrom;\n\n/**\n * PojoUtils. Travel object deeply, and convert complex type to simple type.\n * <p/>\n * Simple type below will be remained:\n * <ul>\n * <li> Primitive Type, also include <b>String</b>, <b>Number</b>(Integer, Long), <b>Date</b>\n * <li> Array of Primitive Type\n * <li> Collection, eg: List, Map, Set etc.\n * </ul>\n * <p/>\n * Other type will be covert to a map which contains the attributes and value pair of object.\n * <p>\n * TODO: exact PojoUtils to scope bean\n */\npublic class PojoUtils {\n\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(PojoUtils.class);\n    private static final ConcurrentMap<String, Method> NAME_METHODS_CACHE = new ConcurrentHashMap<>();\n    private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Field>> CLASS_FIELD_CACHE =\n            new ConcurrentHashMap<>();\n\n    private static final ConcurrentMap<String, Object> CLASS_NOT_FOUND_CACHE = new ConcurrentHashMap<>();\n\n    private static final Object NOT_FOUND_VALUE = new Object();\n    private static final boolean GENERIC_WITH_CLZ = Boolean.parseBoolean(ConfigurationUtils.getProperty(\n            ApplicationModel.defaultModel(), CommonConstants.GENERIC_WITH_CLZ_KEY, \"true\"));\n\n    private static final List<Class<?>> CLASS_CAN_BE_STRING = Arrays.asList(\n            Byte.class,\n            Short.class,\n            Integer.class,\n            Long.class,\n            Float.class,\n            Double.class,\n            Boolean.class,\n            Character.class);\n\n    public static Object[] generalize(Object[] objs) {\n        Object[] dests = new Object[objs.length];\n        for (int i = 0; i < objs.length; i++) {\n            dests[i] = generalize(objs[i]);\n        }\n        return dests;\n    }\n\n    public static Object[] realize(Object[] objs, Class<?>[] types) {\n        if (objs.length != types.length) {\n            throw new IllegalArgumentException(\"args.length != types.length\");\n        }\n\n        Object[] dests = new Object[objs.length];\n        for (int i = 0; i < objs.length; i++) {\n            dests[i] = realize(objs[i], types[i]);\n        }\n\n        return dests;\n    }\n\n    public static Object[] realize(Object[] objs, Class<?>[] types, Type[] gtypes) {\n        if (objs.length != types.length || objs.length != gtypes.length) {\n            throw new IllegalArgumentException(\"args.length != types.length\");\n        }\n        Object[] dests = new Object[objs.length];\n        for (int i = 0; i < objs.length; i++) {\n            dests[i] = realize(objs[i], types[i], gtypes[i]);\n        }\n        return dests;\n    }\n\n    public static Object generalize(Object pojo) {\n        return generalize(pojo, new IdentityHashMap<>());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Object generalize(Object pojo, Map<Object, Object> history) {\n        if (pojo == null) {\n            return null;\n        }\n\n        if (pojo instanceof Enum<?>) {\n            return ((Enum<?>) pojo).name();\n        }\n        if (pojo.getClass().isArray()\n                && Enum.class.isAssignableFrom(pojo.getClass().getComponentType())) {\n            int len = Array.getLength(pojo);\n            String[] values = new String[len];\n            for (int i = 0; i < len; i++) {\n                values[i] = ((Enum<?>) Array.get(pojo, i)).name();\n            }\n            return values;\n        }\n\n        if (ReflectUtils.isPrimitives(pojo.getClass())) {\n            return pojo;\n        }\n\n        if (pojo instanceof LocalDate || pojo instanceof LocalDateTime || pojo instanceof LocalTime) {\n            return pojo.toString();\n        }\n\n        if (pojo instanceof Class) {\n            return ((Class) pojo).getName();\n        }\n\n        Object o = history.get(pojo);\n        if (o != null) {\n            return o;\n        }\n        history.put(pojo, pojo);\n\n        if (pojo.getClass().isArray()) {\n            int len = Array.getLength(pojo);\n            Object[] dest = new Object[len];\n            history.put(pojo, dest);\n            for (int i = 0; i < len; i++) {\n                Object obj = Array.get(pojo, i);\n                dest[i] = generalize(obj, history);\n            }\n            return dest;\n        }\n        if (pojo instanceof Collection<?>) {\n            Collection<Object> src = (Collection<Object>) pojo;\n            int len = src.size();\n            Collection<Object> dest = (pojo instanceof List<?>) ? new ArrayList<>(len) : new HashSet<>(len);\n            history.put(pojo, dest);\n            for (Object obj : src) {\n                dest.add(generalize(obj, history));\n            }\n            return dest;\n        }\n        if (pojo instanceof Map<?, ?>) {\n            Map<Object, Object> src = (Map<Object, Object>) pojo;\n            Map<Object, Object> dest = createMap(src);\n            history.put(pojo, dest);\n            for (Map.Entry<Object, Object> obj : src.entrySet()) {\n                dest.put(generalize(obj.getKey(), history), generalize(obj.getValue(), history));\n            }\n            return dest;\n        }\n        Map<String, Object> map = new HashMap<>();\n        history.put(pojo, map);\n        if (GENERIC_WITH_CLZ) {\n            map.put(\"class\", pojo.getClass().getName());\n        }\n        for (Method method : pojo.getClass().getMethods()) {\n            if (ReflectUtils.isBeanPropertyReadMethod(method)) {\n                ReflectUtils.makeAccessible(method);\n                try {\n                    map.put(\n                            ReflectUtils.getPropertyNameFromBeanReadMethod(method),\n                            generalize(method.invoke(pojo), history));\n                } catch (Exception e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n        }\n        // public field\n        for (Field field : pojo.getClass().getFields()) {\n            if (ReflectUtils.isPublicInstanceField(field)) {\n                try {\n                    Object fieldValue = field.get(pojo);\n                    if (history.containsKey(pojo)) {\n                        Object pojoGeneralizedValue = history.get(pojo);\n                        if (pojoGeneralizedValue instanceof Map\n                                && ((Map) pojoGeneralizedValue).containsKey(field.getName())) {\n                            continue;\n                        }\n                    }\n                    if (fieldValue != null) {\n                        map.put(field.getName(), generalize(fieldValue, history));\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n        }\n        return map;\n    }\n\n    public static Object realize(Object pojo, Class<?> type) {\n        return realize0(pojo, type, null, new IdentityHashMap<>());\n    }\n\n    public static Object realize(Object pojo, Class<?> type, Type genericType) {\n        return realize0(pojo, type, genericType, new IdentityHashMap<>());\n    }\n\n    private static class PojoInvocationHandler implements InvocationHandler {\n\n        private final Map<Object, Object> map;\n\n        public PojoInvocationHandler(Map<Object, Object> map) {\n            this.map = map;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            if (method.getDeclaringClass() == Object.class) {\n                return method.invoke(map, args);\n            }\n            String methodName = method.getName();\n            Object value = null;\n            if (methodName.length() > 3 && methodName.startsWith(\"get\")) {\n                value = map.get(methodName.substring(3, 4).toLowerCase() + methodName.substring(4));\n            } else if (methodName.length() > 2 && methodName.startsWith(\"is\")) {\n                value = map.get(methodName.substring(2, 3).toLowerCase() + methodName.substring(3));\n            } else {\n                value = map.get(methodName.substring(0, 1).toLowerCase() + methodName.substring(1));\n            }\n            if (value instanceof Map<?, ?> && !Map.class.isAssignableFrom(method.getReturnType())) {\n                value = realize0(value, method.getReturnType(), null, new IdentityHashMap<>());\n            }\n            return value;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Collection<Object> createCollection(Class<?> type, int len) {\n        if (type.isAssignableFrom(ArrayList.class)) {\n            return new ArrayList<>(len);\n        }\n        if (type.isAssignableFrom(HashSet.class)) {\n            return new HashSet<>(len);\n        }\n        if (!type.isInterface() && !Modifier.isAbstract(type.getModifiers())) {\n            try {\n                return (Collection<Object>) type.getDeclaredConstructor().newInstance();\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n        return new ArrayList<>();\n    }\n\n    private static Map createMap(Map src) {\n        Class<? extends Map> cl = src.getClass();\n        Map result = null;\n        if (HashMap.class == cl) {\n            result = new HashMap();\n        } else if (Hashtable.class == cl) {\n            result = new Hashtable();\n        } else if (IdentityHashMap.class == cl) {\n            result = new IdentityHashMap();\n        } else if (LinkedHashMap.class == cl) {\n            result = new LinkedHashMap();\n        } else if (Properties.class == cl) {\n            result = new Properties();\n        } else if (TreeMap.class == cl) {\n            result = new TreeMap();\n        } else if (WeakHashMap.class == cl) {\n            return new WeakHashMap();\n        } else if (ConcurrentHashMap.class == cl) {\n            result = new ConcurrentHashMap();\n        } else if (ConcurrentSkipListMap.class == cl) {\n            result = new ConcurrentSkipListMap();\n        } else {\n            try {\n                result = cl.getDeclaredConstructor().newInstance();\n            } catch (Exception e) {\n                /* ignore */\n            }\n\n            if (result == null) {\n                try {\n                    Constructor<?> constructor = cl.getConstructor(Map.class);\n                    result = (Map) constructor.newInstance(Collections.EMPTY_MAP);\n                } catch (Exception e) {\n                    /* ignore */\n                }\n            }\n        }\n\n        if (result == null) {\n            result = new HashMap<>();\n        }\n\n        return result;\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private static Object realize0(Object pojo, Class<?> type, Type genericType, final Map<Object, Object> history) {\n        return realize1(pojo, type, genericType, new HashMap<>(8), history);\n    }\n\n    private static Object realize1(\n            Object pojo,\n            Class<?> type,\n            Type genericType,\n            final Map<String, Type> mapParent,\n            final Map<Object, Object> history) {\n        if (pojo == null) {\n            return null;\n        }\n\n        if (type != null && type.isEnum() && pojo.getClass() == String.class) {\n            return Enum.valueOf((Class<Enum>) type, (String) pojo);\n        }\n\n        if (ReflectUtils.isPrimitives(pojo.getClass())\n                && !(type != null\n                        && type.isArray()\n                        && type.getComponentType().isEnum()\n                        && pojo.getClass() == String[].class)) {\n            return CompatibleTypeUtils.compatibleTypeConvert(pojo, type);\n        }\n\n        Object o = history.get(pojo);\n\n        if (o != null) {\n            return o;\n        }\n\n        history.put(pojo, pojo);\n\n        Map<String, Type> mapGeneric = new HashMap<>(8);\n        mapGeneric.putAll(mapParent);\n        TypeVariable<? extends Class<?>>[] typeParameters = type.getTypeParameters();\n        if (genericType instanceof ParameterizedType && typeParameters.length > 0) {\n            ParameterizedType parameterizedType = (ParameterizedType) genericType;\n            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n            for (int i = 0; i < typeParameters.length; i++) {\n                if (!(actualTypeArguments[i] instanceof TypeVariable)) {\n                    mapGeneric.put(typeParameters[i].getTypeName(), actualTypeArguments[i]);\n                }\n            }\n        }\n\n        if (pojo.getClass().isArray()) {\n            if (Collection.class.isAssignableFrom(type)) {\n                Class<?> ctype = pojo.getClass().getComponentType();\n                int len = Array.getLength(pojo);\n                Collection dest = createCollection(type, len);\n                history.put(pojo, dest);\n                for (int i = 0; i < len; i++) {\n                    Object obj = Array.get(pojo, i);\n                    Object value = realize1(obj, ctype, null, mapGeneric, history);\n                    dest.add(value);\n                }\n                return dest;\n            } else {\n                Class<?> ctype = (type != null && type.isArray()\n                        ? type.getComponentType()\n                        : pojo.getClass().getComponentType());\n                int len = Array.getLength(pojo);\n                Object dest = Array.newInstance(ctype, len);\n                history.put(pojo, dest);\n                for (int i = 0; i < len; i++) {\n                    Object obj = Array.get(pojo, i);\n                    Object value = realize1(obj, ctype, null, mapGeneric, history);\n                    Array.set(dest, i, value);\n                }\n                return dest;\n            }\n        }\n\n        if (pojo instanceof Collection<?>) {\n            if (type.isArray()) {\n                Class<?> ctype = type.getComponentType();\n                Collection<Object> src = (Collection<Object>) pojo;\n                int len = src.size();\n                Object dest = Array.newInstance(ctype, len);\n                history.put(pojo, dest);\n                int i = 0;\n                for (Object obj : src) {\n                    Object value = realize1(obj, ctype, null, mapGeneric, history);\n                    Array.set(dest, i, value);\n                    i++;\n                }\n                return dest;\n            } else {\n                Collection<Object> src = (Collection<Object>) pojo;\n                int len = src.size();\n                Collection<Object> dest = createCollection(type, len);\n                history.put(pojo, dest);\n                for (Object obj : src) {\n                    Type keyType = getGenericClassByIndex(genericType, 0);\n                    Class<?> keyClazz = obj == null ? null : obj.getClass();\n                    if (keyType instanceof Class) {\n                        keyClazz = (Class<?>) keyType;\n                    }\n                    Object value = realize1(obj, keyClazz, keyType, mapGeneric, history);\n                    dest.add(value);\n                }\n                return dest;\n            }\n        }\n\n        if (pojo instanceof Map<?, ?> && type != null) {\n            Object className = ((Map<Object, Object>) pojo).get(\"class\");\n            if (className instanceof String) {\n                if (!CLASS_NOT_FOUND_CACHE.containsKey(className)) {\n                    try {\n                        type = DefaultSerializeClassChecker.getInstance()\n                                .loadClass(ClassUtils.getClassLoader(), (String) className);\n                    } catch (ClassNotFoundException e) {\n                        CLASS_NOT_FOUND_CACHE.put((String) className, NOT_FOUND_VALUE);\n                    }\n                }\n            }\n\n            // special logic for enum\n            if (type.isEnum()) {\n                Object name = ((Map<Object, Object>) pojo).get(\"name\");\n                if (name != null) {\n                    if (!(name instanceof String)) {\n                        throw new IllegalArgumentException(\"`name` filed should be string!\");\n                    } else {\n                        return Enum.valueOf((Class<Enum>) type, (String) name);\n                    }\n                }\n            }\n            Map<Object, Object> map;\n            // when return type is not the subclass of return type from the signature and not an interface\n            if (!type.isInterface() && !type.isAssignableFrom(pojo.getClass())) {\n                try {\n                    map = (Map<Object, Object>) type.getDeclaredConstructor().newInstance();\n                    Map<Object, Object> mapPojo = (Map<Object, Object>) pojo;\n                    map.putAll(mapPojo);\n                    if (GENERIC_WITH_CLZ) {\n                        map.remove(\"class\");\n                    }\n                } catch (Exception e) {\n                    // ignore error\n                    map = (Map<Object, Object>) pojo;\n                }\n            } else {\n                map = (Map<Object, Object>) pojo;\n            }\n\n            if (Map.class.isAssignableFrom(type) || type == Object.class) {\n                final Map<Object, Object> result;\n                // fix issue#5939\n                Type mapKeyType = getKeyTypeForMap(map.getClass());\n                Type typeKeyType = getGenericClassByIndex(genericType, 0);\n                boolean typeMismatch = mapKeyType instanceof Class\n                        && typeKeyType instanceof Class\n                        && !typeKeyType.getTypeName().equals(mapKeyType.getTypeName());\n                if (typeMismatch) {\n                    result = createMap(new HashMap(0));\n                } else {\n                    result = createMap(map);\n                }\n\n                history.put(pojo, result);\n                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                    Type keyType = getGenericClassByIndex(genericType, 0);\n                    Type valueType = getGenericClassByIndex(genericType, 1);\n                    Class<?> keyClazz;\n                    if (keyType instanceof Class) {\n                        keyClazz = (Class<?>) keyType;\n                    } else if (keyType instanceof ParameterizedType) {\n                        keyClazz = (Class<?>) ((ParameterizedType) keyType).getRawType();\n                    } else {\n                        keyClazz =\n                                entry.getKey() == null ? null : entry.getKey().getClass();\n                    }\n                    Class<?> valueClazz;\n                    if (valueType instanceof Class) {\n                        valueClazz = (Class<?>) valueType;\n                    } else if (valueType instanceof ParameterizedType) {\n                        valueClazz = (Class<?>) ((ParameterizedType) valueType).getRawType();\n                    } else {\n                        valueClazz = entry.getValue() == null\n                                ? null\n                                : entry.getValue().getClass();\n                    }\n\n                    Object key = keyClazz == null\n                            ? entry.getKey()\n                            : realize1(entry.getKey(), keyClazz, keyType, mapGeneric, history);\n                    Object value = valueClazz == null\n                            ? entry.getValue()\n                            : realize1(entry.getValue(), valueClazz, valueType, mapGeneric, history);\n                    result.put(key, value);\n                }\n                return result;\n            } else if (type.isInterface()) {\n                Object dest = Proxy.newProxyInstance(\n                        Thread.currentThread().getContextClassLoader(),\n                        new Class<?>[] {type},\n                        new PojoInvocationHandler(map));\n                history.put(pojo, dest);\n                return dest;\n            } else {\n                Object dest;\n                if (Throwable.class.isAssignableFrom(type)) {\n                    Object message = map.get(\"message\");\n                    if (message instanceof String) {\n                        dest = newThrowableInstance(type, (String) message);\n                    } else {\n                        dest = newInstance(type);\n                    }\n                } else {\n                    dest = newInstance(type);\n                }\n\n                history.put(pojo, dest);\n\n                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                    Object key = entry.getKey();\n                    if (key instanceof String) {\n                        String name = (String) key;\n                        Object value = entry.getValue();\n                        if (value != null) {\n                            Method method = getSetterMethod(dest.getClass(), name, value.getClass());\n                            Field field = getAndCacheField(dest.getClass(), name);\n                            if (method != null) {\n                                if (!method.isAccessible()) {\n                                    method.setAccessible(true);\n                                }\n                                Type containType = Optional.ofNullable(field)\n                                        .map(Field::getGenericType)\n                                        .map(Type::getTypeName)\n                                        .map(mapGeneric::get)\n                                        .orElse(null);\n                                if (containType != null) {\n                                    // is generic\n                                    if (containType instanceof ParameterizedType) {\n                                        value = realize1(\n                                                value,\n                                                (Class<?>) ((ParameterizedType) containType).getRawType(),\n                                                containType,\n                                                mapGeneric,\n                                                history);\n                                    } else if (containType instanceof Class) {\n                                        value = realize1(\n                                                value, (Class<?>) containType, containType, mapGeneric, history);\n                                    } else {\n                                        Type ptype = method.getGenericParameterTypes()[0];\n                                        value = realize1(\n                                                value, method.getParameterTypes()[0], ptype, mapGeneric, history);\n                                    }\n                                } else {\n                                    Type ptype = method.getGenericParameterTypes()[0];\n                                    value = realize1(value, method.getParameterTypes()[0], ptype, mapGeneric, history);\n                                }\n                                try {\n                                    method.invoke(dest, value);\n                                } catch (Exception e) {\n                                    String exceptionDescription = \"Failed to set pojo \"\n                                            + dest.getClass().getSimpleName() + \" property \" + name + \" value \"\n                                            + value.getClass() + \", cause: \" + e.getMessage();\n                                    logger.error(COMMON_REFLECTIVE_OPERATION_FAILED, \"\", \"\", exceptionDescription, e);\n                                    throw new RuntimeException(exceptionDescription, e);\n                                }\n                            } else if (field != null) {\n                                value = realize1(value, field.getType(), field.getGenericType(), mapGeneric, history);\n                                try {\n                                    field.set(dest, value);\n                                } catch (IllegalAccessException e) {\n                                    throw new RuntimeException(\n                                            \"Failed to set field \" + name + \" of pojo \"\n                                                    + dest.getClass().getName() + \" : \" + e.getMessage(),\n                                            e);\n                                }\n                            }\n                        }\n                    }\n                }\n                return dest;\n            }\n        }\n        return pojo;\n    }\n\n    /**\n     * Get key type for {@link Map} directly implemented by {@code clazz}.\n     * If {@code clazz} does not implement {@link Map} directly, return {@code null}.\n     *\n     * @param clazz {@link Class}\n     * @return Return String.class for {@link com.alibaba.fastjson.JSONObject}\n     */\n    private static Type getKeyTypeForMap(Class<?> clazz) {\n        Type[] interfaces = clazz.getGenericInterfaces();\n        if (!ArrayUtils.isEmpty(interfaces)) {\n            for (Type type : interfaces) {\n                if (type instanceof ParameterizedType) {\n                    ParameterizedType t = (ParameterizedType) type;\n                    if (\"java.util.Map\".equals(t.getRawType().getTypeName())) {\n                        return t.getActualTypeArguments()[0];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get parameterized type\n     *\n     * @param genericType generic type\n     * @param index       index of the target parameterized type\n     * @return Return Person.class for List<Person>, return Person.class for Map<String, Person> when index=0\n     */\n    private static Type getGenericClassByIndex(Type genericType, int index) {\n        Type clazz = null;\n        // find parameterized type\n        if (genericType instanceof ParameterizedType) {\n            ParameterizedType t = (ParameterizedType) genericType;\n            Type[] types = t.getActualTypeArguments();\n            clazz = types[index];\n        }\n        return clazz;\n    }\n\n    private static Object newThrowableInstance(Class<?> cls, String message) {\n        try {\n            Constructor<?> messagedConstructor = cls.getDeclaredConstructor(String.class);\n            return messagedConstructor.newInstance(message);\n        } catch (Exception t) {\n            return newInstance(cls);\n        }\n    }\n\n    private static Object newInstance(Class<?> cls) {\n        try {\n            return cls.getDeclaredConstructor().newInstance();\n        } catch (Exception t) {\n            Constructor<?>[] constructors = cls.getDeclaredConstructors();\n            /*\n             From Javadoc java.lang.Class#getDeclaredConstructors\n             This method returns an array of Constructor objects reflecting all the constructors\n             declared by the class represented by this Class object.\n             This method returns an array of length 0,\n             if this Class object represents an interface, a primitive type, an array class, or void.\n            */\n            if (constructors.length == 0) {\n                throw new RuntimeException(\"Illegal constructor: \" + cls.getName());\n            }\n            Throwable lastError = null;\n            Arrays.sort(constructors, Comparator.comparingInt(a -> a.getParameterTypes().length));\n            for (Constructor<?> constructor : constructors) {\n                try {\n                    constructor.setAccessible(true);\n                    Object[] parameters = Arrays.stream(constructor.getParameterTypes())\n                            .map(PojoUtils::getDefaultValue)\n                            .toArray();\n                    return constructor.newInstance(parameters);\n                } catch (Exception e) {\n                    lastError = e;\n                }\n            }\n            throw new RuntimeException(lastError.getMessage(), lastError);\n        }\n    }\n\n    /**\n     * return init value\n     *\n     * @param parameterType\n     * @return\n     */\n    private static Object getDefaultValue(Class<?> parameterType) {\n        if (\"char\".equals(parameterType.getName())) {\n            return Character.MIN_VALUE;\n        }\n        if (\"boolean\".equals(parameterType.getName())) {\n            return false;\n        }\n        if (\"byte\".equals(parameterType.getName())) {\n            return (byte) 0;\n        }\n        if (\"short\".equals(parameterType.getName())) {\n            return (short) 0;\n        }\n        return parameterType.isPrimitive() ? 0 : null;\n    }\n\n    private static Method getSetterMethod(Class<?> cls, String property, Class<?> valueCls) {\n        String name = \"set\" + property.substring(0, 1).toUpperCase() + property.substring(1);\n        Method method = NAME_METHODS_CACHE.get(cls.getName() + \".\" + name + \"(\" + valueCls.getName() + \")\");\n        if (method == null) {\n            try {\n                method = cls.getMethod(name, valueCls);\n            } catch (NoSuchMethodException e) {\n                for (Method m : cls.getMethods()) {\n                    if (ReflectUtils.isBeanPropertyWriteMethod(m) && m.getName().equals(name)) {\n                        method = m;\n                        break;\n                    }\n                }\n            }\n            if (method != null) {\n                NAME_METHODS_CACHE.put(cls.getName() + \".\" + name + \"(\" + valueCls.getName() + \")\", method);\n            }\n        }\n        return method;\n    }\n\n    private static Field getAndCacheField(Class<?> cls, String fieldName) {\n        Field result;\n        if (CLASS_FIELD_CACHE.containsKey(cls) && CLASS_FIELD_CACHE.get(cls).containsKey(fieldName)) {\n            return CLASS_FIELD_CACHE.get(cls).get(fieldName);\n        }\n\n        result = getField(cls, fieldName);\n\n        if (result != null) {\n            ConcurrentMap<String, Field> fields =\n                    CLASS_FIELD_CACHE.computeIfAbsent(cls, k -> new ConcurrentHashMap<>());\n            fields.putIfAbsent(fieldName, result);\n        }\n        return result;\n    }\n\n    private static Field getField(Class<?> cls, String fieldName) {\n        Field result = null;\n        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n            try {\n                result = acls.getDeclaredField(fieldName);\n                if (!Modifier.isPublic(result.getModifiers())) {\n                    result.setAccessible(true);\n                }\n            } catch (NoSuchFieldException e) {\n            }\n        }\n        if (result == null && cls != null) {\n            for (Field field : cls.getFields()) {\n                if (fieldName.equals(field.getName()) && ReflectUtils.isPublicInstanceField(field)) {\n                    result = field;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static boolean isPojo(Class<?> cls) {\n        return !ReflectUtils.isPrimitives(cls)\n                && !Collection.class.isAssignableFrom(cls)\n                && !Map.class.isAssignableFrom(cls);\n    }\n\n    /**\n     * Update the property if absent\n     *\n     * @param getterMethod the getter method\n     * @param setterMethod the setter method\n     * @param newValue     the new value\n     * @param <T>          the value type\n     * @since 2.7.8\n     */\n    public static <T> void updatePropertyIfAbsent(Supplier<T> getterMethod, Consumer<T> setterMethod, T newValue) {\n        if (newValue != null && getterMethod.get() == null) {\n            setterMethod.accept(newValue);\n        }\n    }\n\n    /**\n     * convert map to a specific class instance\n     *\n     * @param map map wait for convert\n     * @param cls the specified class\n     * @param <T> the type of {@code cls}\n     * @return class instance declare in param {@code cls}\n     * @throws ReflectiveOperationException if the instance creation is failed\n     * @since 2.7.10\n     */\n    public static <T> T mapToPojo(Map<String, Object> map, Class<T> cls) throws ReflectiveOperationException {\n        T instance = cls.getDeclaredConstructor().newInstance();\n        Map<String, Field> beanPropertyFields = ReflectUtils.getBeanPropertyFields(cls);\n        for (Map.Entry<String, Field> entry : beanPropertyFields.entrySet()) {\n            String name = entry.getKey();\n            Field field = entry.getValue();\n            Object mapObject = map.get(name);\n            if (mapObject == null) {\n                continue;\n            }\n\n            Type type = field.getGenericType();\n            Object fieldObject = getFieldObject(mapObject, type);\n            field.set(instance, fieldObject);\n        }\n\n        return instance;\n    }\n\n    private static Object getFieldObject(Object mapObject, Type fieldType) throws ReflectiveOperationException {\n        if (fieldType instanceof Class<?>) {\n            return convertClassType(mapObject, (Class<?>) fieldType);\n        } else if (fieldType instanceof ParameterizedType) {\n            return convertParameterizedType(mapObject, (ParameterizedType) fieldType);\n        } else if (fieldType instanceof GenericArrayType\n                || fieldType instanceof TypeVariable<?>\n                || fieldType instanceof WildcardType) {\n            // ignore these type currently\n            return null;\n        } else {\n            throw new IllegalArgumentException(\"Unrecognized Type: \" + fieldType.toString());\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Object convertClassType(Object mapObject, Class<?> type) throws ReflectiveOperationException {\n        if (type.isPrimitive() || isAssignableFrom(type, mapObject.getClass())) {\n            return mapObject;\n        } else if (Objects.equals(type, String.class) && CLASS_CAN_BE_STRING.contains(mapObject.getClass())) {\n            // auto convert specified type to string\n            return mapObject.toString();\n        } else if (mapObject instanceof Map) {\n            return mapToPojo((Map<String, Object>) mapObject, type);\n        } else {\n            // type didn't match and mapObject is not another Map struct.\n            // we just ignore this situation.\n            return null;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Object convertParameterizedType(Object mapObject, ParameterizedType type)\n            throws ReflectiveOperationException {\n        Type rawType = type.getRawType();\n        if (!isAssignableFrom((Class<?>) rawType, mapObject.getClass())) {\n            return null;\n        }\n\n        Type[] actualTypeArguments = type.getActualTypeArguments();\n        if (isAssignableFrom(Map.class, (Class<?>) rawType)) {\n            Map<Object, Object> map = (Map<Object, Object>)\n                    mapObject.getClass().getDeclaredConstructor().newInstance();\n            for (Map.Entry<Object, Object> entry : ((Map<Object, Object>) mapObject).entrySet()) {\n                Object key = getFieldObject(entry.getKey(), actualTypeArguments[0]);\n                Object value = getFieldObject(entry.getValue(), actualTypeArguments[1]);\n                map.put(key, value);\n            }\n\n            return map;\n        } else if (isAssignableFrom(Collection.class, (Class<?>) rawType)) {\n            Collection<Object> collection = (Collection<Object>)\n                    mapObject.getClass().getDeclaredConstructor().newInstance();\n            for (Object m : (Iterable<?>) mapObject) {\n                Object ele = getFieldObject(m, actualTypeArguments[0]);\n                collection.add(ele);\n            }\n\n            return collection;\n        } else {\n            // ignore other type currently\n            return null;\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 144,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java",
        "line": 474,
        "sink": "java.lang.Enum.valueOf",
        "source": "-",
        "sourceLine": 474,
        "qualifier": "Call to java.lang.Enum.valueOf with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.Enum.valueOf with untrusted data from [msg : String](2).",
        "line_number": 474,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 145
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 145
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 145
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 145
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java#L615",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.utils;\n\nimport org.apache.dubbo.common.config.ConfigurationUtils;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\n\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.IdentityHashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Properties;\nimport java.util.TreeMap;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.ConcurrentSkipListMap;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.COMMON_REFLECTIVE_OPERATION_FAILED;\nimport static org.apache.dubbo.common.utils.ClassUtils.isAssignableFrom;\n\n/**\n * PojoUtils. Travel object deeply, and convert complex type to simple type.\n * <p/>\n * Simple type below will be remained:\n * <ul>\n * <li> Primitive Type, also include <b>String</b>, <b>Number</b>(Integer, Long), <b>Date</b>\n * <li> Array of Primitive Type\n * <li> Collection, eg: List, Map, Set etc.\n * </ul>\n * <p/>\n * Other type will be covert to a map which contains the attributes and value pair of object.\n * <p>\n * TODO: exact PojoUtils to scope bean\n */\npublic class PojoUtils {\n\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(PojoUtils.class);\n    private static final ConcurrentMap<String, Method> NAME_METHODS_CACHE = new ConcurrentHashMap<>();\n    private static final ConcurrentMap<Class<?>, ConcurrentMap<String, Field>> CLASS_FIELD_CACHE =\n            new ConcurrentHashMap<>();\n\n    private static final ConcurrentMap<String, Object> CLASS_NOT_FOUND_CACHE = new ConcurrentHashMap<>();\n\n    private static final Object NOT_FOUND_VALUE = new Object();\n    private static final boolean GENERIC_WITH_CLZ = Boolean.parseBoolean(ConfigurationUtils.getProperty(\n            ApplicationModel.defaultModel(), CommonConstants.GENERIC_WITH_CLZ_KEY, \"true\"));\n\n    private static final List<Class<?>> CLASS_CAN_BE_STRING = Arrays.asList(\n            Byte.class,\n            Short.class,\n            Integer.class,\n            Long.class,\n            Float.class,\n            Double.class,\n            Boolean.class,\n            Character.class);\n\n    public static Object[] generalize(Object[] objs) {\n        Object[] dests = new Object[objs.length];\n        for (int i = 0; i < objs.length; i++) {\n            dests[i] = generalize(objs[i]);\n        }\n        return dests;\n    }\n\n    public static Object[] realize(Object[] objs, Class<?>[] types) {\n        if (objs.length != types.length) {\n            throw new IllegalArgumentException(\"args.length != types.length\");\n        }\n\n        Object[] dests = new Object[objs.length];\n        for (int i = 0; i < objs.length; i++) {\n            dests[i] = realize(objs[i], types[i]);\n        }\n\n        return dests;\n    }\n\n    public static Object[] realize(Object[] objs, Class<?>[] types, Type[] gtypes) {\n        if (objs.length != types.length || objs.length != gtypes.length) {\n            throw new IllegalArgumentException(\"args.length != types.length\");\n        }\n        Object[] dests = new Object[objs.length];\n        for (int i = 0; i < objs.length; i++) {\n            dests[i] = realize(objs[i], types[i], gtypes[i]);\n        }\n        return dests;\n    }\n\n    public static Object generalize(Object pojo) {\n        return generalize(pojo, new IdentityHashMap<>());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Object generalize(Object pojo, Map<Object, Object> history) {\n        if (pojo == null) {\n            return null;\n        }\n\n        if (pojo instanceof Enum<?>) {\n            return ((Enum<?>) pojo).name();\n        }\n        if (pojo.getClass().isArray()\n                && Enum.class.isAssignableFrom(pojo.getClass().getComponentType())) {\n            int len = Array.getLength(pojo);\n            String[] values = new String[len];\n            for (int i = 0; i < len; i++) {\n                values[i] = ((Enum<?>) Array.get(pojo, i)).name();\n            }\n            return values;\n        }\n\n        if (ReflectUtils.isPrimitives(pojo.getClass())) {\n            return pojo;\n        }\n\n        if (pojo instanceof LocalDate || pojo instanceof LocalDateTime || pojo instanceof LocalTime) {\n            return pojo.toString();\n        }\n\n        if (pojo instanceof Class) {\n            return ((Class) pojo).getName();\n        }\n\n        Object o = history.get(pojo);\n        if (o != null) {\n            return o;\n        }\n        history.put(pojo, pojo);\n\n        if (pojo.getClass().isArray()) {\n            int len = Array.getLength(pojo);\n            Object[] dest = new Object[len];\n            history.put(pojo, dest);\n            for (int i = 0; i < len; i++) {\n                Object obj = Array.get(pojo, i);\n                dest[i] = generalize(obj, history);\n            }\n            return dest;\n        }\n        if (pojo instanceof Collection<?>) {\n            Collection<Object> src = (Collection<Object>) pojo;\n            int len = src.size();\n            Collection<Object> dest = (pojo instanceof List<?>) ? new ArrayList<>(len) : new HashSet<>(len);\n            history.put(pojo, dest);\n            for (Object obj : src) {\n                dest.add(generalize(obj, history));\n            }\n            return dest;\n        }\n        if (pojo instanceof Map<?, ?>) {\n            Map<Object, Object> src = (Map<Object, Object>) pojo;\n            Map<Object, Object> dest = createMap(src);\n            history.put(pojo, dest);\n            for (Map.Entry<Object, Object> obj : src.entrySet()) {\n                dest.put(generalize(obj.getKey(), history), generalize(obj.getValue(), history));\n            }\n            return dest;\n        }\n        Map<String, Object> map = new HashMap<>();\n        history.put(pojo, map);\n        if (GENERIC_WITH_CLZ) {\n            map.put(\"class\", pojo.getClass().getName());\n        }\n        for (Method method : pojo.getClass().getMethods()) {\n            if (ReflectUtils.isBeanPropertyReadMethod(method)) {\n                ReflectUtils.makeAccessible(method);\n                try {\n                    map.put(\n                            ReflectUtils.getPropertyNameFromBeanReadMethod(method),\n                            generalize(method.invoke(pojo), history));\n                } catch (Exception e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n        }\n        // public field\n        for (Field field : pojo.getClass().getFields()) {\n            if (ReflectUtils.isPublicInstanceField(field)) {\n                try {\n                    Object fieldValue = field.get(pojo);\n                    if (history.containsKey(pojo)) {\n                        Object pojoGeneralizedValue = history.get(pojo);\n                        if (pojoGeneralizedValue instanceof Map\n                                && ((Map) pojoGeneralizedValue).containsKey(field.getName())) {\n                            continue;\n                        }\n                    }\n                    if (fieldValue != null) {\n                        map.put(field.getName(), generalize(fieldValue, history));\n                    }\n                } catch (Exception e) {\n                    throw new RuntimeException(e.getMessage(), e);\n                }\n            }\n        }\n        return map;\n    }\n\n    public static Object realize(Object pojo, Class<?> type) {\n        return realize0(pojo, type, null, new IdentityHashMap<>());\n    }\n\n    public static Object realize(Object pojo, Class<?> type, Type genericType) {\n        return realize0(pojo, type, genericType, new IdentityHashMap<>());\n    }\n\n    private static class PojoInvocationHandler implements InvocationHandler {\n\n        private final Map<Object, Object> map;\n\n        public PojoInvocationHandler(Map<Object, Object> map) {\n            this.map = map;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            if (method.getDeclaringClass() == Object.class) {\n                return method.invoke(map, args);\n            }\n            String methodName = method.getName();\n            Object value = null;\n            if (methodName.length() > 3 && methodName.startsWith(\"get\")) {\n                value = map.get(methodName.substring(3, 4).toLowerCase() + methodName.substring(4));\n            } else if (methodName.length() > 2 && methodName.startsWith(\"is\")) {\n                value = map.get(methodName.substring(2, 3).toLowerCase() + methodName.substring(3));\n            } else {\n                value = map.get(methodName.substring(0, 1).toLowerCase() + methodName.substring(1));\n            }\n            if (value instanceof Map<?, ?> && !Map.class.isAssignableFrom(method.getReturnType())) {\n                value = realize0(value, method.getReturnType(), null, new IdentityHashMap<>());\n            }\n            return value;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Collection<Object> createCollection(Class<?> type, int len) {\n        if (type.isAssignableFrom(ArrayList.class)) {\n            return new ArrayList<>(len);\n        }\n        if (type.isAssignableFrom(HashSet.class)) {\n            return new HashSet<>(len);\n        }\n        if (!type.isInterface() && !Modifier.isAbstract(type.getModifiers())) {\n            try {\n                return (Collection<Object>) type.getDeclaredConstructor().newInstance();\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n        return new ArrayList<>();\n    }\n\n    private static Map createMap(Map src) {\n        Class<? extends Map> cl = src.getClass();\n        Map result = null;\n        if (HashMap.class == cl) {\n            result = new HashMap();\n        } else if (Hashtable.class == cl) {\n            result = new Hashtable();\n        } else if (IdentityHashMap.class == cl) {\n            result = new IdentityHashMap();\n        } else if (LinkedHashMap.class == cl) {\n            result = new LinkedHashMap();\n        } else if (Properties.class == cl) {\n            result = new Properties();\n        } else if (TreeMap.class == cl) {\n            result = new TreeMap();\n        } else if (WeakHashMap.class == cl) {\n            return new WeakHashMap();\n        } else if (ConcurrentHashMap.class == cl) {\n            result = new ConcurrentHashMap();\n        } else if (ConcurrentSkipListMap.class == cl) {\n            result = new ConcurrentSkipListMap();\n        } else {\n            try {\n                result = cl.getDeclaredConstructor().newInstance();\n            } catch (Exception e) {\n                /* ignore */\n            }\n\n            if (result == null) {\n                try {\n                    Constructor<?> constructor = cl.getConstructor(Map.class);\n                    result = (Map) constructor.newInstance(Collections.EMPTY_MAP);\n                } catch (Exception e) {\n                    /* ignore */\n                }\n            }\n        }\n\n        if (result == null) {\n            result = new HashMap<>();\n        }\n\n        return result;\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private static Object realize0(Object pojo, Class<?> type, Type genericType, final Map<Object, Object> history) {\n        return realize1(pojo, type, genericType, new HashMap<>(8), history);\n    }\n\n    private static Object realize1(\n            Object pojo,\n            Class<?> type,\n            Type genericType,\n            final Map<String, Type> mapParent,\n            final Map<Object, Object> history) {\n        if (pojo == null) {\n            return null;\n        }\n\n        if (type != null && type.isEnum() && pojo.getClass() == String.class) {\n            return Enum.valueOf((Class<Enum>) type, (String) pojo);\n        }\n\n        if (ReflectUtils.isPrimitives(pojo.getClass())\n                && !(type != null\n                        && type.isArray()\n                        && type.getComponentType().isEnum()\n                        && pojo.getClass() == String[].class)) {\n            return CompatibleTypeUtils.compatibleTypeConvert(pojo, type);\n        }\n\n        Object o = history.get(pojo);\n\n        if (o != null) {\n            return o;\n        }\n\n        history.put(pojo, pojo);\n\n        Map<String, Type> mapGeneric = new HashMap<>(8);\n        mapGeneric.putAll(mapParent);\n        TypeVariable<? extends Class<?>>[] typeParameters = type.getTypeParameters();\n        if (genericType instanceof ParameterizedType && typeParameters.length > 0) {\n            ParameterizedType parameterizedType = (ParameterizedType) genericType;\n            Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n            for (int i = 0; i < typeParameters.length; i++) {\n                if (!(actualTypeArguments[i] instanceof TypeVariable)) {\n                    mapGeneric.put(typeParameters[i].getTypeName(), actualTypeArguments[i]);\n                }\n            }\n        }\n\n        if (pojo.getClass().isArray()) {\n            if (Collection.class.isAssignableFrom(type)) {\n                Class<?> ctype = pojo.getClass().getComponentType();\n                int len = Array.getLength(pojo);\n                Collection dest = createCollection(type, len);\n                history.put(pojo, dest);\n                for (int i = 0; i < len; i++) {\n                    Object obj = Array.get(pojo, i);\n                    Object value = realize1(obj, ctype, null, mapGeneric, history);\n                    dest.add(value);\n                }\n                return dest;\n            } else {\n                Class<?> ctype = (type != null && type.isArray()\n                        ? type.getComponentType()\n                        : pojo.getClass().getComponentType());\n                int len = Array.getLength(pojo);\n                Object dest = Array.newInstance(ctype, len);\n                history.put(pojo, dest);\n                for (int i = 0; i < len; i++) {\n                    Object obj = Array.get(pojo, i);\n                    Object value = realize1(obj, ctype, null, mapGeneric, history);\n                    Array.set(dest, i, value);\n                }\n                return dest;\n            }\n        }\n\n        if (pojo instanceof Collection<?>) {\n            if (type.isArray()) {\n                Class<?> ctype = type.getComponentType();\n                Collection<Object> src = (Collection<Object>) pojo;\n                int len = src.size();\n                Object dest = Array.newInstance(ctype, len);\n                history.put(pojo, dest);\n                int i = 0;\n                for (Object obj : src) {\n                    Object value = realize1(obj, ctype, null, mapGeneric, history);\n                    Array.set(dest, i, value);\n                    i++;\n                }\n                return dest;\n            } else {\n                Collection<Object> src = (Collection<Object>) pojo;\n                int len = src.size();\n                Collection<Object> dest = createCollection(type, len);\n                history.put(pojo, dest);\n                for (Object obj : src) {\n                    Type keyType = getGenericClassByIndex(genericType, 0);\n                    Class<?> keyClazz = obj == null ? null : obj.getClass();\n                    if (keyType instanceof Class) {\n                        keyClazz = (Class<?>) keyType;\n                    }\n                    Object value = realize1(obj, keyClazz, keyType, mapGeneric, history);\n                    dest.add(value);\n                }\n                return dest;\n            }\n        }\n\n        if (pojo instanceof Map<?, ?> && type != null) {\n            Object className = ((Map<Object, Object>) pojo).get(\"class\");\n            if (className instanceof String) {\n                if (!CLASS_NOT_FOUND_CACHE.containsKey(className)) {\n                    try {\n                        type = DefaultSerializeClassChecker.getInstance()\n                                .loadClass(ClassUtils.getClassLoader(), (String) className);\n                    } catch (ClassNotFoundException e) {\n                        CLASS_NOT_FOUND_CACHE.put((String) className, NOT_FOUND_VALUE);\n                    }\n                }\n            }\n\n            // special logic for enum\n            if (type.isEnum()) {\n                Object name = ((Map<Object, Object>) pojo).get(\"name\");\n                if (name != null) {\n                    if (!(name instanceof String)) {\n                        throw new IllegalArgumentException(\"`name` filed should be string!\");\n                    } else {\n                        return Enum.valueOf((Class<Enum>) type, (String) name);\n                    }\n                }\n            }\n            Map<Object, Object> map;\n            // when return type is not the subclass of return type from the signature and not an interface\n            if (!type.isInterface() && !type.isAssignableFrom(pojo.getClass())) {\n                try {\n                    map = (Map<Object, Object>) type.getDeclaredConstructor().newInstance();\n                    Map<Object, Object> mapPojo = (Map<Object, Object>) pojo;\n                    map.putAll(mapPojo);\n                    if (GENERIC_WITH_CLZ) {\n                        map.remove(\"class\");\n                    }\n                } catch (Exception e) {\n                    // ignore error\n                    map = (Map<Object, Object>) pojo;\n                }\n            } else {\n                map = (Map<Object, Object>) pojo;\n            }\n\n            if (Map.class.isAssignableFrom(type) || type == Object.class) {\n                final Map<Object, Object> result;\n                // fix issue#5939\n                Type mapKeyType = getKeyTypeForMap(map.getClass());\n                Type typeKeyType = getGenericClassByIndex(genericType, 0);\n                boolean typeMismatch = mapKeyType instanceof Class\n                        && typeKeyType instanceof Class\n                        && !typeKeyType.getTypeName().equals(mapKeyType.getTypeName());\n                if (typeMismatch) {\n                    result = createMap(new HashMap(0));\n                } else {\n                    result = createMap(map);\n                }\n\n                history.put(pojo, result);\n                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                    Type keyType = getGenericClassByIndex(genericType, 0);\n                    Type valueType = getGenericClassByIndex(genericType, 1);\n                    Class<?> keyClazz;\n                    if (keyType instanceof Class) {\n                        keyClazz = (Class<?>) keyType;\n                    } else if (keyType instanceof ParameterizedType) {\n                        keyClazz = (Class<?>) ((ParameterizedType) keyType).getRawType();\n                    } else {\n                        keyClazz =\n                                entry.getKey() == null ? null : entry.getKey().getClass();\n                    }\n                    Class<?> valueClazz;\n                    if (valueType instanceof Class) {\n                        valueClazz = (Class<?>) valueType;\n                    } else if (valueType instanceof ParameterizedType) {\n                        valueClazz = (Class<?>) ((ParameterizedType) valueType).getRawType();\n                    } else {\n                        valueClazz = entry.getValue() == null\n                                ? null\n                                : entry.getValue().getClass();\n                    }\n\n                    Object key = keyClazz == null\n                            ? entry.getKey()\n                            : realize1(entry.getKey(), keyClazz, keyType, mapGeneric, history);\n                    Object value = valueClazz == null\n                            ? entry.getValue()\n                            : realize1(entry.getValue(), valueClazz, valueType, mapGeneric, history);\n                    result.put(key, value);\n                }\n                return result;\n            } else if (type.isInterface()) {\n                Object dest = Proxy.newProxyInstance(\n                        Thread.currentThread().getContextClassLoader(),\n                        new Class<?>[] {type},\n                        new PojoInvocationHandler(map));\n                history.put(pojo, dest);\n                return dest;\n            } else {\n                Object dest;\n                if (Throwable.class.isAssignableFrom(type)) {\n                    Object message = map.get(\"message\");\n                    if (message instanceof String) {\n                        dest = newThrowableInstance(type, (String) message);\n                    } else {\n                        dest = newInstance(type);\n                    }\n                } else {\n                    dest = newInstance(type);\n                }\n\n                history.put(pojo, dest);\n\n                for (Map.Entry<Object, Object> entry : map.entrySet()) {\n                    Object key = entry.getKey();\n                    if (key instanceof String) {\n                        String name = (String) key;\n                        Object value = entry.getValue();\n                        if (value != null) {\n                            Method method = getSetterMethod(dest.getClass(), name, value.getClass());\n                            Field field = getAndCacheField(dest.getClass(), name);\n                            if (method != null) {\n                                if (!method.isAccessible()) {\n                                    method.setAccessible(true);\n                                }\n                                Type containType = Optional.ofNullable(field)\n                                        .map(Field::getGenericType)\n                                        .map(Type::getTypeName)\n                                        .map(mapGeneric::get)\n                                        .orElse(null);\n                                if (containType != null) {\n                                    // is generic\n                                    if (containType instanceof ParameterizedType) {\n                                        value = realize1(\n                                                value,\n                                                (Class<?>) ((ParameterizedType) containType).getRawType(),\n                                                containType,\n                                                mapGeneric,\n                                                history);\n                                    } else if (containType instanceof Class) {\n                                        value = realize1(\n                                                value, (Class<?>) containType, containType, mapGeneric, history);\n                                    } else {\n                                        Type ptype = method.getGenericParameterTypes()[0];\n                                        value = realize1(\n                                                value, method.getParameterTypes()[0], ptype, mapGeneric, history);\n                                    }\n                                } else {\n                                    Type ptype = method.getGenericParameterTypes()[0];\n                                    value = realize1(value, method.getParameterTypes()[0], ptype, mapGeneric, history);\n                                }\n                                try {\n                                    method.invoke(dest, value);\n                                } catch (Exception e) {\n                                    String exceptionDescription = \"Failed to set pojo \"\n                                            + dest.getClass().getSimpleName() + \" property \" + name + \" value \"\n                                            + value.getClass() + \", cause: \" + e.getMessage();\n                                    logger.error(COMMON_REFLECTIVE_OPERATION_FAILED, \"\", \"\", exceptionDescription, e);\n                                    throw new RuntimeException(exceptionDescription, e);\n                                }\n                            } else if (field != null) {\n                                value = realize1(value, field.getType(), field.getGenericType(), mapGeneric, history);\n                                try {\n                                    field.set(dest, value);\n                                } catch (IllegalAccessException e) {\n                                    throw new RuntimeException(\n                                            \"Failed to set field \" + name + \" of pojo \"\n                                                    + dest.getClass().getName() + \" : \" + e.getMessage(),\n                                            e);\n                                }\n                            }\n                        }\n                    }\n                }\n                return dest;\n            }\n        }\n        return pojo;\n    }\n\n    /**\n     * Get key type for {@link Map} directly implemented by {@code clazz}.\n     * If {@code clazz} does not implement {@link Map} directly, return {@code null}.\n     *\n     * @param clazz {@link Class}\n     * @return Return String.class for {@link com.alibaba.fastjson.JSONObject}\n     */\n    private static Type getKeyTypeForMap(Class<?> clazz) {\n        Type[] interfaces = clazz.getGenericInterfaces();\n        if (!ArrayUtils.isEmpty(interfaces)) {\n            for (Type type : interfaces) {\n                if (type instanceof ParameterizedType) {\n                    ParameterizedType t = (ParameterizedType) type;\n                    if (\"java.util.Map\".equals(t.getRawType().getTypeName())) {\n                        return t.getActualTypeArguments()[0];\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get parameterized type\n     *\n     * @param genericType generic type\n     * @param index       index of the target parameterized type\n     * @return Return Person.class for List<Person>, return Person.class for Map<String, Person> when index=0\n     */\n    private static Type getGenericClassByIndex(Type genericType, int index) {\n        Type clazz = null;\n        // find parameterized type\n        if (genericType instanceof ParameterizedType) {\n            ParameterizedType t = (ParameterizedType) genericType;\n            Type[] types = t.getActualTypeArguments();\n            clazz = types[index];\n        }\n        return clazz;\n    }\n\n    private static Object newThrowableInstance(Class<?> cls, String message) {\n        try {\n            Constructor<?> messagedConstructor = cls.getDeclaredConstructor(String.class);\n            return messagedConstructor.newInstance(message);\n        } catch (Exception t) {\n            return newInstance(cls);\n        }\n    }\n\n    private static Object newInstance(Class<?> cls) {\n        try {\n            return cls.getDeclaredConstructor().newInstance();\n        } catch (Exception t) {\n            Constructor<?>[] constructors = cls.getDeclaredConstructors();\n            /*\n             From Javadoc java.lang.Class#getDeclaredConstructors\n             This method returns an array of Constructor objects reflecting all the constructors\n             declared by the class represented by this Class object.\n             This method returns an array of length 0,\n             if this Class object represents an interface, a primitive type, an array class, or void.\n            */\n            if (constructors.length == 0) {\n                throw new RuntimeException(\"Illegal constructor: \" + cls.getName());\n            }\n            Throwable lastError = null;\n            Arrays.sort(constructors, Comparator.comparingInt(a -> a.getParameterTypes().length));\n            for (Constructor<?> constructor : constructors) {\n                try {\n                    constructor.setAccessible(true);\n                    Object[] parameters = Arrays.stream(constructor.getParameterTypes())\n                            .map(PojoUtils::getDefaultValue)\n                            .toArray();\n                    return constructor.newInstance(parameters);\n                } catch (Exception e) {\n                    lastError = e;\n                }\n            }\n            throw new RuntimeException(lastError.getMessage(), lastError);\n        }\n    }\n\n    /**\n     * return init value\n     *\n     * @param parameterType\n     * @return\n     */\n    private static Object getDefaultValue(Class<?> parameterType) {\n        if (\"char\".equals(parameterType.getName())) {\n            return Character.MIN_VALUE;\n        }\n        if (\"boolean\".equals(parameterType.getName())) {\n            return false;\n        }\n        if (\"byte\".equals(parameterType.getName())) {\n            return (byte) 0;\n        }\n        if (\"short\".equals(parameterType.getName())) {\n            return (short) 0;\n        }\n        return parameterType.isPrimitive() ? 0 : null;\n    }\n\n    private static Method getSetterMethod(Class<?> cls, String property, Class<?> valueCls) {\n        String name = \"set\" + property.substring(0, 1).toUpperCase() + property.substring(1);\n        Method method = NAME_METHODS_CACHE.get(cls.getName() + \".\" + name + \"(\" + valueCls.getName() + \")\");\n        if (method == null) {\n            try {\n                method = cls.getMethod(name, valueCls);\n            } catch (NoSuchMethodException e) {\n                for (Method m : cls.getMethods()) {\n                    if (ReflectUtils.isBeanPropertyWriteMethod(m) && m.getName().equals(name)) {\n                        method = m;\n                        break;\n                    }\n                }\n            }\n            if (method != null) {\n                NAME_METHODS_CACHE.put(cls.getName() + \".\" + name + \"(\" + valueCls.getName() + \")\", method);\n            }\n        }\n        return method;\n    }\n\n    private static Field getAndCacheField(Class<?> cls, String fieldName) {\n        Field result;\n        if (CLASS_FIELD_CACHE.containsKey(cls) && CLASS_FIELD_CACHE.get(cls).containsKey(fieldName)) {\n            return CLASS_FIELD_CACHE.get(cls).get(fieldName);\n        }\n\n        result = getField(cls, fieldName);\n\n        if (result != null) {\n            ConcurrentMap<String, Field> fields =\n                    CLASS_FIELD_CACHE.computeIfAbsent(cls, k -> new ConcurrentHashMap<>());\n            fields.putIfAbsent(fieldName, result);\n        }\n        return result;\n    }\n\n    private static Field getField(Class<?> cls, String fieldName) {\n        Field result = null;\n        for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {\n            try {\n                result = acls.getDeclaredField(fieldName);\n                if (!Modifier.isPublic(result.getModifiers())) {\n                    result.setAccessible(true);\n                }\n            } catch (NoSuchFieldException e) {\n            }\n        }\n        if (result == null && cls != null) {\n            for (Field field : cls.getFields()) {\n                if (fieldName.equals(field.getName()) && ReflectUtils.isPublicInstanceField(field)) {\n                    result = field;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static boolean isPojo(Class<?> cls) {\n        return !ReflectUtils.isPrimitives(cls)\n                && !Collection.class.isAssignableFrom(cls)\n                && !Map.class.isAssignableFrom(cls);\n    }\n\n    /**\n     * Update the property if absent\n     *\n     * @param getterMethod the getter method\n     * @param setterMethod the setter method\n     * @param newValue     the new value\n     * @param <T>          the value type\n     * @since 2.7.8\n     */\n    public static <T> void updatePropertyIfAbsent(Supplier<T> getterMethod, Consumer<T> setterMethod, T newValue) {\n        if (newValue != null && getterMethod.get() == null) {\n            setterMethod.accept(newValue);\n        }\n    }\n\n    /**\n     * convert map to a specific class instance\n     *\n     * @param map map wait for convert\n     * @param cls the specified class\n     * @param <T> the type of {@code cls}\n     * @return class instance declare in param {@code cls}\n     * @throws ReflectiveOperationException if the instance creation is failed\n     * @since 2.7.10\n     */\n    public static <T> T mapToPojo(Map<String, Object> map, Class<T> cls) throws ReflectiveOperationException {\n        T instance = cls.getDeclaredConstructor().newInstance();\n        Map<String, Field> beanPropertyFields = ReflectUtils.getBeanPropertyFields(cls);\n        for (Map.Entry<String, Field> entry : beanPropertyFields.entrySet()) {\n            String name = entry.getKey();\n            Field field = entry.getValue();\n            Object mapObject = map.get(name);\n            if (mapObject == null) {\n                continue;\n            }\n\n            Type type = field.getGenericType();\n            Object fieldObject = getFieldObject(mapObject, type);\n            field.set(instance, fieldObject);\n        }\n\n        return instance;\n    }\n\n    private static Object getFieldObject(Object mapObject, Type fieldType) throws ReflectiveOperationException {\n        if (fieldType instanceof Class<?>) {\n            return convertClassType(mapObject, (Class<?>) fieldType);\n        } else if (fieldType instanceof ParameterizedType) {\n            return convertParameterizedType(mapObject, (ParameterizedType) fieldType);\n        } else if (fieldType instanceof GenericArrayType\n                || fieldType instanceof TypeVariable<?>\n                || fieldType instanceof WildcardType) {\n            // ignore these type currently\n            return null;\n        } else {\n            throw new IllegalArgumentException(\"Unrecognized Type: \" + fieldType.toString());\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Object convertClassType(Object mapObject, Class<?> type) throws ReflectiveOperationException {\n        if (type.isPrimitive() || isAssignableFrom(type, mapObject.getClass())) {\n            return mapObject;\n        } else if (Objects.equals(type, String.class) && CLASS_CAN_BE_STRING.contains(mapObject.getClass())) {\n            // auto convert specified type to string\n            return mapObject.toString();\n        } else if (mapObject instanceof Map) {\n            return mapToPojo((Map<String, Object>) mapObject, type);\n        } else {\n            // type didn't match and mapObject is not another Map struct.\n            // we just ignore this situation.\n            return null;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static Object convertParameterizedType(Object mapObject, ParameterizedType type)\n            throws ReflectiveOperationException {\n        Type rawType = type.getRawType();\n        if (!isAssignableFrom((Class<?>) rawType, mapObject.getClass())) {\n            return null;\n        }\n\n        Type[] actualTypeArguments = type.getActualTypeArguments();\n        if (isAssignableFrom(Map.class, (Class<?>) rawType)) {\n            Map<Object, Object> map = (Map<Object, Object>)\n                    mapObject.getClass().getDeclaredConstructor().newInstance();\n            for (Map.Entry<Object, Object> entry : ((Map<Object, Object>) mapObject).entrySet()) {\n                Object key = getFieldObject(entry.getKey(), actualTypeArguments[0]);\n                Object value = getFieldObject(entry.getValue(), actualTypeArguments[1]);\n                map.put(key, value);\n            }\n\n            return map;\n        } else if (isAssignableFrom(Collection.class, (Class<?>) rawType)) {\n            Collection<Object> collection = (Collection<Object>)\n                    mapObject.getClass().getDeclaredConstructor().newInstance();\n            for (Object m : (Iterable<?>) mapObject) {\n                Object ele = getFieldObject(m, actualTypeArguments[0]);\n                collection.add(ele);\n            }\n\n            return collection;\n        } else {\n            // ignore other type currently\n            return null;\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 146,
        "dataset": "codeql",
        "filepath": "dubbo-common/src/main/java/org/apache/dubbo/common/utils/PojoUtils.java",
        "line": 615,
        "sink": "java.lang.reflect.Field.set",
        "source": "-",
        "sourceLine": 615,
        "qualifier": "Call to java.lang.reflect.Field.set with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.reflect.Field.set with untrusted data from [msg : String](2).",
        "line_number": 615,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 147
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 147
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 147
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 147
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java#L116",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.dubbo.container.page;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.alibaba.dubbo.common.Constants;\n\n/**\n * ResourceServlet\n */\npublic class ResourceFilter implements Filter {\n\n    private static final String CLASSPATH_PREFIX = \"classpath:\";\n\n    private final long start = System.currentTimeMillis();\n\n    private final List<String> resources = new ArrayList<>();\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n        String config = filterConfig.getInitParameter(\"resources\");\n        if (config != null && config.length() > 0) {\n            String[] configs = Constants.COMMA_SPLIT_PATTERN.split(config);\n            for (String c : configs) {\n                if (c != null && c.length() > 0) {\n                    c = c.replace('\\\\', '/');\n                    if (c.endsWith(\"/\")) {\n                        c = c.substring(0, c.length() - 1);\n                    }\n                    resources.add(c);\n                }\n            }\n        }\n    }\n\n    public void destroy() {}\n\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)\n            throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) req;\n        HttpServletResponse response = (HttpServletResponse) res;\n        if (response.isCommitted()) {\n            return;\n        }\n        String uri = request.getRequestURI();\n        String context = request.getContextPath();\n        if (uri.endsWith(\"/favicon.ico\")) {\n            uri = \"/favicon.ico\";\n        } else if (context != null && !\"/\".equals(context)) {\n            uri = uri.substring(context.length());\n        }\n        if (!uri.startsWith(\"/\")) {\n            uri = \"/\" + uri;\n        }\n        long lastModified = getLastModified(uri);\n        long since = request.getDateHeader(\"If-Modified-Since\");\n        if (since >= lastModified) {\n            response.sendError(HttpServletResponse.SC_NOT_MODIFIED);\n            return;\n        }\n        byte[] data;\n        InputStream input = getInputStream(uri);\n        if (input == null) {\n            chain.doFilter(req, res);\n            return;\n        }\n        try {\n            ByteArrayOutputStream output = new ByteArrayOutputStream();\n            byte[] buffer = new byte[8192];\n            int n = 0;\n            while (-1 != (n = input.read(buffer))) {\n                output.write(buffer, 0, n);\n            }\n            data = output.toByteArray();\n        } finally {\n            input.close();\n        }\n        response.setDateHeader(\"Last-Modified\", lastModified);\n        OutputStream output = response.getOutputStream();\n        output.write(data);\n        output.flush();\n    }\n\n    private boolean isFile(String path) {\n        return path.startsWith(\"/\") || path.indexOf(\":\") <= 1;\n    }\n\n    private long getLastModified(String uri) {\n        for (String resource : resources) {\n            if (resource != null && resource.length() > 0) {\n                String path = resource + uri;\n                if (isFile(path)) {\n                    File file = new File(path);\n                    if (file.exists()) {\n                        return file.lastModified();\n                    }\n                }\n            }\n        }\n        return start;\n    }\n\n    private InputStream getInputStream(String uri) {\n        for (String resource : resources) {\n            String path = resource + uri;\n            try {\n                if (isFile(path)) {\n                    return new FileInputStream(path);\n                } else if (path.startsWith(CLASSPATH_PREFIX)) {\n                    return Thread.currentThread()\n                            .getContextClassLoader()\n                            .getResourceAsStream(path.substring(CLASSPATH_PREFIX.length()));\n                } else {\n                    return new URL(path).openStream();\n                }\n            } catch (IOException e) {\n            }\n        }\n        return null;\n    }\n}\n",
        "methodName": null,
        "exampleID": 148,
        "dataset": "codeql",
        "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
        "line": 116,
        "sink": "java.lang.String.indexOf",
        "source": "-",
        "sourceLine": 116,
        "qualifier": "Call to java.lang.String.indexOf with untrusted data from [getRequestURI(...) : String](1).",
        "line_number": 116,
        "steps": [
            {
                "line": 76,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "methodName": null,
                "exampleID": 149
            },
            {
                "line": 76,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "methodName": null,
                "exampleID": 149
            },
            {
                "line": 76,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "methodName": null,
                "exampleID": 149
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java#L126",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.dubbo.container.page;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.alibaba.dubbo.common.Constants;\n\n/**\n * ResourceServlet\n */\npublic class ResourceFilter implements Filter {\n\n    private static final String CLASSPATH_PREFIX = \"classpath:\";\n\n    private final long start = System.currentTimeMillis();\n\n    private final List<String> resources = new ArrayList<>();\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n        String config = filterConfig.getInitParameter(\"resources\");\n        if (config != null && config.length() > 0) {\n            String[] configs = Constants.COMMA_SPLIT_PATTERN.split(config);\n            for (String c : configs) {\n                if (c != null && c.length() > 0) {\n                    c = c.replace('\\\\', '/');\n                    if (c.endsWith(\"/\")) {\n                        c = c.substring(0, c.length() - 1);\n                    }\n                    resources.add(c);\n                }\n            }\n        }\n    }\n\n    public void destroy() {}\n\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)\n            throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) req;\n        HttpServletResponse response = (HttpServletResponse) res;\n        if (response.isCommitted()) {\n            return;\n        }\n        String uri = request.getRequestURI();\n        String context = request.getContextPath();\n        if (uri.endsWith(\"/favicon.ico\")) {\n            uri = \"/favicon.ico\";\n        } else if (context != null && !\"/\".equals(context)) {\n            uri = uri.substring(context.length());\n        }\n        if (!uri.startsWith(\"/\")) {\n            uri = \"/\" + uri;\n        }\n        long lastModified = getLastModified(uri);\n        long since = request.getDateHeader(\"If-Modified-Since\");\n        if (since >= lastModified) {\n            response.sendError(HttpServletResponse.SC_NOT_MODIFIED);\n            return;\n        }\n        byte[] data;\n        InputStream input = getInputStream(uri);\n        if (input == null) {\n            chain.doFilter(req, res);\n            return;\n        }\n        try {\n            ByteArrayOutputStream output = new ByteArrayOutputStream();\n            byte[] buffer = new byte[8192];\n            int n = 0;\n            while (-1 != (n = input.read(buffer))) {\n                output.write(buffer, 0, n);\n            }\n            data = output.toByteArray();\n        } finally {\n            input.close();\n        }\n        response.setDateHeader(\"Last-Modified\", lastModified);\n        OutputStream output = response.getOutputStream();\n        output.write(data);\n        output.flush();\n    }\n\n    private boolean isFile(String path) {\n        return path.startsWith(\"/\") || path.indexOf(\":\") <= 1;\n    }\n\n    private long getLastModified(String uri) {\n        for (String resource : resources) {\n            if (resource != null && resource.length() > 0) {\n                String path = resource + uri;\n                if (isFile(path)) {\n                    File file = new File(path);\n                    if (file.exists()) {\n                        return file.lastModified();\n                    }\n                }\n            }\n        }\n        return start;\n    }\n\n    private InputStream getInputStream(String uri) {\n        for (String resource : resources) {\n            String path = resource + uri;\n            try {\n                if (isFile(path)) {\n                    return new FileInputStream(path);\n                } else if (path.startsWith(CLASSPATH_PREFIX)) {\n                    return Thread.currentThread()\n                            .getContextClassLoader()\n                            .getResourceAsStream(path.substring(CLASSPATH_PREFIX.length()));\n                } else {\n                    return new URL(path).openStream();\n                }\n            } catch (IOException e) {\n            }\n        }\n        return null;\n    }\n}\n",
        "methodName": null,
        "exampleID": 150,
        "dataset": "codeql",
        "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
        "line": 126,
        "sink": "java.io.File.lastModified",
        "source": "-",
        "sourceLine": 126,
        "qualifier": "Call to java.io.File.lastModified with untrusted data from [getRequestURI(...) : String](1).",
        "line_number": 126,
        "steps": [
            {
                "line": 76,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "methodName": null,
                "exampleID": 151
            },
            {
                "line": 76,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "methodName": null,
                "exampleID": 151
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java#L145",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.dubbo.container.page;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.alibaba.dubbo.common.Constants;\n\n/**\n * ResourceServlet\n */\npublic class ResourceFilter implements Filter {\n\n    private static final String CLASSPATH_PREFIX = \"classpath:\";\n\n    private final long start = System.currentTimeMillis();\n\n    private final List<String> resources = new ArrayList<>();\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n        String config = filterConfig.getInitParameter(\"resources\");\n        if (config != null && config.length() > 0) {\n            String[] configs = Constants.COMMA_SPLIT_PATTERN.split(config);\n            for (String c : configs) {\n                if (c != null && c.length() > 0) {\n                    c = c.replace('\\\\', '/');\n                    if (c.endsWith(\"/\")) {\n                        c = c.substring(0, c.length() - 1);\n                    }\n                    resources.add(c);\n                }\n            }\n        }\n    }\n\n    public void destroy() {}\n\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)\n            throws IOException, ServletException {\n        HttpServletRequest request = (HttpServletRequest) req;\n        HttpServletResponse response = (HttpServletResponse) res;\n        if (response.isCommitted()) {\n            return;\n        }\n        String uri = request.getRequestURI();\n        String context = request.getContextPath();\n        if (uri.endsWith(\"/favicon.ico\")) {\n            uri = \"/favicon.ico\";\n        } else if (context != null && !\"/\".equals(context)) {\n            uri = uri.substring(context.length());\n        }\n        if (!uri.startsWith(\"/\")) {\n            uri = \"/\" + uri;\n        }\n        long lastModified = getLastModified(uri);\n        long since = request.getDateHeader(\"If-Modified-Since\");\n        if (since >= lastModified) {\n            response.sendError(HttpServletResponse.SC_NOT_MODIFIED);\n            return;\n        }\n        byte[] data;\n        InputStream input = getInputStream(uri);\n        if (input == null) {\n            chain.doFilter(req, res);\n            return;\n        }\n        try {\n            ByteArrayOutputStream output = new ByteArrayOutputStream();\n            byte[] buffer = new byte[8192];\n            int n = 0;\n            while (-1 != (n = input.read(buffer))) {\n                output.write(buffer, 0, n);\n            }\n            data = output.toByteArray();\n        } finally {\n            input.close();\n        }\n        response.setDateHeader(\"Last-Modified\", lastModified);\n        OutputStream output = response.getOutputStream();\n        output.write(data);\n        output.flush();\n    }\n\n    private boolean isFile(String path) {\n        return path.startsWith(\"/\") || path.indexOf(\":\") <= 1;\n    }\n\n    private long getLastModified(String uri) {\n        for (String resource : resources) {\n            if (resource != null && resource.length() > 0) {\n                String path = resource + uri;\n                if (isFile(path)) {\n                    File file = new File(path);\n                    if (file.exists()) {\n                        return file.lastModified();\n                    }\n                }\n            }\n        }\n        return start;\n    }\n\n    private InputStream getInputStream(String uri) {\n        for (String resource : resources) {\n            String path = resource + uri;\n            try {\n                if (isFile(path)) {\n                    return new FileInputStream(path);\n                } else if (path.startsWith(CLASSPATH_PREFIX)) {\n                    return Thread.currentThread()\n                            .getContextClassLoader()\n                            .getResourceAsStream(path.substring(CLASSPATH_PREFIX.length()));\n                } else {\n                    return new URL(path).openStream();\n                }\n            } catch (IOException e) {\n            }\n        }\n        return null;\n    }\n}\n",
        "methodName": null,
        "exampleID": 152,
        "dataset": "codeql",
        "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
        "line": 145,
        "sink": "java.net.URL.openStream",
        "source": "-",
        "sourceLine": 145,
        "qualifier": "Call to java.net.URL.openStream with untrusted data from [getRequestURI(...) : String](1).",
        "line_number": 145,
        "steps": [
            {
                "line": 76,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "methodName": null,
                "exampleID": 153
            },
            {
                "line": 76,
                "source": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "filepath": "dubbo-compatible/src/main/java/com/alibaba/dubbo/container/page/ResourceFilter.java",
                "methodName": null,
                "exampleID": 153
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java#L83",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.metadata.rest;\n\nimport org.apache.dubbo.config.annotation.DubboService;\n\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.FormParam;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.HeaderParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.QueryParam;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * JAX-RS {@link RestService}\n */\n@DubboService(\n        version = \"3.0.0\",\n        protocol = {\"dubbo\", \"rest\"},\n        group = \"standard\")\n@Path(\"/\")\npublic class StandardRestService implements RestService {\n\n    @Override\n    @Path(\"param\")\n    @GET\n    public String param(@QueryParam(\"param\") String param) {\n        return param;\n    }\n\n    @Override\n    @Path(\"params\")\n    @POST\n    public String params(@QueryParam(\"a\") int a, @QueryParam(\"b\") String b) {\n        return a + b;\n    }\n\n    @Override\n    @Path(\"headers\")\n    @GET\n    public String headers(\n            @HeaderParam(\"h\") String header, @HeaderParam(\"h2\") String header2, @QueryParam(\"v\") Integer param) {\n        String result = header + \" , \" + header2 + \" , \" + param;\n        return result;\n    }\n\n    @Override\n    @Path(\"path-variables/{p1}/{p2}\")\n    @GET\n    public String pathVariables(\n            @PathParam(\"p1\") String path1, @PathParam(\"p2\") String path2, @QueryParam(\"v\") String param) {\n        String result = path1 + \" , \" + path2 + \" , \" + param;\n        return result;\n    }\n\n    // @CookieParam does not support : https://github.com/OpenFeign/feign/issues/913\n    // @CookieValue also does not support\n\n    @Override\n    @Path(\"form\")\n    @POST\n    public String form(@FormParam(\"f\") String form) {\n        return String.valueOf(form);\n    }\n\n    @Override\n    @Path(\"request/body/map\")\n    @POST\n    @Produces(\"application/json;charset=UTF-8\")\n    public User requestBodyMap(Map<String, Object> data, @QueryParam(\"param\") String param) {\n        User user = new User();\n        user.setId(((Integer) data.get(\"id\")).longValue());\n        user.setName((String) data.get(\"name\"));\n        user.setAge((Integer) data.get(\"age\"));\n        return user;\n    }\n\n    @Path(\"request/body/user\")\n    @POST\n    @Override\n    @Consumes(\"application/json;charset=UTF-8\")\n    public Map<String, Object> requestBodyUser(User user) {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"id\", user.getId());\n        map.put(\"name\", user.getName());\n        map.put(\"age\", user.getAge());\n        return map;\n    }\n}\n",
        "methodName": null,
        "exampleID": 154,
        "dataset": "codeql",
        "filepath": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
        "line": 83,
        "sink": "java.lang.String.valueOf",
        "source": "-",
        "sourceLine": 83,
        "qualifier": "Call to java.lang.String.valueOf with untrusted data from [form : String](1).\nCall to java.lang.String.valueOf with untrusted data from [form : String](2).\nCall to java.lang.String.valueOf with untrusted data from [form : String](3).\nCall to java.lang.String.valueOf with untrusted data from [form : String](1).\nCall to java.lang.String.valueOf with untrusted data from [form : String](1).",
        "line_number": 83,
        "steps": [
            {
                "line": 82,
                "source": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "filepath": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "methodName": null,
                "exampleID": 155
            },
            {
                "line": 83,
                "source": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "filepath": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "methodName": null,
                "exampleID": 155
            },
            {
                "line": 82,
                "source": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "filepath": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "methodName": null,
                "exampleID": 155
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java#L74",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.metadata.rest;\n\nimport org.apache.dubbo.config.annotation.DubboService;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.http.MediaType;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestHeader;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * Spring MVC {@link RestService}\n *\n * @since 2.7.6\n */\n@DubboService(version = \"2.0.0\", group = \"spring\")\n@RestController\npublic class SpringRestService implements RestService {\n\n    @Override\n    @GetMapping(value = \"/param\")\n    public String param(@RequestParam(defaultValue = \"value-param\") String param) {\n        return null;\n    }\n\n    @Override\n    @PostMapping(\"/params\")\n    public String params(\n            @RequestParam(defaultValue = \"value-a\") int a, @RequestParam(defaultValue = \"value-b\") String b) {\n        return null;\n    }\n\n    @Override\n    @GetMapping(\"/headers\")\n    public String headers(\n            @RequestHeader(name = \"h\", defaultValue = \"value-h\") String header,\n            @RequestHeader(name = \"h2\", defaultValue = \"value-h2\") String header2,\n            @RequestParam(value = \"v\", defaultValue = \"1\") Integer param) {\n        return null;\n    }\n\n    @Override\n    @GetMapping(\"/path-variables/{p1}/{p2}\")\n    public String pathVariables(\n            @PathVariable(\"p1\") String path1, @PathVariable(\"p2\") String path2, @RequestParam(\"v\") String param) {\n        return null;\n    }\n\n    @Override\n    @PostMapping(\"/form\")\n    public String form(@RequestParam(\"f\") String form) {\n        return String.valueOf(form);\n    }\n\n    @Override\n    @PostMapping(value = \"/request/body/map\", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)\n    public User requestBodyMap(@RequestBody Map<String, Object> data, @RequestParam(\"param\") String param) {\n        User user = new User();\n        user.setId(((Integer) data.get(\"id\")).longValue());\n        user.setName((String) data.get(\"name\"));\n        user.setAge((Integer) data.get(\"age\"));\n        return user;\n    }\n\n    @PostMapping(value = \"/request/body/user\", consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)\n    @Override\n    public Map<String, Object> requestBodyUser(@RequestBody User user) {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"id\", user.getId());\n        map.put(\"name\", user.getName());\n        map.put(\"age\", user.getAge());\n        return map;\n    }\n}\n",
        "methodName": null,
        "exampleID": 156,
        "dataset": "codeql",
        "filepath": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
        "line": 74,
        "sink": "java.lang.String.valueOf",
        "source": "-",
        "sourceLine": 74,
        "qualifier": "Call to java.lang.String.valueOf with untrusted data from [form : String](1).\nCall to java.lang.String.valueOf with untrusted data from [form : String](2).\nCall to java.lang.String.valueOf with untrusted data from [form : String](3).\nCall to java.lang.String.valueOf with untrusted data from [form : String](1).\nCall to java.lang.String.valueOf with untrusted data from [form : String](1).",
        "line_number": 74,
        "steps": [
            {
                "line": 73,
                "source": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "filepath": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "methodName": null,
                "exampleID": 157
            },
            {
                "line": 73,
                "source": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "filepath": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "methodName": null,
                "exampleID": 157
            },
            {
                "line": 73,
                "source": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "filepath": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "methodName": null,
                "exampleID": 157
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java#L74",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.metadata.rest;\n\nimport org.apache.dubbo.config.annotation.DubboService;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.http.MediaType;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestHeader;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * Spring MVC {@link RestService}\n *\n * @since 2.7.6\n */\n@DubboService(version = \"2.0.0\", group = \"spring\")\n@RestController\npublic class SpringRestService implements RestService {\n\n    @Override\n    @GetMapping(value = \"/param\")\n    public String param(@RequestParam(defaultValue = \"value-param\") String param) {\n        return null;\n    }\n\n    @Override\n    @PostMapping(\"/params\")\n    public String params(\n            @RequestParam(defaultValue = \"value-a\") int a, @RequestParam(defaultValue = \"value-b\") String b) {\n        return null;\n    }\n\n    @Override\n    @GetMapping(\"/headers\")\n    public String headers(\n            @RequestHeader(name = \"h\", defaultValue = \"value-h\") String header,\n            @RequestHeader(name = \"h2\", defaultValue = \"value-h2\") String header2,\n            @RequestParam(value = \"v\", defaultValue = \"1\") Integer param) {\n        return null;\n    }\n\n    @Override\n    @GetMapping(\"/path-variables/{p1}/{p2}\")\n    public String pathVariables(\n            @PathVariable(\"p1\") String path1, @PathVariable(\"p2\") String path2, @RequestParam(\"v\") String param) {\n        return null;\n    }\n\n    @Override\n    @PostMapping(\"/form\")\n    public String form(@RequestParam(\"f\") String form) {\n        return String.valueOf(form);\n    }\n\n    @Override\n    @PostMapping(value = \"/request/body/map\", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)\n    public User requestBodyMap(@RequestBody Map<String, Object> data, @RequestParam(\"param\") String param) {\n        User user = new User();\n        user.setId(((Integer) data.get(\"id\")).longValue());\n        user.setName((String) data.get(\"name\"));\n        user.setAge((Integer) data.get(\"age\"));\n        return user;\n    }\n\n    @PostMapping(value = \"/request/body/user\", consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)\n    @Override\n    public Map<String, Object> requestBodyUser(@RequestBody User user) {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"id\", user.getId());\n        map.put(\"name\", user.getName());\n        map.put(\"age\", user.getAge());\n        return map;\n    }\n\n    @PostMapping(value = \"/request/body/user/json\", consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)\n    @Override\n    public void noAnnotationJsonBody(User user) {}\n\n    @PostMapping(value = \"/request/body/user/form\", consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n    @Override\n    public void noAnnotationFormBody(User user) {}\n\n    @PostMapping(value = \"/request/body/user/param\")\n    @Override\n    public void noAnnotationParam(String text) {}\n}\n",
        "methodName": null,
        "exampleID": 158,
        "dataset": "codeql",
        "filepath": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
        "line": 74,
        "sink": "java.lang.String.valueOf",
        "source": "-",
        "sourceLine": 74,
        "qualifier": "Call to java.lang.String.valueOf with untrusted data from [form : String](1).\nCall to java.lang.String.valueOf with untrusted data from [form : String](2).\nCall to java.lang.String.valueOf with untrusted data from [form : String](3).\nCall to java.lang.String.valueOf with untrusted data from [form : String](1).\nCall to java.lang.String.valueOf with untrusted data from [form : String](1).",
        "line_number": 74,
        "steps": [
            {
                "line": 73,
                "source": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "filepath": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "methodName": null,
                "exampleID": 159
            },
            {
                "line": 73,
                "source": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "filepath": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "methodName": null,
                "exampleID": 159
            },
            {
                "line": 73,
                "source": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "filepath": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "methodName": null,
                "exampleID": 159
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java#L84",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.metadata.rest;\n\nimport org.apache.dubbo.config.annotation.DubboService;\n\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.FormParam;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.HeaderParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.QueryParam;\nimport javax.ws.rs.core.MediaType;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * JAX-RS {@link RestService}\n */\n@DubboService(\n        version = \"3.0.0\",\n        protocol = {\"dubbo\", \"rest\"},\n        group = \"standard\")\n@Path(\"/\")\npublic class StandardRestService implements RestService {\n\n    @Override\n    @Path(\"param\")\n    @GET\n    public String param(@QueryParam(\"param\") String param) {\n        return param;\n    }\n\n    @Override\n    @Path(\"params\")\n    @POST\n    public String params(@QueryParam(\"a\") int a, @QueryParam(\"b\") String b) {\n        return a + b;\n    }\n\n    @Override\n    @Path(\"headers\")\n    @GET\n    public String headers(\n            @HeaderParam(\"h\") String header, @HeaderParam(\"h2\") String header2, @QueryParam(\"v\") Integer param) {\n        String result = header + \" , \" + header2 + \" , \" + param;\n        return result;\n    }\n\n    @Override\n    @Path(\"path-variables/{p1}/{p2}\")\n    @GET\n    public String pathVariables(\n            @PathParam(\"p1\") String path1, @PathParam(\"p2\") String path2, @QueryParam(\"v\") String param) {\n        String result = path1 + \" , \" + path2 + \" , \" + param;\n        return result;\n    }\n\n    // @CookieParam does not support : https://github.com/OpenFeign/feign/issues/913\n    // @CookieValue also does not support\n\n    @Override\n    @Path(\"form\")\n    @POST\n    public String form(@FormParam(\"f\") String form) {\n        return String.valueOf(form);\n    }\n\n    @Override\n    @Path(\"request/body/map\")\n    @POST\n    @Produces(\"application/json;charset=UTF-8\")\n    public User requestBodyMap(Map<String, Object> data, @QueryParam(\"param\") String param) {\n        User user = new User();\n        user.setId(((Integer) data.get(\"id\")).longValue());\n        user.setName((String) data.get(\"name\"));\n        user.setAge((Integer) data.get(\"age\"));\n        return user;\n    }\n\n    @Path(\"request/body/user\")\n    @POST\n    @Override\n    @Consumes(\"application/json;charset=UTF-8\")\n    public Map<String, Object> requestBodyUser(User user) {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"id\", user.getId());\n        map.put(\"name\", user.getName());\n        map.put(\"age\", user.getAge());\n        return map;\n    }\n\n    @Path(\"noAnnotationJsonBody/json\")\n    @POST\n    @Consumes(MediaType.APPLICATION_JSON)\n    @Override\n    public void noAnnotationJsonBody(User user) {}\n\n    @Path(\"noAnnotationFormBody/form\")\n    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n    @POST\n    @Override\n    public void noAnnotationFormBody(User user) {}\n\n    @Path(\"noAnnotationParam/text\")\n    @POST\n    @Override\n    public void noAnnotationParam(String text) {}\n}\n",
        "methodName": null,
        "exampleID": 160,
        "dataset": "codeql",
        "filepath": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
        "line": 84,
        "sink": "java.lang.String.valueOf",
        "source": "-",
        "sourceLine": 84,
        "qualifier": "Call to java.lang.String.valueOf with untrusted data from [form : String](1).\nCall to java.lang.String.valueOf with untrusted data from [form : String](2).\nCall to java.lang.String.valueOf with untrusted data from [form : String](3).\nCall to java.lang.String.valueOf with untrusted data from [form : String](1).\nCall to java.lang.String.valueOf with untrusted data from [form : String](1).",
        "line_number": 84,
        "steps": [
            {
                "line": 82,
                "source": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "filepath": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "methodName": null,
                "exampleID": 161
            },
            {
                "line": 83,
                "source": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "filepath": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "methodName": null,
                "exampleID": 161
            },
            {
                "line": 82,
                "source": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "filepath": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "methodName": null,
                "exampleID": 161
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java#L83",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.metadata.rest;\n\nimport org.apache.dubbo.config.annotation.DubboService;\n\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.FormParam;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.HeaderParam;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.QueryParam;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * JAX-RS {@link RestService}\n */\n@DubboService(\n        version = \"3.0.0\",\n        protocol = {\"dubbo\", \"rest\"},\n        group = \"standard\")\n@Path(\"/\")\npublic class StandardRestService implements RestService {\n\n    @Override\n    @Path(\"param\")\n    @GET\n    public String param(@QueryParam(\"param\") String param) {\n        return param;\n    }\n\n    @Override\n    @Path(\"params\")\n    @POST\n    public String params(@QueryParam(\"a\") int a, @QueryParam(\"b\") String b) {\n        return a + b;\n    }\n\n    @Override\n    @Path(\"headers\")\n    @GET\n    public String headers(\n            @HeaderParam(\"h\") String header, @HeaderParam(\"h2\") String header2, @QueryParam(\"v\") Integer param) {\n        String result = header + \" , \" + header2 + \" , \" + param;\n        return result;\n    }\n\n    @Override\n    @Path(\"path-variables/{p1}/{p2}\")\n    @GET\n    public String pathVariables(\n            @PathParam(\"p1\") String path1, @PathParam(\"p2\") String path2, @QueryParam(\"v\") String param) {\n        String result = path1 + \" , \" + path2 + \" , \" + param;\n        return result;\n    }\n\n    // @CookieParam does not support : https://github.com/OpenFeign/feign/issues/913\n    // @CookieValue also does not support\n\n    @Override\n    @Path(\"form\")\n    @POST\n    public String form(@FormParam(\"f\") String form) {\n        return String.valueOf(form);\n    }\n\n    @Override\n    @Path(\"request/body/map\")\n    @POST\n    @Produces(\"application/json;charset=UTF-8\")\n    public User requestBodyMap(Map<String, Object> data, @QueryParam(\"param\") String param) {\n        User user = new User();\n        user.setId(((Integer) data.get(\"id\")).longValue());\n        user.setName((String) data.get(\"name\"));\n        user.setAge((Integer) data.get(\"age\"));\n        return user;\n    }\n\n    @Path(\"request/body/user\")\n    @POST\n    @Override\n    @Consumes(\"application/json;charset=UTF-8\")\n    public Map<String, Object> requestBodyUser(User user) {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"id\", user.getId());\n        map.put(\"name\", user.getName());\n        map.put(\"age\", user.getAge());\n        return map;\n    }\n}\n",
        "methodName": null,
        "exampleID": 162,
        "dataset": "codeql",
        "filepath": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
        "line": 83,
        "sink": "java.lang.String.valueOf",
        "source": "-",
        "sourceLine": 83,
        "qualifier": "Call to java.lang.String.valueOf with untrusted data from [form : String](1).\nCall to java.lang.String.valueOf with untrusted data from [form : String](2).\nCall to java.lang.String.valueOf with untrusted data from [form : String](3).\nCall to java.lang.String.valueOf with untrusted data from [form : String](1).\nCall to java.lang.String.valueOf with untrusted data from [form : String](1).",
        "line_number": 83,
        "steps": [
            {
                "line": 82,
                "source": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "filepath": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "methodName": null,
                "exampleID": 163
            },
            {
                "line": 83,
                "source": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "filepath": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "methodName": null,
                "exampleID": 163
            },
            {
                "line": 82,
                "source": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "filepath": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/StandardRestService.java",
                "methodName": null,
                "exampleID": 163
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java#L74",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.metadata.rest;\n\nimport org.apache.dubbo.config.annotation.DubboService;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.http.MediaType;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestHeader;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n/**\n * Spring MVC {@link RestService}\n *\n * @since 2.7.6\n */\n@DubboService(version = \"2.0.0\", group = \"spring\")\n@RestController\npublic class SpringRestService implements RestService {\n\n    @Override\n    @GetMapping(value = \"/param\")\n    public String param(@RequestParam(defaultValue = \"value-param\") String param) {\n        return null;\n    }\n\n    @Override\n    @PostMapping(\"/params\")\n    public String params(\n            @RequestParam(defaultValue = \"value-a\") int a, @RequestParam(defaultValue = \"value-b\") String b) {\n        return null;\n    }\n\n    @Override\n    @GetMapping(\"/headers\")\n    public String headers(\n            @RequestHeader(name = \"h\", defaultValue = \"value-h\") String header,\n            @RequestHeader(name = \"h2\", defaultValue = \"value-h2\") String header2,\n            @RequestParam(value = \"v\", defaultValue = \"1\") Integer param) {\n        return null;\n    }\n\n    @Override\n    @GetMapping(\"/path-variables/{p1}/{p2}\")\n    public String pathVariables(\n            @PathVariable(\"p1\") String path1, @PathVariable(\"p2\") String path2, @RequestParam(\"v\") String param) {\n        return null;\n    }\n\n    @Override\n    @PostMapping(\"/form\")\n    public String form(@RequestParam(\"f\") String form) {\n        return String.valueOf(form);\n    }\n\n    @Override\n    @PostMapping(value = \"/request/body/map\", produces = MediaType.APPLICATION_JSON_UTF8_VALUE)\n    public User requestBodyMap(@RequestBody Map<String, Object> data, @RequestParam(\"param\") String param) {\n        User user = new User();\n        user.setId(((Integer) data.get(\"id\")).longValue());\n        user.setName((String) data.get(\"name\"));\n        user.setAge((Integer) data.get(\"age\"));\n        return user;\n    }\n\n    @PostMapping(value = \"/request/body/user\", consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)\n    @Override\n    public Map<String, Object> requestBodyUser(@RequestBody User user) {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"id\", user.getId());\n        map.put(\"name\", user.getName());\n        map.put(\"age\", user.getAge());\n        return map;\n    }\n}\n",
        "methodName": null,
        "exampleID": 164,
        "dataset": "codeql",
        "filepath": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
        "line": 74,
        "sink": "java.lang.String.valueOf",
        "source": "-",
        "sourceLine": 74,
        "qualifier": "Call to java.lang.String.valueOf with untrusted data from [form : String](1).\nCall to java.lang.String.valueOf with untrusted data from [form : String](2).\nCall to java.lang.String.valueOf with untrusted data from [form : String](3).\nCall to java.lang.String.valueOf with untrusted data from [form : String](1).\nCall to java.lang.String.valueOf with untrusted data from [form : String](1).",
        "line_number": 74,
        "steps": [
            {
                "line": 73,
                "source": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "filepath": "dubbo-compatible/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "methodName": null,
                "exampleID": 165
            },
            {
                "line": 73,
                "source": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "filepath": "dubbo-metadata/dubbo-metadata-api/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "methodName": null,
                "exampleID": 165
            },
            {
                "line": 73,
                "source": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "filepath": "dubbo-metadata/dubbo-metadata-processor/src/test/java/org/apache/dubbo/metadata/rest/SpringRestService.java",
                "methodName": null,
                "exampleID": 165
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/MetricsEvent.java#L91",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.metrics.event;\n\nimport org.apache.dubbo.common.beans.factory.ScopeBeanFactory;\nimport org.apache.dubbo.metrics.exception.MetricsNeverHappenException;\nimport org.apache.dubbo.metrics.model.MethodMetric;\nimport org.apache.dubbo.metrics.model.key.TypeWrapper;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\n\nimport java.util.Collections;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\n\n/**\n * BaseMetricsEvent.\n */\npublic abstract class MetricsEvent {\n\n    /**\n     * Metric object. (eg. {@link MethodMetric})\n     */\n    protected final transient ApplicationModel source;\n\n    private boolean available = true;\n    private final TypeWrapper typeWrapper;\n    private final String appName;\n    private final MetricsDispatcher metricsDispatcher;\n\n    private final Map<String, Object> attachments = new IdentityHashMap<>(8);\n\n    public MetricsEvent(ApplicationModel source, TypeWrapper typeWrapper) {\n        this(source, null, null, typeWrapper);\n    }\n\n    public MetricsEvent(\n            ApplicationModel source, String appName, MetricsDispatcher metricsDispatcher, TypeWrapper typeWrapper) {\n        this.typeWrapper = typeWrapper;\n        if (source == null) {\n            this.source = ApplicationModel.defaultModel();\n            // Appears only in unit tests\n            this.available = false;\n        } else {\n            this.source = source;\n        }\n        if (metricsDispatcher == null) {\n            if (this.source.isDestroyed()) {\n                this.metricsDispatcher = null;\n            } else {\n                ScopeBeanFactory beanFactory = this.source.getBeanFactory();\n                if (beanFactory.isDestroyed()) {\n                    this.metricsDispatcher = null;\n                } else {\n                    MetricsDispatcher dispatcher = beanFactory.getBean(MetricsDispatcher.class);\n                    this.metricsDispatcher = dispatcher;\n                }\n            }\n        } else {\n            this.metricsDispatcher = metricsDispatcher;\n        }\n        if (appName == null) {\n            this.appName = this.source.tryGetApplicationName();\n        } else {\n            this.appName = appName;\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getAttachmentValue(String key) {\n        if (key == null) {\n            throw new MetricsNeverHappenException(\"Attachment key is null\");\n        }\n        return (T) attachments.get(key);\n    }\n\n    public Map<String, Object> getAttachments() {\n        return Collections.unmodifiableMap(attachments);\n    }\n\n    public void putAttachment(String key, Object value) {\n        attachments.put(key, value);\n    }\n\n    public void putAttachments(Map<String, String> attachments) {\n        this.attachments.putAll(attachments);\n    }\n\n    public void setAvailable(boolean available) {\n        this.available = available;\n    }\n\n    public boolean isAvailable() {\n        return available;\n    }\n\n    public void customAfterPost(Object postResult) {}\n\n    public ApplicationModel getSource() {\n        return source;\n    }\n\n    public MetricsDispatcher getMetricsDispatcher() {\n        return metricsDispatcher;\n    }\n\n    public String appName() {\n        return appName;\n    }\n\n    public TypeWrapper getTypeWrapper() {\n        return typeWrapper;\n    }\n\n    public boolean isAssignableFrom(Object type) {\n        return typeWrapper.isAssignableFrom(type);\n    }\n\n    public String toString() {\n        return getClass().getName() + \"[source=\" + source + \"]\";\n    }\n\n    public enum Type {\n        TOTAL(\"TOTAL_%s\"),\n        SUCCEED(\"SUCCEED_%s\"),\n        BUSINESS_FAILED(\"BUSINESS_FAILED_%s\"),\n        REQUEST_TIMEOUT(\"REQUEST_TIMEOUT_%s\"),\n        REQUEST_LIMIT(\"REQUEST_LIMIT_%s\"),\n        PROCESSING(\"PROCESSING_%s\"),\n        UNKNOWN_FAILED(\"UNKNOWN_FAILED_%s\"),\n        TOTAL_FAILED(\"TOTAL_FAILED_%s\"),\n        APPLICATION_INFO(\"APPLICATION_INFO_%s\"),\n        NETWORK_EXCEPTION(\"NETWORK_EXCEPTION_%s\"),\n        SERVICE_UNAVAILABLE(\"SERVICE_UNAVAILABLE_%s\"),\n        CODEC_EXCEPTION(\"CODEC_EXCEPTION_%s\"),\n        NO_INVOKER_AVAILABLE(\"NO_INVOKER_AVAILABLE_%s\"),\n        ;\n\n        private final String name;\n\n        public final String getName() {\n            return this.name;\n        }\n\n        public final String getNameByType(String type) {\n            return String.format(name, type);\n        }\n\n        Type(String name) {\n            this.name = name;\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 166,
        "dataset": "codeql",
        "filepath": "dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/event/MetricsEvent.java",
        "line": 91,
        "sink": "java.util.Collections.unmodifiableMap",
        "source": "-",
        "sourceLine": 91,
        "qualifier": "Call to java.util.Collections.unmodifiableMap with untrusted data from [msg : Object](1).\nCall to java.util.Collections.unmodifiableMap with untrusted data from [msg : Object](2).\nCall to java.util.Collections.unmodifiableMap with untrusted data from [msg : Object](3).",
        "line_number": 91,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 167
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 167
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 167
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 167
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/observation/DubboClientContext.java#L39",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.metrics.observation;\n\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\n\nimport java.util.Objects;\n\nimport io.micrometer.observation.transport.SenderContext;\n\n/**\n * Provider context for RPC.\n */\npublic class DubboClientContext extends SenderContext<Invocation> {\n\n    private final Invoker<?> invoker;\n\n    private final Invocation invocation;\n\n    public DubboClientContext(Invoker<?> invoker, Invocation invocation) {\n        super((map, key, value) -> Objects.requireNonNull(map).setAttachment(key, value));\n        this.invoker = invoker;\n        this.invocation = invocation;\n        setCarrier(invocation);\n    }\n\n    public Invoker<?> getInvoker() {\n        return invoker;\n    }\n\n    public Invocation getInvocation() {\n        return invocation;\n    }\n}\n",
        "methodName": null,
        "exampleID": 168,
        "dataset": "codeql",
        "filepath": "dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/observation/DubboClientContext.java",
        "line": 39,
        "sink": "io.micrometer.observation.transport.SenderContext<Invocation>.setCarrier",
        "source": "-",
        "sourceLine": 39,
        "qualifier": "Call to io.micrometer.observation.transport.SenderContext<Invocation>.setCarrier with untrusted data from [msg : Object](1).\nCall to io.micrometer.observation.transport.SenderContext<Invocation>.setCarrier with untrusted data from [msg : Object](2).\nCall to io.micrometer.observation.transport.SenderContext<Invocation>.setCarrier with untrusted data from [msg : Object](3).",
        "line_number": 39,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 169
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 169
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 169
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 169
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/observation/DubboServerContext.java#L37",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.metrics.observation;\n\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\n\nimport io.micrometer.observation.transport.ReceiverContext;\n\n/**\n * Consumer context for RPC.\n */\npublic class DubboServerContext extends ReceiverContext<Invocation> {\n\n    private final Invoker<?> invoker;\n\n    private final Invocation invocation;\n\n    public DubboServerContext(Invoker<?> invoker, Invocation invocation) {\n        super((stringObjectMap, s) -> String.valueOf(stringObjectMap.getAttachment(s)));\n        this.invoker = invoker;\n        this.invocation = invocation;\n        setCarrier(invocation);\n    }\n\n    public Invoker<?> getInvoker() {\n        return invoker;\n    }\n\n    public Invocation getInvocation() {\n        return invocation;\n    }\n}\n",
        "methodName": null,
        "exampleID": 170,
        "dataset": "codeql",
        "filepath": "dubbo-metrics/dubbo-metrics-api/src/main/java/org/apache/dubbo/metrics/observation/DubboServerContext.java",
        "line": 37,
        "sink": "io.micrometer.observation.transport.ReceiverContext<Invocation>.setCarrier",
        "source": "-",
        "sourceLine": 37,
        "qualifier": "Call to io.micrometer.observation.transport.ReceiverContext<Invocation>.setCarrier with untrusted data from [msg : Object](1).\nCall to io.micrometer.observation.transport.ReceiverContext<Invocation>.setCarrier with untrusted data from [msg : Object](2).\nCall to io.micrometer.observation.transport.ReceiverContext<Invocation>.setCarrier with untrusted data from [msg : Object](3).",
        "line_number": 37,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 171
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 171
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 171
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 171
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/report/DefaultMetricsReporter.java#L57",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.metrics.report;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\nimport io.micrometer.core.instrument.Counter;\nimport io.micrometer.core.instrument.Gauge;\nimport io.micrometer.core.instrument.Tag;\nimport io.micrometer.core.instrument.Timer;\nimport io.micrometer.core.instrument.simple.SimpleMeterRegistry;\n\npublic class DefaultMetricsReporter extends AbstractMetricsReporter {\n\n    SimpleMeterRegistry meterRegistry = new SimpleMeterRegistry();\n\n    protected DefaultMetricsReporter(URL url, ApplicationModel applicationModel) {\n        super(url, applicationModel);\n    }\n\n    @Override\n    public String getResponse() {\n        return null;\n    }\n\n    @Override\n    public String getResponseWithName(String metricsName) {\n        Map<String, List<Tag>> metricsTags = new HashMap<>();\n        Map<String, Object> metricsValue = new HashMap<>();\n        StringBuilder sb = new StringBuilder();\n        meterRegistry.getMeters().stream()\n                .filter(meter -> {\n                    if (meter == null || meter.getId() == null || meter.getId().getName() == null) {\n                        return false;\n                    }\n                    if (metricsName != null) {\n                        return meter.getId().getName().contains(metricsName);\n                    }\n                    return true;\n                })\n                .forEach(meter -> {\n                    Object value = null;\n                    if (meter instanceof Counter) {\n                        Counter counter = (Counter) meter;\n                        value = counter.count();\n                    }\n                    if (meter instanceof Gauge) {\n                        Gauge gauge = (Gauge) meter;\n                        value = gauge.value();\n                    }\n                    if (meter instanceof Timer) {\n                        Timer timer = (Timer) meter;\n                        value = timer.totalTime(TimeUnit.MILLISECONDS);\n                    }\n                    metricsTags.put(meter.getId().getName(), meter.getId().getTags());\n                    metricsValue.put(meter.getId().getName(), value);\n                });\n        metricsValue.forEach((key, value) -> {\n            sb.append(key).append(\"{\");\n            List<Tag> tags = metricsTags.get(key);\n            if (tags != null && tags.size() > 0) {\n                tags.forEach(tag -> {\n                    sb.append(tag.getKey()).append(\"=\").append(tag.getValue()).append(\",\");\n                });\n            }\n            sb.append(\"} \").append(value).append(System.lineSeparator());\n        });\n        return sb.toString();\n    }\n\n    @Override\n    protected void doInit() {\n        addMeterRegistry(meterRegistry);\n    }\n\n    @Override\n    protected void doDestroy() {}\n}\n",
        "methodName": null,
        "exampleID": 172,
        "dataset": "codeql",
        "filepath": "dubbo-metrics/dubbo-metrics-default/src/main/java/org/apache/dubbo/metrics/report/DefaultMetricsReporter.java",
        "line": 57,
        "sink": "java.lang.String.contains",
        "source": "-",
        "sourceLine": 57,
        "qualifier": "Call to java.lang.String.contains with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.String.contains with untrusted data from [msg : String](2).",
        "line_number": 57,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 173
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 173
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 173
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 173
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/decoder/TelnetCommandDecoder.java#L45",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command.decoder;\n\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.qos.command.CommandContextFactory;\n\npublic class TelnetCommandDecoder {\n    public static final CommandContext decode(String str) {\n        CommandContext commandContext = null;\n        if (!StringUtils.isBlank(str)) {\n            str = str.trim();\n            String[] array = str.split(\"(?<![\\\\\\\\]) \");\n            if (array.length > 0) {\n                String[] targetArgs = new String[array.length - 1];\n                System.arraycopy(array, 1, targetArgs, 0, array.length - 1);\n                String name = array[0].trim();\n                if (name.equals(\"invoke\") && array.length > 2) {\n                    targetArgs = reBuildInvokeCmdArgs(str);\n                }\n                commandContext = CommandContextFactory.newInstance(name, targetArgs, false);\n                commandContext.setOriginRequest(str);\n            }\n        }\n\n        return commandContext;\n    }\n\n    private static String[] reBuildInvokeCmdArgs(String cmd) {\n        return new String[] {cmd.substring(cmd.indexOf(\" \") + 1).trim()};\n    }\n}\n",
        "methodName": null,
        "exampleID": 174,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/decoder/TelnetCommandDecoder.java",
        "line": 45,
        "sink": "java.lang.String.indexOf",
        "source": "-",
        "sourceLine": 45,
        "qualifier": "Call to java.lang.String.indexOf with untrusted data from [msg : String](1).",
        "line_number": 45,
        "steps": [
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 175
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java#L54",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.qos.api.PermissionLevel;\nimport org.apache.dubbo.qos.command.exception.NoSuchCommandException;\nimport org.apache.dubbo.qos.command.exception.PermissionDenyException;\nimport org.apache.dubbo.qos.common.QosConstants;\nimport org.apache.dubbo.qos.permission.DefaultAnonymousAccessPermissionChecker;\nimport org.apache.dubbo.qos.permission.PermissionChecker;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport io.netty.channel.Channel;\n\npublic class DefaultCommandExecutor implements CommandExecutor {\n    private static final Logger logger = LoggerFactory.getLogger(DefaultCommandExecutor.class);\n    private final FrameworkModel frameworkModel;\n\n    public DefaultCommandExecutor(FrameworkModel frameworkModel) {\n        this.frameworkModel = frameworkModel;\n    }\n\n    @Override\n    public String execute(CommandContext commandContext) throws NoSuchCommandException, PermissionDenyException {\n        String remoteAddress = Optional.ofNullable(commandContext.getRemote())\n                .map(Channel::remoteAddress)\n                .map(Objects::toString)\n                .orElse(\"unknown\");\n\n        logger.info(\"[Dubbo QoS] Command Process start. Command: \" + commandContext.getCommandName() + \", Args: \"\n                + Arrays.toString(commandContext.getArgs()) + \", Remote Address: \" + remoteAddress);\n\n        BaseCommand command = null;\n        try {\n            command =\n                    frameworkModel.getExtensionLoader(BaseCommand.class).getExtension(commandContext.getCommandName());\n        } catch (Throwable throwable) {\n            // can't find command\n        }\n        if (command == null) {\n            logger.info(\"[Dubbo QoS] Command Not found. Command: \" + commandContext.getCommandName()\n                    + \", Remote Address: \" + remoteAddress);\n            throw new NoSuchCommandException(commandContext.getCommandName());\n        }\n\n        // check permission when configs allow anonymous access\n        if (commandContext.isAllowAnonymousAccess()) {\n            PermissionChecker permissionChecker = DefaultAnonymousAccessPermissionChecker.INSTANCE;\n            try {\n                permissionChecker = frameworkModel\n                        .getExtensionLoader(PermissionChecker.class)\n                        .getExtension(QosConstants.QOS_PERMISSION_CHECKER);\n            } catch (Throwable throwable) {\n                // can't find valid custom permissionChecker\n            }\n\n            final Cmd cmd = command.getClass().getAnnotation(Cmd.class);\n            final PermissionLevel cmdRequiredPermissionLevel = cmd.requiredPermissionLevel();\n\n            if (!permissionChecker.access(commandContext, cmdRequiredPermissionLevel)) {\n                logger.info(\n                        \"[Dubbo QoS] Command Deny to access. Command: \" + commandContext.getCommandName() + \", Args: \"\n                                + Arrays.toString(commandContext.getArgs()) + \", Required Permission Level: \"\n                                + cmdRequiredPermissionLevel + \", Remote Address: \"\n                                + remoteAddress);\n                throw new PermissionDenyException(commandContext.getCommandName());\n            }\n        }\n\n        try {\n            String result = command.execute(commandContext, commandContext.getArgs());\n            if (command.logResult()) {\n                logger.info(\"[Dubbo QoS] Command Process success. Command: \" + commandContext.getCommandName()\n                        + \", Args: \"\n                        + Arrays.toString(commandContext.getArgs()) + \", Result: \" + result + \", Remote Address: \"\n                        + remoteAddress);\n            }\n            return result;\n        } catch (Throwable t) {\n            logger.info(\n                    \"[Dubbo QoS] Command Process Failed. Command: \" + commandContext.getCommandName() + \", Args: \"\n                            + Arrays.toString(commandContext.getArgs()) + \", Remote Address: \"\n                            + remoteAddress,\n                    t);\n            throw t;\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 176,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java",
        "line": 54,
        "sink": "java.util.Arrays.toString",
        "source": "-",
        "sourceLine": 54,
        "qualifier": "Call to java.util.Arrays.toString with untrusted data from [msg : HttpRequest](1).\nCall to java.util.Arrays.toString with untrusted data from [msg : String](2).",
        "line_number": 54,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 177
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 177
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 177
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 177
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/decoder/HttpCommandDecoder.java#L55",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command.decoder;\n\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.qos.command.CommandContextFactory;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.QueryStringDecoder;\nimport io.netty.handler.codec.http.multipart.Attribute;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;\nimport io.netty.handler.codec.http.multipart.InterfaceHttpData;\n\npublic class HttpCommandDecoder {\n    public static CommandContext decode(HttpRequest request) {\n        CommandContext commandContext = null;\n        if (request != null) {\n            QueryStringDecoder queryStringDecoder = new QueryStringDecoder(request.uri());\n            String path = queryStringDecoder.path();\n            String[] array = path.split(\"/\");\n            if (array.length == 2) {\n                String name = array[1];\n\n                // process GET request and POST request separately. Check url for GET, and check body for POST\n                if (request.method() == HttpMethod.GET) {\n                    if (queryStringDecoder.parameters().isEmpty()) {\n                        commandContext = CommandContextFactory.newInstance(name);\n                        commandContext.setHttp(true);\n                    } else {\n                        List<String> valueList = new ArrayList<>();\n                        for (List<String> values :\n                                queryStringDecoder.parameters().values()) {\n                            valueList.addAll(values);\n                        }\n                        commandContext =\n                                CommandContextFactory.newInstance(name, valueList.toArray(new String[] {}), true);\n                    }\n                } else if (request.method() == HttpMethod.POST) {\n                    HttpPostRequestDecoder httpPostRequestDecoder = new HttpPostRequestDecoder(request);\n                    List<String> valueList = new ArrayList<>();\n                    for (InterfaceHttpData interfaceHttpData : httpPostRequestDecoder.getBodyHttpDatas()) {\n                        if (interfaceHttpData.getHttpDataType() == InterfaceHttpData.HttpDataType.Attribute) {\n                            Attribute attribute = (Attribute) interfaceHttpData;\n                            try {\n                                valueList.add(attribute.getValue());\n                            } catch (IOException ex) {\n                                throw new RuntimeException(ex);\n                            }\n                        }\n                    }\n                    if (valueList.isEmpty()) {\n                        commandContext = CommandContextFactory.newInstance(name);\n                        commandContext.setHttp(true);\n                    } else {\n                        commandContext =\n                                CommandContextFactory.newInstance(name, valueList.toArray(new String[] {}), true);\n                    }\n                }\n            } else if (array.length == 3) {\n                String name = array[1];\n                String appName = array[2];\n                if (request.method() == HttpMethod.GET) {\n                    commandContext = CommandContextFactory.newInstance(name, new String[] {appName}, true);\n                    commandContext.setHttp(true);\n                }\n            }\n        }\n\n        return commandContext;\n    }\n}\n",
        "methodName": null,
        "exampleID": 178,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/decoder/HttpCommandDecoder.java",
        "line": 55,
        "sink": "java.util.List<String>.toArray",
        "source": "-",
        "sourceLine": 55,
        "qualifier": "Call to java.util.List<String>.toArray with untrusted data from [msg : HttpRequest](1).",
        "line_number": 55,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 179
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/decoder/HttpCommandDecoder.java#L75",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command.decoder;\n\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.qos.command.CommandContextFactory;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.QueryStringDecoder;\nimport io.netty.handler.codec.http.multipart.Attribute;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;\nimport io.netty.handler.codec.http.multipart.InterfaceHttpData;\n\npublic class HttpCommandDecoder {\n    public static CommandContext decode(HttpRequest request) {\n        CommandContext commandContext = null;\n        if (request != null) {\n            QueryStringDecoder queryStringDecoder = new QueryStringDecoder(request.uri());\n            String path = queryStringDecoder.path();\n            String[] array = path.split(\"/\");\n            if (array.length == 2) {\n                String name = array[1];\n\n                // process GET request and POST request separately. Check url for GET, and check body for POST\n                if (request.method() == HttpMethod.GET) {\n                    if (queryStringDecoder.parameters().isEmpty()) {\n                        commandContext = CommandContextFactory.newInstance(name);\n                        commandContext.setHttp(true);\n                    } else {\n                        List<String> valueList = new ArrayList<>();\n                        for (List<String> values :\n                                queryStringDecoder.parameters().values()) {\n                            valueList.addAll(values);\n                        }\n                        commandContext =\n                                CommandContextFactory.newInstance(name, valueList.toArray(new String[] {}), true);\n                    }\n                } else if (request.method() == HttpMethod.POST) {\n                    HttpPostRequestDecoder httpPostRequestDecoder = new HttpPostRequestDecoder(request);\n                    List<String> valueList = new ArrayList<>();\n                    for (InterfaceHttpData interfaceHttpData : httpPostRequestDecoder.getBodyHttpDatas()) {\n                        if (interfaceHttpData.getHttpDataType() == InterfaceHttpData.HttpDataType.Attribute) {\n                            Attribute attribute = (Attribute) interfaceHttpData;\n                            try {\n                                valueList.add(attribute.getValue());\n                            } catch (IOException ex) {\n                                throw new RuntimeException(ex);\n                            }\n                        }\n                    }\n                    if (valueList.isEmpty()) {\n                        commandContext = CommandContextFactory.newInstance(name);\n                        commandContext.setHttp(true);\n                    } else {\n                        commandContext =\n                                CommandContextFactory.newInstance(name, valueList.toArray(new String[] {}), true);\n                    }\n                }\n            } else if (array.length == 3) {\n                String name = array[1];\n                String appName = array[2];\n                if (request.method() == HttpMethod.GET) {\n                    commandContext = CommandContextFactory.newInstance(name, new String[] {appName}, true);\n                    commandContext.setHttp(true);\n                }\n            }\n        }\n\n        return commandContext;\n    }\n}\n",
        "methodName": null,
        "exampleID": 180,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/decoder/HttpCommandDecoder.java",
        "line": 75,
        "sink": "java.util.List<String>.toArray",
        "source": "-",
        "sourceLine": 75,
        "qualifier": "Call to java.util.List<String>.toArray with untrusted data from [msg : HttpRequest](1).",
        "line_number": 75,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 181
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/decoder/HttpCommandDecoder.java#L81",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command.decoder;\n\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.qos.command.CommandContextFactory;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.QueryStringDecoder;\nimport io.netty.handler.codec.http.multipart.Attribute;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;\nimport io.netty.handler.codec.http.multipart.InterfaceHttpData;\n\npublic class HttpCommandDecoder {\n    public static CommandContext decode(HttpRequest request) {\n        CommandContext commandContext = null;\n        if (request != null) {\n            QueryStringDecoder queryStringDecoder = new QueryStringDecoder(request.uri());\n            String path = queryStringDecoder.path();\n            String[] array = path.split(\"/\");\n            if (array.length == 2) {\n                String name = array[1];\n\n                // process GET request and POST request separately. Check url for GET, and check body for POST\n                if (request.method() == HttpMethod.GET) {\n                    if (queryStringDecoder.parameters().isEmpty()) {\n                        commandContext = CommandContextFactory.newInstance(name);\n                        commandContext.setHttp(true);\n                    } else {\n                        List<String> valueList = new ArrayList<>();\n                        for (List<String> values :\n                                queryStringDecoder.parameters().values()) {\n                            valueList.addAll(values);\n                        }\n                        commandContext =\n                                CommandContextFactory.newInstance(name, valueList.toArray(new String[] {}), true);\n                    }\n                } else if (request.method() == HttpMethod.POST) {\n                    HttpPostRequestDecoder httpPostRequestDecoder = new HttpPostRequestDecoder(request);\n                    List<String> valueList = new ArrayList<>();\n                    for (InterfaceHttpData interfaceHttpData : httpPostRequestDecoder.getBodyHttpDatas()) {\n                        if (interfaceHttpData.getHttpDataType() == InterfaceHttpData.HttpDataType.Attribute) {\n                            Attribute attribute = (Attribute) interfaceHttpData;\n                            try {\n                                valueList.add(attribute.getValue());\n                            } catch (IOException ex) {\n                                throw new RuntimeException(ex);\n                            }\n                        }\n                    }\n                    if (valueList.isEmpty()) {\n                        commandContext = CommandContextFactory.newInstance(name);\n                        commandContext.setHttp(true);\n                    } else {\n                        commandContext =\n                                CommandContextFactory.newInstance(name, valueList.toArray(new String[] {}), true);\n                    }\n                }\n            } else if (array.length == 3) {\n                String name = array[1];\n                String appName = array[2];\n                if (request.method() == HttpMethod.GET) {\n                    commandContext = CommandContextFactory.newInstance(name, new String[] {appName}, true);\n                    commandContext.setHttp(true);\n                }\n            }\n        }\n\n        return commandContext;\n    }\n}\n",
        "methodName": null,
        "exampleID": 182,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/decoder/HttpCommandDecoder.java",
        "line": 81,
        "sink": "io.netty.handler.codec.http.HttpRequest.method",
        "source": "-",
        "sourceLine": 81,
        "qualifier": "Call to io.netty.handler.codec.http.HttpRequest.method with untrusted data from [msg : HttpRequest](1).",
        "line_number": 81,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 183
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java#L59",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.qos.api.PermissionLevel;\nimport org.apache.dubbo.qos.command.exception.NoSuchCommandException;\nimport org.apache.dubbo.qos.command.exception.PermissionDenyException;\nimport org.apache.dubbo.qos.common.QosConstants;\nimport org.apache.dubbo.qos.permission.DefaultAnonymousAccessPermissionChecker;\nimport org.apache.dubbo.qos.permission.PermissionChecker;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport io.netty.channel.Channel;\n\npublic class DefaultCommandExecutor implements CommandExecutor {\n    private static final Logger logger = LoggerFactory.getLogger(DefaultCommandExecutor.class);\n    private final FrameworkModel frameworkModel;\n\n    public DefaultCommandExecutor(FrameworkModel frameworkModel) {\n        this.frameworkModel = frameworkModel;\n    }\n\n    @Override\n    public String execute(CommandContext commandContext) throws NoSuchCommandException, PermissionDenyException {\n        String remoteAddress = Optional.ofNullable(commandContext.getRemote())\n                .map(Channel::remoteAddress)\n                .map(Objects::toString)\n                .orElse(\"unknown\");\n\n        logger.info(\"[Dubbo QoS] Command Process start. Command: \" + commandContext.getCommandName() + \", Args: \"\n                + Arrays.toString(commandContext.getArgs()) + \", Remote Address: \" + remoteAddress);\n\n        BaseCommand command = null;\n        try {\n            command =\n                    frameworkModel.getExtensionLoader(BaseCommand.class).getExtension(commandContext.getCommandName());\n        } catch (Throwable throwable) {\n            // can't find command\n        }\n        if (command == null) {\n            logger.info(\"[Dubbo QoS] Command Not found. Command: \" + commandContext.getCommandName()\n                    + \", Remote Address: \" + remoteAddress);\n            throw new NoSuchCommandException(commandContext.getCommandName());\n        }\n\n        // check permission when configs allow anonymous access\n        if (commandContext.isAllowAnonymousAccess()) {\n            PermissionChecker permissionChecker = DefaultAnonymousAccessPermissionChecker.INSTANCE;\n            try {\n                permissionChecker = frameworkModel\n                        .getExtensionLoader(PermissionChecker.class)\n                        .getExtension(QosConstants.QOS_PERMISSION_CHECKER);\n            } catch (Throwable throwable) {\n                // can't find valid custom permissionChecker\n            }\n\n            final Cmd cmd = command.getClass().getAnnotation(Cmd.class);\n            final PermissionLevel cmdRequiredPermissionLevel = cmd.requiredPermissionLevel();\n\n            if (!permissionChecker.access(commandContext, cmdRequiredPermissionLevel)) {\n                logger.info(\n                        \"[Dubbo QoS] Command Deny to access. Command: \" + commandContext.getCommandName() + \", Args: \"\n                                + Arrays.toString(commandContext.getArgs()) + \", Required Permission Level: \"\n                                + cmdRequiredPermissionLevel + \", Remote Address: \"\n                                + remoteAddress);\n                throw new PermissionDenyException(commandContext.getCommandName());\n            }\n        }\n\n        try {\n            String result = command.execute(commandContext, commandContext.getArgs());\n            if (command.logResult()) {\n                logger.info(\"[Dubbo QoS] Command Process success. Command: \" + commandContext.getCommandName()\n                        + \", Args: \"\n                        + Arrays.toString(commandContext.getArgs()) + \", Result: \" + result + \", Remote Address: \"\n                        + remoteAddress);\n            }\n            return result;\n        } catch (Throwable t) {\n            logger.info(\n                    \"[Dubbo QoS] Command Process Failed. Command: \" + commandContext.getCommandName() + \", Args: \"\n                            + Arrays.toString(commandContext.getArgs()) + \", Remote Address: \"\n                            + remoteAddress,\n                    t);\n            throw t;\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 184,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java",
        "line": 59,
        "sink": "org.apache.dubbo.common.extension.ExtensionLoader<BaseCommand>.getExtension",
        "source": "-",
        "sourceLine": 59,
        "qualifier": "Call to org.apache.dubbo.common.extension.ExtensionLoader<BaseCommand>.getExtension with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.dubbo.common.extension.ExtensionLoader<BaseCommand>.getExtension with untrusted data from [msg : String](2).",
        "line_number": 59,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 185
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 185
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 185
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 185
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java#L86",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.qos.api.PermissionLevel;\nimport org.apache.dubbo.qos.command.exception.NoSuchCommandException;\nimport org.apache.dubbo.qos.command.exception.PermissionDenyException;\nimport org.apache.dubbo.qos.common.QosConstants;\nimport org.apache.dubbo.qos.permission.DefaultAnonymousAccessPermissionChecker;\nimport org.apache.dubbo.qos.permission.PermissionChecker;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport io.netty.channel.Channel;\n\npublic class DefaultCommandExecutor implements CommandExecutor {\n    private static final Logger logger = LoggerFactory.getLogger(DefaultCommandExecutor.class);\n    private final FrameworkModel frameworkModel;\n\n    public DefaultCommandExecutor(FrameworkModel frameworkModel) {\n        this.frameworkModel = frameworkModel;\n    }\n\n    @Override\n    public String execute(CommandContext commandContext) throws NoSuchCommandException, PermissionDenyException {\n        String remoteAddress = Optional.ofNullable(commandContext.getRemote())\n                .map(Channel::remoteAddress)\n                .map(Objects::toString)\n                .orElse(\"unknown\");\n\n        logger.info(\"[Dubbo QoS] Command Process start. Command: \" + commandContext.getCommandName() + \", Args: \"\n                + Arrays.toString(commandContext.getArgs()) + \", Remote Address: \" + remoteAddress);\n\n        BaseCommand command = null;\n        try {\n            command =\n                    frameworkModel.getExtensionLoader(BaseCommand.class).getExtension(commandContext.getCommandName());\n        } catch (Throwable throwable) {\n            // can't find command\n        }\n        if (command == null) {\n            logger.info(\"[Dubbo QoS] Command Not found. Command: \" + commandContext.getCommandName()\n                    + \", Remote Address: \" + remoteAddress);\n            throw new NoSuchCommandException(commandContext.getCommandName());\n        }\n\n        // check permission when configs allow anonymous access\n        if (commandContext.isAllowAnonymousAccess()) {\n            PermissionChecker permissionChecker = DefaultAnonymousAccessPermissionChecker.INSTANCE;\n            try {\n                permissionChecker = frameworkModel\n                        .getExtensionLoader(PermissionChecker.class)\n                        .getExtension(QosConstants.QOS_PERMISSION_CHECKER);\n            } catch (Throwable throwable) {\n                // can't find valid custom permissionChecker\n            }\n\n            final Cmd cmd = command.getClass().getAnnotation(Cmd.class);\n            final PermissionLevel cmdRequiredPermissionLevel = cmd.requiredPermissionLevel();\n\n            if (!permissionChecker.access(commandContext, cmdRequiredPermissionLevel)) {\n                logger.info(\n                        \"[Dubbo QoS] Command Deny to access. Command: \" + commandContext.getCommandName() + \", Args: \"\n                                + Arrays.toString(commandContext.getArgs()) + \", Required Permission Level: \"\n                                + cmdRequiredPermissionLevel + \", Remote Address: \"\n                                + remoteAddress);\n                throw new PermissionDenyException(commandContext.getCommandName());\n            }\n        }\n\n        try {\n            String result = command.execute(commandContext, commandContext.getArgs());\n            if (command.logResult()) {\n                logger.info(\"[Dubbo QoS] Command Process success. Command: \" + commandContext.getCommandName()\n                        + \", Args: \"\n                        + Arrays.toString(commandContext.getArgs()) + \", Result: \" + result + \", Remote Address: \"\n                        + remoteAddress);\n            }\n            return result;\n        } catch (Throwable t) {\n            logger.info(\n                    \"[Dubbo QoS] Command Process Failed. Command: \" + commandContext.getCommandName() + \", Args: \"\n                            + Arrays.toString(commandContext.getArgs()) + \", Remote Address: \"\n                            + remoteAddress,\n                    t);\n            throw t;\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 186,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java",
        "line": 86,
        "sink": "java.util.Arrays.toString",
        "source": "-",
        "sourceLine": 86,
        "qualifier": "Call to java.util.Arrays.toString with untrusted data from [msg : HttpRequest](1).\nCall to java.util.Arrays.toString with untrusted data from [msg : String](2).",
        "line_number": 86,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 187
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 187
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 187
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 187
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java#L98",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.qos.api.PermissionLevel;\nimport org.apache.dubbo.qos.command.exception.NoSuchCommandException;\nimport org.apache.dubbo.qos.command.exception.PermissionDenyException;\nimport org.apache.dubbo.qos.common.QosConstants;\nimport org.apache.dubbo.qos.permission.DefaultAnonymousAccessPermissionChecker;\nimport org.apache.dubbo.qos.permission.PermissionChecker;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport io.netty.channel.Channel;\n\npublic class DefaultCommandExecutor implements CommandExecutor {\n    private static final Logger logger = LoggerFactory.getLogger(DefaultCommandExecutor.class);\n    private final FrameworkModel frameworkModel;\n\n    public DefaultCommandExecutor(FrameworkModel frameworkModel) {\n        this.frameworkModel = frameworkModel;\n    }\n\n    @Override\n    public String execute(CommandContext commandContext) throws NoSuchCommandException, PermissionDenyException {\n        String remoteAddress = Optional.ofNullable(commandContext.getRemote())\n                .map(Channel::remoteAddress)\n                .map(Objects::toString)\n                .orElse(\"unknown\");\n\n        logger.info(\"[Dubbo QoS] Command Process start. Command: \" + commandContext.getCommandName() + \", Args: \"\n                + Arrays.toString(commandContext.getArgs()) + \", Remote Address: \" + remoteAddress);\n\n        BaseCommand command = null;\n        try {\n            command =\n                    frameworkModel.getExtensionLoader(BaseCommand.class).getExtension(commandContext.getCommandName());\n        } catch (Throwable throwable) {\n            // can't find command\n        }\n        if (command == null) {\n            logger.info(\"[Dubbo QoS] Command Not found. Command: \" + commandContext.getCommandName()\n                    + \", Remote Address: \" + remoteAddress);\n            throw new NoSuchCommandException(commandContext.getCommandName());\n        }\n\n        // check permission when configs allow anonymous access\n        if (commandContext.isAllowAnonymousAccess()) {\n            PermissionChecker permissionChecker = DefaultAnonymousAccessPermissionChecker.INSTANCE;\n            try {\n                permissionChecker = frameworkModel\n                        .getExtensionLoader(PermissionChecker.class)\n                        .getExtension(QosConstants.QOS_PERMISSION_CHECKER);\n            } catch (Throwable throwable) {\n                // can't find valid custom permissionChecker\n            }\n\n            final Cmd cmd = command.getClass().getAnnotation(Cmd.class);\n            final PermissionLevel cmdRequiredPermissionLevel = cmd.requiredPermissionLevel();\n\n            if (!permissionChecker.access(commandContext, cmdRequiredPermissionLevel)) {\n                logger.info(\n                        \"[Dubbo QoS] Command Deny to access. Command: \" + commandContext.getCommandName() + \", Args: \"\n                                + Arrays.toString(commandContext.getArgs()) + \", Required Permission Level: \"\n                                + cmdRequiredPermissionLevel + \", Remote Address: \"\n                                + remoteAddress);\n                throw new PermissionDenyException(commandContext.getCommandName());\n            }\n        }\n\n        try {\n            String result = command.execute(commandContext, commandContext.getArgs());\n            if (command.logResult()) {\n                logger.info(\"[Dubbo QoS] Command Process success. Command: \" + commandContext.getCommandName()\n                        + \", Args: \"\n                        + Arrays.toString(commandContext.getArgs()) + \", Result: \" + result + \", Remote Address: \"\n                        + remoteAddress);\n            }\n            return result;\n        } catch (Throwable t) {\n            logger.info(\n                    \"[Dubbo QoS] Command Process Failed. Command: \" + commandContext.getCommandName() + \", Args: \"\n                            + Arrays.toString(commandContext.getArgs()) + \", Remote Address: \"\n                            + remoteAddress,\n                    t);\n            throw t;\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 188,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java",
        "line": 98,
        "sink": "java.util.Arrays.toString",
        "source": "-",
        "sourceLine": 98,
        "qualifier": "Call to java.util.Arrays.toString with untrusted data from [msg : HttpRequest](1).\nCall to java.util.Arrays.toString with untrusted data from [msg : String](2).",
        "line_number": 98,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 189
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 189
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 189
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 189
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java#L105",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.qos.api.PermissionLevel;\nimport org.apache.dubbo.qos.command.exception.NoSuchCommandException;\nimport org.apache.dubbo.qos.command.exception.PermissionDenyException;\nimport org.apache.dubbo.qos.common.QosConstants;\nimport org.apache.dubbo.qos.permission.DefaultAnonymousAccessPermissionChecker;\nimport org.apache.dubbo.qos.permission.PermissionChecker;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.util.Arrays;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport io.netty.channel.Channel;\n\npublic class DefaultCommandExecutor implements CommandExecutor {\n    private static final Logger logger = LoggerFactory.getLogger(DefaultCommandExecutor.class);\n    private final FrameworkModel frameworkModel;\n\n    public DefaultCommandExecutor(FrameworkModel frameworkModel) {\n        this.frameworkModel = frameworkModel;\n    }\n\n    @Override\n    public String execute(CommandContext commandContext) throws NoSuchCommandException, PermissionDenyException {\n        String remoteAddress = Optional.ofNullable(commandContext.getRemote())\n                .map(Channel::remoteAddress)\n                .map(Objects::toString)\n                .orElse(\"unknown\");\n\n        logger.info(\"[Dubbo QoS] Command Process start. Command: \" + commandContext.getCommandName() + \", Args: \"\n                + Arrays.toString(commandContext.getArgs()) + \", Remote Address: \" + remoteAddress);\n\n        BaseCommand command = null;\n        try {\n            command =\n                    frameworkModel.getExtensionLoader(BaseCommand.class).getExtension(commandContext.getCommandName());\n        } catch (Throwable throwable) {\n            // can't find command\n        }\n        if (command == null) {\n            logger.info(\"[Dubbo QoS] Command Not found. Command: \" + commandContext.getCommandName()\n                    + \", Remote Address: \" + remoteAddress);\n            throw new NoSuchCommandException(commandContext.getCommandName());\n        }\n\n        // check permission when configs allow anonymous access\n        if (commandContext.isAllowAnonymousAccess()) {\n            PermissionChecker permissionChecker = DefaultAnonymousAccessPermissionChecker.INSTANCE;\n            try {\n                permissionChecker = frameworkModel\n                        .getExtensionLoader(PermissionChecker.class)\n                        .getExtension(QosConstants.QOS_PERMISSION_CHECKER);\n            } catch (Throwable throwable) {\n                // can't find valid custom permissionChecker\n            }\n\n            final Cmd cmd = command.getClass().getAnnotation(Cmd.class);\n            final PermissionLevel cmdRequiredPermissionLevel = cmd.requiredPermissionLevel();\n\n            if (!permissionChecker.access(commandContext, cmdRequiredPermissionLevel)) {\n                logger.info(\n                        \"[Dubbo QoS] Command Deny to access. Command: \" + commandContext.getCommandName() + \", Args: \"\n                                + Arrays.toString(commandContext.getArgs()) + \", Required Permission Level: \"\n                                + cmdRequiredPermissionLevel + \", Remote Address: \"\n                                + remoteAddress);\n                throw new PermissionDenyException(commandContext.getCommandName());\n            }\n        }\n\n        try {\n            String result = command.execute(commandContext, commandContext.getArgs());\n            if (command.logResult()) {\n                logger.info(\"[Dubbo QoS] Command Process success. Command: \" + commandContext.getCommandName()\n                        + \", Args: \"\n                        + Arrays.toString(commandContext.getArgs()) + \", Result: \" + result + \", Remote Address: \"\n                        + remoteAddress);\n            }\n            return result;\n        } catch (Throwable t) {\n            logger.info(\n                    \"[Dubbo QoS] Command Process Failed. Command: \" + commandContext.getCommandName() + \", Args: \"\n                            + Arrays.toString(commandContext.getArgs()) + \", Remote Address: \"\n                            + remoteAddress,\n                    t);\n            throw t;\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 190,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/DefaultCommandExecutor.java",
        "line": 105,
        "sink": "java.util.Arrays.toString",
        "source": "-",
        "sourceLine": 105,
        "qualifier": "Call to java.util.Arrays.toString with untrusted data from [msg : HttpRequest](1).\nCall to java.util.Arrays.toString with untrusted data from [msg : String](2).",
        "line_number": 105,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 191
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 191
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 191
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 191
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Help.java#L52",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command.impl;\n\nimport org.apache.dubbo.common.utils.ArrayUtils;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.qos.command.util.CommandHelper;\nimport org.apache.dubbo.qos.textui.TTable;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\n@Cmd(\n        name = \"help\",\n        summary = \"help command\",\n        example = {\"help\", \"help online\"})\npublic class Help implements BaseCommand {\n\n    private final CommandHelper commandHelper;\n\n    private static final String MAIN_HELP = \"mainHelp\";\n\n    private static final Map<String, String> processedTable = new WeakHashMap<>();\n\n    public Help(FrameworkModel frameworkModel) {\n        this.commandHelper = new CommandHelper(frameworkModel);\n    }\n\n    @Override\n    public String execute(CommandContext commandContext, String[] args) {\n        if (ArrayUtils.isNotEmpty(args)) {\n            return processedTable.computeIfAbsent(args[0], this::commandHelp);\n        } else {\n            return processedTable.computeIfAbsent(MAIN_HELP, commandName -> mainHelp());\n        }\n    }\n\n    private String commandHelp(String commandName) {\n\n        if (!commandHelper.hasCommand(commandName)) {\n            return \"no such command:\" + commandName;\n        }\n\n        Class<?> clazz = commandHelper.getCommandClass(commandName);\n\n        final Cmd cmd = clazz.getAnnotation(Cmd.class);\n        final TTable tTable = new TTable(new TTable.ColumnDefine[] {\n            new TTable.ColumnDefine(TTable.Align.RIGHT), new TTable.ColumnDefine(80, false, TTable.Align.LEFT)\n        });\n\n        tTable.addRow(\"COMMAND NAME\", commandName);\n\n        if (null != cmd.example()) {\n            tTable.addRow(\"EXAMPLE\", drawExample(cmd));\n        }\n\n        return tTable.padding(1).rendering();\n    }\n\n    private String drawExample(Cmd cmd) {\n        final StringBuilder drawExampleStringBuilder = new StringBuilder();\n        for (String example : cmd.example()) {\n            drawExampleStringBuilder.append(example).append('\\n');\n        }\n        return drawExampleStringBuilder.toString();\n    }\n\n    /*\n     * output main help\n     */\n    private String mainHelp() {\n\n        final TTable tTable = new TTable(new TTable.ColumnDefine[] {\n            new TTable.ColumnDefine(TTable.Align.RIGHT), new TTable.ColumnDefine(80, false, TTable.Align.LEFT)\n        });\n\n        final List<Class<?>> classes = commandHelper.getAllCommandClass();\n\n        Collections.sort(classes, new Comparator<Class<?>>() {\n\n            @Override\n            public int compare(Class<?> o1, Class<?> o2) {\n                final Integer o1s = o1.getAnnotation(Cmd.class).sort();\n                final Integer o2s = o2.getAnnotation(Cmd.class).sort();\n                return o1s.compareTo(o2s);\n            }\n        });\n        for (Class<?> clazz : classes) {\n\n            if (clazz.isAnnotationPresent(Cmd.class)) {\n                final Cmd cmd = clazz.getAnnotation(Cmd.class);\n                tTable.addRow(cmd.name(), cmd.summary());\n            }\n        }\n\n        return tTable.padding(1).rendering();\n    }\n}\n",
        "methodName": null,
        "exampleID": 192,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/Help.java",
        "line": 52,
        "sink": "java.util.Map<String,String>.computeIfAbsent",
        "source": "-",
        "sourceLine": 52,
        "qualifier": "Call to java.util.Map<String,String>.computeIfAbsent with untrusted data from [msg : HttpRequest](1).\nCall to java.util.Map<String,String>.computeIfAbsent with untrusted data from [msg : String](2).",
        "line_number": 52,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 193
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 193
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 193
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 193
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/InvokeTelnet.java#L133",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command.impl;\n\nimport org.apache.dubbo.common.utils.ArrayUtils;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.common.utils.JsonUtils;\nimport org.apache.dubbo.common.utils.ReflectUtils;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.rpc.AppResponse;\nimport org.apache.dubbo.rpc.AsyncContext;\nimport org.apache.dubbo.rpc.AsyncContextImpl;\nimport org.apache.dubbo.rpc.RpcContext;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.ProviderModel;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\n\nimport io.netty.channel.Channel;\nimport io.netty.util.AttributeKey;\n\nimport static org.apache.dubbo.common.utils.PojoUtils.realize;\n\n@Cmd(\n        name = \"invoke\",\n        summary = \"Invoke the service method.\",\n        example = {\"invoke IHelloService.sayHello(\\\"xxxx\\\")\", \"invoke sayHello(\\\"xxxx\\\")\"})\npublic class InvokeTelnet implements BaseCommand {\n    public static final AttributeKey<String> INVOKE_MESSAGE_KEY = AttributeKey.valueOf(\"telnet.invoke.method.message\");\n    public static final AttributeKey<List<Method>> INVOKE_METHOD_LIST_KEY =\n            AttributeKey.valueOf(\"telnet.invoke.method.list\");\n    public static final AttributeKey<ProviderModel> INVOKE_METHOD_PROVIDER_KEY =\n            AttributeKey.valueOf(\"telnet.invoke.method.provider\");\n\n    private final FrameworkModel frameworkModel;\n\n    public InvokeTelnet(FrameworkModel frameworkModel) {\n        this.frameworkModel = frameworkModel;\n    }\n\n    @Override\n    public String execute(CommandContext commandContext, String[] args) {\n        if (ArrayUtils.isEmpty(args)) {\n            return \"Please input method name, eg: \\r\\ninvoke xxxMethod(1234, \\\"abcd\\\", {\\\"prop\\\" : \\\"value\\\"})\\r\\n\"\n                    + \"invoke XxxService.xxxMethod(1234, \\\"abcd\\\", {\\\"prop\\\" : \\\"value\\\"})\\r\\n\"\n                    + \"invoke com.xxx.XxxService.xxxMethod(1234, \\\"abcd\\\", {\\\"prop\\\" : \\\"value\\\"})\";\n        }\n        Channel channel = commandContext.getRemote();\n        String service = channel.attr(ChangeTelnet.SERVICE_KEY) != null\n                ? channel.attr(ChangeTelnet.SERVICE_KEY).get()\n                : null;\n\n        String message = args[0];\n        int i = message.indexOf(\"(\");\n\n        if (i < 0 || !message.endsWith(\")\")) {\n            return \"Invalid parameters, format: service.method(args)\";\n        }\n\n        String method = message.substring(0, i).trim();\n        String param = message.substring(i + 1, message.length() - 1).trim();\n        i = method.lastIndexOf(\".\");\n        if (i >= 0) {\n            service = method.substring(0, i).trim();\n            method = method.substring(i + 1).trim();\n        }\n\n        if (StringUtils.isEmpty(service)) {\n            return \"If you want to invoke like [invoke sayHello(\\\"xxxx\\\")], please execute cd command first,\"\n                    + \" or you can execute it like [invoke IHelloService.sayHello(\\\"xxxx\\\")]\";\n        }\n\n        List<Object> list;\n        try {\n            list = JsonUtils.toJavaList(\"[\" + param + \"]\", Object.class);\n        } catch (Throwable t) {\n            return \"Invalid json argument, cause: \" + t.getMessage();\n        }\n        StringBuilder buf = new StringBuilder();\n        Method invokeMethod = null;\n        ProviderModel selectedProvider = null;\n        if (isInvokedSelectCommand(channel)) {\n            selectedProvider = channel.attr(INVOKE_METHOD_PROVIDER_KEY).get();\n            invokeMethod = channel.attr(SelectTelnet.SELECT_METHOD_KEY).get();\n        } else {\n            for (ProviderModel provider : frameworkModel.getServiceRepository().allProviderModels()) {\n                if (!isServiceMatch(service, provider)) {\n                    continue;\n                }\n\n                selectedProvider = provider;\n                List<Method> methodList = findSameSignatureMethod(provider.getAllMethods(), method, list);\n                if (CollectionUtils.isEmpty(methodList)) {\n                    break;\n                }\n\n                if (methodList.size() == 1) {\n                    invokeMethod = methodList.get(0);\n                } else {\n                    List<Method> matchMethods = findMatchMethods(methodList, list);\n                    if (CollectionUtils.isEmpty(matchMethods)) {\n                        break;\n                    }\n                    if (matchMethods.size() == 1) {\n                        invokeMethod = matchMethods.get(0);\n                    } else { // exist overridden method\n                        channel.attr(INVOKE_METHOD_PROVIDER_KEY).set(provider);\n                        channel.attr(INVOKE_METHOD_LIST_KEY).set(matchMethods);\n                        channel.attr(INVOKE_MESSAGE_KEY).set(message);\n                        printSelectMessage(buf, matchMethods);\n                        return buf.toString();\n                    }\n                }\n                break;\n            }\n        }\n\n        if (!StringUtils.isEmpty(service)) {\n            buf.append(\"Use default service \").append(service).append('.');\n        }\n        if (selectedProvider == null) {\n            buf.append(\"\\r\\nNo such service \").append(service);\n            return buf.toString();\n        }\n        if (invokeMethod == null) {\n            buf.append(\"\\r\\nNo such method \")\n                    .append(method)\n                    .append(\" in service \")\n                    .append(service);\n            return buf.toString();\n        }\n        try {\n            Object[] array =\n                    realize(list.toArray(), invokeMethod.getParameterTypes(), invokeMethod.getGenericParameterTypes());\n            long start = System.currentTimeMillis();\n            AppResponse result = new AppResponse();\n            try {\n                Object o = invokeMethod.invoke(selectedProvider.getServiceInstance(), array);\n                boolean setValueDone = false;\n                if (RpcContext.getServerAttachment().isAsyncStarted()) {\n                    AsyncContext asyncContext = RpcContext.getServerAttachment().getAsyncContext();\n                    if (asyncContext instanceof AsyncContextImpl) {\n                        CompletableFuture<Object> internalFuture =\n                                ((AsyncContextImpl) asyncContext).getInternalFuture();\n                        result.setValue(internalFuture.get());\n                        setValueDone = true;\n                    }\n                }\n                if (!setValueDone) {\n                    result.setValue(o);\n                }\n            } catch (Throwable t) {\n                result.setException(t);\n                if (t instanceof InterruptedException) {\n                    Thread.currentThread().interrupt();\n                }\n            } finally {\n                RpcContext.removeContext();\n            }\n            long end = System.currentTimeMillis();\n            buf.append(\"\\r\\nresult: \");\n            buf.append(JsonUtils.toJson(result.recreate()));\n            buf.append(\"\\r\\nelapsed: \");\n            buf.append(end - start);\n            buf.append(\" ms.\");\n        } catch (Throwable t) {\n            return \"Failed to invoke method \" + invokeMethod.getName() + \", cause: \" + StringUtils.toString(t);\n        }\n        return buf.toString();\n    }\n\n    private boolean isServiceMatch(String service, ProviderModel provider) {\n        return provider.getServiceKey().equalsIgnoreCase(service)\n                || provider.getServiceInterfaceClass().getSimpleName().equalsIgnoreCase(service)\n                || provider.getServiceInterfaceClass().getName().equalsIgnoreCase(service)\n                || StringUtils.isEmpty(service);\n    }\n\n    private List<Method> findSameSignatureMethod(\n            Set<MethodDescriptor> methods, String lookupMethodName, List<Object> args) {\n        List<Method> sameSignatureMethods = new ArrayList<>();\n        for (MethodDescriptor model : methods) {\n            Method method = model.getMethod();\n            if (method.getName().equals(lookupMethodName) && method.getParameterTypes().length == args.size()) {\n                sameSignatureMethods.add(method);\n            }\n        }\n        return sameSignatureMethods;\n    }\n\n    private List<Method> findMatchMethods(List<Method> methods, List<Object> args) {\n        List<Method> matchMethod = new ArrayList<>();\n        for (Method method : methods) {\n            if (isMatch(method, args)) {\n                matchMethod.add(method);\n            }\n        }\n        return matchMethod;\n    }\n\n    private static boolean isMatch(Method method, List<Object> args) {\n        Class<?>[] types = method.getParameterTypes();\n        if (types.length != args.size()) {\n            return false;\n        }\n        for (int i = 0; i < types.length; i++) {\n            Class<?> type = types[i];\n            Object arg = args.get(i);\n\n            if (arg == null) {\n                if (type.isPrimitive()) {\n                    return false;\n                }\n\n                // if the type is not primitive, we choose to believe what the invoker want is a null value\n                continue;\n            }\n\n            if (ReflectUtils.isPrimitive(arg.getClass())) {\n                // allow string arg to enum type, @see PojoUtils.realize0()\n                if (arg instanceof String && type.isEnum()) {\n                    continue;\n                }\n\n                if (!ReflectUtils.isPrimitive(type)) {\n                    return false;\n                }\n\n                if (!ReflectUtils.isCompatible(type, arg)) {\n                    return false;\n                }\n            } else if (arg instanceof Map) {\n                String name = (String) ((Map<?, ?>) arg).get(\"class\");\n                if (StringUtils.isNotEmpty(name)) {\n                    Class<?> cls = ReflectUtils.forName(name);\n                    if (!type.isAssignableFrom(cls)) {\n                        return false;\n                    }\n                } else {\n                    return true;\n                }\n            } else if (arg instanceof Collection) {\n                if (!type.isArray() && !type.isAssignableFrom(arg.getClass())) {\n                    return false;\n                }\n            } else {\n                if (!type.isAssignableFrom(arg.getClass())) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private void printSelectMessage(StringBuilder buf, List<Method> methods) {\n        buf.append(\"Methods:\\r\\n\");\n        for (int i = 0; i < methods.size(); i++) {\n            Method method = methods.get(i);\n            buf.append(i + 1).append(\". \").append(method.getName()).append('(');\n            Class<?>[] parameterTypes = method.getParameterTypes();\n            for (int n = 0; n < parameterTypes.length; n++) {\n                buf.append(parameterTypes[n].getSimpleName());\n                if (n != parameterTypes.length - 1) {\n                    buf.append(',');\n                }\n            }\n            buf.append(\")\\r\\n\");\n        }\n        buf.append(\"Please use the select command to select the method you want to invoke. eg: select 1\");\n    }\n\n    private boolean isInvokedSelectCommand(Channel channel) {\n        if (channel.attr(SelectTelnet.SELECT_KEY).get() != null) {\n            channel.attr(SelectTelnet.SELECT_KEY).remove();\n            return true;\n        }\n        return false;\n    }\n}\n",
        "methodName": null,
        "exampleID": 194,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/InvokeTelnet.java",
        "line": 133,
        "sink": "io.netty.util.Attribute<String>.set",
        "source": "-",
        "sourceLine": 133,
        "qualifier": "Call to io.netty.util.Attribute<String>.set with untrusted data from [msg : HttpRequest](1).\nCall to io.netty.util.Attribute<String>.set with untrusted data from [msg : String](2).",
        "line_number": 133,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 195
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 195
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 195
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 195
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/InvokeTelnet.java#L158",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command.impl;\n\nimport org.apache.dubbo.common.utils.ArrayUtils;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.common.utils.JsonUtils;\nimport org.apache.dubbo.common.utils.ReflectUtils;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.rpc.AppResponse;\nimport org.apache.dubbo.rpc.AsyncContext;\nimport org.apache.dubbo.rpc.AsyncContextImpl;\nimport org.apache.dubbo.rpc.RpcContext;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.ProviderModel;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\n\nimport io.netty.channel.Channel;\nimport io.netty.util.AttributeKey;\n\nimport static org.apache.dubbo.common.utils.PojoUtils.realize;\n\n@Cmd(\n        name = \"invoke\",\n        summary = \"Invoke the service method.\",\n        example = {\"invoke IHelloService.sayHello(\\\"xxxx\\\")\", \"invoke sayHello(\\\"xxxx\\\")\"})\npublic class InvokeTelnet implements BaseCommand {\n    public static final AttributeKey<String> INVOKE_MESSAGE_KEY = AttributeKey.valueOf(\"telnet.invoke.method.message\");\n    public static final AttributeKey<List<Method>> INVOKE_METHOD_LIST_KEY =\n            AttributeKey.valueOf(\"telnet.invoke.method.list\");\n    public static final AttributeKey<ProviderModel> INVOKE_METHOD_PROVIDER_KEY =\n            AttributeKey.valueOf(\"telnet.invoke.method.provider\");\n\n    private final FrameworkModel frameworkModel;\n\n    public InvokeTelnet(FrameworkModel frameworkModel) {\n        this.frameworkModel = frameworkModel;\n    }\n\n    @Override\n    public String execute(CommandContext commandContext, String[] args) {\n        if (ArrayUtils.isEmpty(args)) {\n            return \"Please input method name, eg: \\r\\ninvoke xxxMethod(1234, \\\"abcd\\\", {\\\"prop\\\" : \\\"value\\\"})\\r\\n\"\n                    + \"invoke XxxService.xxxMethod(1234, \\\"abcd\\\", {\\\"prop\\\" : \\\"value\\\"})\\r\\n\"\n                    + \"invoke com.xxx.XxxService.xxxMethod(1234, \\\"abcd\\\", {\\\"prop\\\" : \\\"value\\\"})\";\n        }\n        Channel channel = commandContext.getRemote();\n        String service = channel.attr(ChangeTelnet.SERVICE_KEY) != null\n                ? channel.attr(ChangeTelnet.SERVICE_KEY).get()\n                : null;\n\n        String message = args[0];\n        int i = message.indexOf(\"(\");\n\n        if (i < 0 || !message.endsWith(\")\")) {\n            return \"Invalid parameters, format: service.method(args)\";\n        }\n\n        String method = message.substring(0, i).trim();\n        String param = message.substring(i + 1, message.length() - 1).trim();\n        i = method.lastIndexOf(\".\");\n        if (i >= 0) {\n            service = method.substring(0, i).trim();\n            method = method.substring(i + 1).trim();\n        }\n\n        if (StringUtils.isEmpty(service)) {\n            return \"If you want to invoke like [invoke sayHello(\\\"xxxx\\\")], please execute cd command first,\"\n                    + \" or you can execute it like [invoke IHelloService.sayHello(\\\"xxxx\\\")]\";\n        }\n\n        List<Object> list;\n        try {\n            list = JsonUtils.toJavaList(\"[\" + param + \"]\", Object.class);\n        } catch (Throwable t) {\n            return \"Invalid json argument, cause: \" + t.getMessage();\n        }\n        StringBuilder buf = new StringBuilder();\n        Method invokeMethod = null;\n        ProviderModel selectedProvider = null;\n        if (isInvokedSelectCommand(channel)) {\n            selectedProvider = channel.attr(INVOKE_METHOD_PROVIDER_KEY).get();\n            invokeMethod = channel.attr(SelectTelnet.SELECT_METHOD_KEY).get();\n        } else {\n            for (ProviderModel provider : frameworkModel.getServiceRepository().allProviderModels()) {\n                if (!isServiceMatch(service, provider)) {\n                    continue;\n                }\n\n                selectedProvider = provider;\n                List<Method> methodList = findSameSignatureMethod(provider.getAllMethods(), method, list);\n                if (CollectionUtils.isEmpty(methodList)) {\n                    break;\n                }\n\n                if (methodList.size() == 1) {\n                    invokeMethod = methodList.get(0);\n                } else {\n                    List<Method> matchMethods = findMatchMethods(methodList, list);\n                    if (CollectionUtils.isEmpty(matchMethods)) {\n                        break;\n                    }\n                    if (matchMethods.size() == 1) {\n                        invokeMethod = matchMethods.get(0);\n                    } else { // exist overridden method\n                        channel.attr(INVOKE_METHOD_PROVIDER_KEY).set(provider);\n                        channel.attr(INVOKE_METHOD_LIST_KEY).set(matchMethods);\n                        channel.attr(INVOKE_MESSAGE_KEY).set(message);\n                        printSelectMessage(buf, matchMethods);\n                        return buf.toString();\n                    }\n                }\n                break;\n            }\n        }\n\n        if (!StringUtils.isEmpty(service)) {\n            buf.append(\"Use default service \").append(service).append('.');\n        }\n        if (selectedProvider == null) {\n            buf.append(\"\\r\\nNo such service \").append(service);\n            return buf.toString();\n        }\n        if (invokeMethod == null) {\n            buf.append(\"\\r\\nNo such method \")\n                    .append(method)\n                    .append(\" in service \")\n                    .append(service);\n            return buf.toString();\n        }\n        try {\n            Object[] array =\n                    realize(list.toArray(), invokeMethod.getParameterTypes(), invokeMethod.getGenericParameterTypes());\n            long start = System.currentTimeMillis();\n            AppResponse result = new AppResponse();\n            try {\n                Object o = invokeMethod.invoke(selectedProvider.getServiceInstance(), array);\n                boolean setValueDone = false;\n                if (RpcContext.getServerAttachment().isAsyncStarted()) {\n                    AsyncContext asyncContext = RpcContext.getServerAttachment().getAsyncContext();\n                    if (asyncContext instanceof AsyncContextImpl) {\n                        CompletableFuture<Object> internalFuture =\n                                ((AsyncContextImpl) asyncContext).getInternalFuture();\n                        result.setValue(internalFuture.get());\n                        setValueDone = true;\n                    }\n                }\n                if (!setValueDone) {\n                    result.setValue(o);\n                }\n            } catch (Throwable t) {\n                result.setException(t);\n                if (t instanceof InterruptedException) {\n                    Thread.currentThread().interrupt();\n                }\n            } finally {\n                RpcContext.removeContext();\n            }\n            long end = System.currentTimeMillis();\n            buf.append(\"\\r\\nresult: \");\n            buf.append(JsonUtils.toJson(result.recreate()));\n            buf.append(\"\\r\\nelapsed: \");\n            buf.append(end - start);\n            buf.append(\" ms.\");\n        } catch (Throwable t) {\n            return \"Failed to invoke method \" + invokeMethod.getName() + \", cause: \" + StringUtils.toString(t);\n        }\n        return buf.toString();\n    }\n\n    private boolean isServiceMatch(String service, ProviderModel provider) {\n        return provider.getServiceKey().equalsIgnoreCase(service)\n                || provider.getServiceInterfaceClass().getSimpleName().equalsIgnoreCase(service)\n                || provider.getServiceInterfaceClass().getName().equalsIgnoreCase(service)\n                || StringUtils.isEmpty(service);\n    }\n\n    private List<Method> findSameSignatureMethod(\n            Set<MethodDescriptor> methods, String lookupMethodName, List<Object> args) {\n        List<Method> sameSignatureMethods = new ArrayList<>();\n        for (MethodDescriptor model : methods) {\n            Method method = model.getMethod();\n            if (method.getName().equals(lookupMethodName) && method.getParameterTypes().length == args.size()) {\n                sameSignatureMethods.add(method);\n            }\n        }\n        return sameSignatureMethods;\n    }\n\n    private List<Method> findMatchMethods(List<Method> methods, List<Object> args) {\n        List<Method> matchMethod = new ArrayList<>();\n        for (Method method : methods) {\n            if (isMatch(method, args)) {\n                matchMethod.add(method);\n            }\n        }\n        return matchMethod;\n    }\n\n    private static boolean isMatch(Method method, List<Object> args) {\n        Class<?>[] types = method.getParameterTypes();\n        if (types.length != args.size()) {\n            return false;\n        }\n        for (int i = 0; i < types.length; i++) {\n            Class<?> type = types[i];\n            Object arg = args.get(i);\n\n            if (arg == null) {\n                if (type.isPrimitive()) {\n                    return false;\n                }\n\n                // if the type is not primitive, we choose to believe what the invoker want is a null value\n                continue;\n            }\n\n            if (ReflectUtils.isPrimitive(arg.getClass())) {\n                // allow string arg to enum type, @see PojoUtils.realize0()\n                if (arg instanceof String && type.isEnum()) {\n                    continue;\n                }\n\n                if (!ReflectUtils.isPrimitive(type)) {\n                    return false;\n                }\n\n                if (!ReflectUtils.isCompatible(type, arg)) {\n                    return false;\n                }\n            } else if (arg instanceof Map) {\n                String name = (String) ((Map<?, ?>) arg).get(\"class\");\n                if (StringUtils.isNotEmpty(name)) {\n                    Class<?> cls = ReflectUtils.forName(name);\n                    if (!type.isAssignableFrom(cls)) {\n                        return false;\n                    }\n                } else {\n                    return true;\n                }\n            } else if (arg instanceof Collection) {\n                if (!type.isArray() && !type.isAssignableFrom(arg.getClass())) {\n                    return false;\n                }\n            } else {\n                if (!type.isAssignableFrom(arg.getClass())) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private void printSelectMessage(StringBuilder buf, List<Method> methods) {\n        buf.append(\"Methods:\\r\\n\");\n        for (int i = 0; i < methods.size(); i++) {\n            Method method = methods.get(i);\n            buf.append(i + 1).append(\". \").append(method.getName()).append('(');\n            Class<?>[] parameterTypes = method.getParameterTypes();\n            for (int n = 0; n < parameterTypes.length; n++) {\n                buf.append(parameterTypes[n].getSimpleName());\n                if (n != parameterTypes.length - 1) {\n                    buf.append(',');\n                }\n            }\n            buf.append(\")\\r\\n\");\n        }\n        buf.append(\"Please use the select command to select the method you want to invoke. eg: select 1\");\n    }\n\n    private boolean isInvokedSelectCommand(Channel channel) {\n        if (channel.attr(SelectTelnet.SELECT_KEY).get() != null) {\n            channel.attr(SelectTelnet.SELECT_KEY).remove();\n            return true;\n        }\n        return false;\n    }\n}\n",
        "methodName": null,
        "exampleID": 196,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/InvokeTelnet.java",
        "line": 158,
        "sink": "java.util.List<Object>.toArray",
        "source": "-",
        "sourceLine": 158,
        "qualifier": "Call to java.util.List<Object>.toArray with untrusted data from [msg : HttpRequest](1).\nCall to java.util.List<Object>.toArray with untrusted data from [msg : String](2).",
        "line_number": 158,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 197
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 197
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 197
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 197
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/InvokeTelnet.java#L162",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command.impl;\n\nimport org.apache.dubbo.common.utils.ArrayUtils;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.common.utils.JsonUtils;\nimport org.apache.dubbo.common.utils.ReflectUtils;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.rpc.AppResponse;\nimport org.apache.dubbo.rpc.AsyncContext;\nimport org.apache.dubbo.rpc.AsyncContextImpl;\nimport org.apache.dubbo.rpc.RpcContext;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.ProviderModel;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\n\nimport io.netty.channel.Channel;\nimport io.netty.util.AttributeKey;\n\nimport static org.apache.dubbo.common.utils.PojoUtils.realize;\n\n@Cmd(\n        name = \"invoke\",\n        summary = \"Invoke the service method.\",\n        example = {\"invoke IHelloService.sayHello(\\\"xxxx\\\")\", \"invoke sayHello(\\\"xxxx\\\")\"})\npublic class InvokeTelnet implements BaseCommand {\n    public static final AttributeKey<String> INVOKE_MESSAGE_KEY = AttributeKey.valueOf(\"telnet.invoke.method.message\");\n    public static final AttributeKey<List<Method>> INVOKE_METHOD_LIST_KEY =\n            AttributeKey.valueOf(\"telnet.invoke.method.list\");\n    public static final AttributeKey<ProviderModel> INVOKE_METHOD_PROVIDER_KEY =\n            AttributeKey.valueOf(\"telnet.invoke.method.provider\");\n\n    private final FrameworkModel frameworkModel;\n\n    public InvokeTelnet(FrameworkModel frameworkModel) {\n        this.frameworkModel = frameworkModel;\n    }\n\n    @Override\n    public String execute(CommandContext commandContext, String[] args) {\n        if (ArrayUtils.isEmpty(args)) {\n            return \"Please input method name, eg: \\r\\ninvoke xxxMethod(1234, \\\"abcd\\\", {\\\"prop\\\" : \\\"value\\\"})\\r\\n\"\n                    + \"invoke XxxService.xxxMethod(1234, \\\"abcd\\\", {\\\"prop\\\" : \\\"value\\\"})\\r\\n\"\n                    + \"invoke com.xxx.XxxService.xxxMethod(1234, \\\"abcd\\\", {\\\"prop\\\" : \\\"value\\\"})\";\n        }\n        Channel channel = commandContext.getRemote();\n        String service = channel.attr(ChangeTelnet.SERVICE_KEY) != null\n                ? channel.attr(ChangeTelnet.SERVICE_KEY).get()\n                : null;\n\n        String message = args[0];\n        int i = message.indexOf(\"(\");\n\n        if (i < 0 || !message.endsWith(\")\")) {\n            return \"Invalid parameters, format: service.method(args)\";\n        }\n\n        String method = message.substring(0, i).trim();\n        String param = message.substring(i + 1, message.length() - 1).trim();\n        i = method.lastIndexOf(\".\");\n        if (i >= 0) {\n            service = method.substring(0, i).trim();\n            method = method.substring(i + 1).trim();\n        }\n\n        if (StringUtils.isEmpty(service)) {\n            return \"If you want to invoke like [invoke sayHello(\\\"xxxx\\\")], please execute cd command first,\"\n                    + \" or you can execute it like [invoke IHelloService.sayHello(\\\"xxxx\\\")]\";\n        }\n\n        List<Object> list;\n        try {\n            list = JsonUtils.toJavaList(\"[\" + param + \"]\", Object.class);\n        } catch (Throwable t) {\n            return \"Invalid json argument, cause: \" + t.getMessage();\n        }\n        StringBuilder buf = new StringBuilder();\n        Method invokeMethod = null;\n        ProviderModel selectedProvider = null;\n        if (isInvokedSelectCommand(channel)) {\n            selectedProvider = channel.attr(INVOKE_METHOD_PROVIDER_KEY).get();\n            invokeMethod = channel.attr(SelectTelnet.SELECT_METHOD_KEY).get();\n        } else {\n            for (ProviderModel provider : frameworkModel.getServiceRepository().allProviderModels()) {\n                if (!isServiceMatch(service, provider)) {\n                    continue;\n                }\n\n                selectedProvider = provider;\n                List<Method> methodList = findSameSignatureMethod(provider.getAllMethods(), method, list);\n                if (CollectionUtils.isEmpty(methodList)) {\n                    break;\n                }\n\n                if (methodList.size() == 1) {\n                    invokeMethod = methodList.get(0);\n                } else {\n                    List<Method> matchMethods = findMatchMethods(methodList, list);\n                    if (CollectionUtils.isEmpty(matchMethods)) {\n                        break;\n                    }\n                    if (matchMethods.size() == 1) {\n                        invokeMethod = matchMethods.get(0);\n                    } else { // exist overridden method\n                        channel.attr(INVOKE_METHOD_PROVIDER_KEY).set(provider);\n                        channel.attr(INVOKE_METHOD_LIST_KEY).set(matchMethods);\n                        channel.attr(INVOKE_MESSAGE_KEY).set(message);\n                        printSelectMessage(buf, matchMethods);\n                        return buf.toString();\n                    }\n                }\n                break;\n            }\n        }\n\n        if (!StringUtils.isEmpty(service)) {\n            buf.append(\"Use default service \").append(service).append('.');\n        }\n        if (selectedProvider == null) {\n            buf.append(\"\\r\\nNo such service \").append(service);\n            return buf.toString();\n        }\n        if (invokeMethod == null) {\n            buf.append(\"\\r\\nNo such method \")\n                    .append(method)\n                    .append(\" in service \")\n                    .append(service);\n            return buf.toString();\n        }\n        try {\n            Object[] array =\n                    realize(list.toArray(), invokeMethod.getParameterTypes(), invokeMethod.getGenericParameterTypes());\n            long start = System.currentTimeMillis();\n            AppResponse result = new AppResponse();\n            try {\n                Object o = invokeMethod.invoke(selectedProvider.getServiceInstance(), array);\n                boolean setValueDone = false;\n                if (RpcContext.getServerAttachment().isAsyncStarted()) {\n                    AsyncContext asyncContext = RpcContext.getServerAttachment().getAsyncContext();\n                    if (asyncContext instanceof AsyncContextImpl) {\n                        CompletableFuture<Object> internalFuture =\n                                ((AsyncContextImpl) asyncContext).getInternalFuture();\n                        result.setValue(internalFuture.get());\n                        setValueDone = true;\n                    }\n                }\n                if (!setValueDone) {\n                    result.setValue(o);\n                }\n            } catch (Throwable t) {\n                result.setException(t);\n                if (t instanceof InterruptedException) {\n                    Thread.currentThread().interrupt();\n                }\n            } finally {\n                RpcContext.removeContext();\n            }\n            long end = System.currentTimeMillis();\n            buf.append(\"\\r\\nresult: \");\n            buf.append(JsonUtils.toJson(result.recreate()));\n            buf.append(\"\\r\\nelapsed: \");\n            buf.append(end - start);\n            buf.append(\" ms.\");\n        } catch (Throwable t) {\n            return \"Failed to invoke method \" + invokeMethod.getName() + \", cause: \" + StringUtils.toString(t);\n        }\n        return buf.toString();\n    }\n\n    private boolean isServiceMatch(String service, ProviderModel provider) {\n        return provider.getServiceKey().equalsIgnoreCase(service)\n                || provider.getServiceInterfaceClass().getSimpleName().equalsIgnoreCase(service)\n                || provider.getServiceInterfaceClass().getName().equalsIgnoreCase(service)\n                || StringUtils.isEmpty(service);\n    }\n\n    private List<Method> findSameSignatureMethod(\n            Set<MethodDescriptor> methods, String lookupMethodName, List<Object> args) {\n        List<Method> sameSignatureMethods = new ArrayList<>();\n        for (MethodDescriptor model : methods) {\n            Method method = model.getMethod();\n            if (method.getName().equals(lookupMethodName) && method.getParameterTypes().length == args.size()) {\n                sameSignatureMethods.add(method);\n            }\n        }\n        return sameSignatureMethods;\n    }\n\n    private List<Method> findMatchMethods(List<Method> methods, List<Object> args) {\n        List<Method> matchMethod = new ArrayList<>();\n        for (Method method : methods) {\n            if (isMatch(method, args)) {\n                matchMethod.add(method);\n            }\n        }\n        return matchMethod;\n    }\n\n    private static boolean isMatch(Method method, List<Object> args) {\n        Class<?>[] types = method.getParameterTypes();\n        if (types.length != args.size()) {\n            return false;\n        }\n        for (int i = 0; i < types.length; i++) {\n            Class<?> type = types[i];\n            Object arg = args.get(i);\n\n            if (arg == null) {\n                if (type.isPrimitive()) {\n                    return false;\n                }\n\n                // if the type is not primitive, we choose to believe what the invoker want is a null value\n                continue;\n            }\n\n            if (ReflectUtils.isPrimitive(arg.getClass())) {\n                // allow string arg to enum type, @see PojoUtils.realize0()\n                if (arg instanceof String && type.isEnum()) {\n                    continue;\n                }\n\n                if (!ReflectUtils.isPrimitive(type)) {\n                    return false;\n                }\n\n                if (!ReflectUtils.isCompatible(type, arg)) {\n                    return false;\n                }\n            } else if (arg instanceof Map) {\n                String name = (String) ((Map<?, ?>) arg).get(\"class\");\n                if (StringUtils.isNotEmpty(name)) {\n                    Class<?> cls = ReflectUtils.forName(name);\n                    if (!type.isAssignableFrom(cls)) {\n                        return false;\n                    }\n                } else {\n                    return true;\n                }\n            } else if (arg instanceof Collection) {\n                if (!type.isArray() && !type.isAssignableFrom(arg.getClass())) {\n                    return false;\n                }\n            } else {\n                if (!type.isAssignableFrom(arg.getClass())) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private void printSelectMessage(StringBuilder buf, List<Method> methods) {\n        buf.append(\"Methods:\\r\\n\");\n        for (int i = 0; i < methods.size(); i++) {\n            Method method = methods.get(i);\n            buf.append(i + 1).append(\". \").append(method.getName()).append('(');\n            Class<?>[] parameterTypes = method.getParameterTypes();\n            for (int n = 0; n < parameterTypes.length; n++) {\n                buf.append(parameterTypes[n].getSimpleName());\n                if (n != parameterTypes.length - 1) {\n                    buf.append(',');\n                }\n            }\n            buf.append(\")\\r\\n\");\n        }\n        buf.append(\"Please use the select command to select the method you want to invoke. eg: select 1\");\n    }\n\n    private boolean isInvokedSelectCommand(Channel channel) {\n        if (channel.attr(SelectTelnet.SELECT_KEY).get() != null) {\n            channel.attr(SelectTelnet.SELECT_KEY).remove();\n            return true;\n        }\n        return false;\n    }\n}\n",
        "methodName": null,
        "exampleID": 198,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/InvokeTelnet.java",
        "line": 162,
        "sink": "java.lang.reflect.Method.invoke",
        "source": "-",
        "sourceLine": 162,
        "qualifier": "Call to java.lang.reflect.Method.invoke with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.reflect.Method.invoke with untrusted data from [msg : String](2).",
        "line_number": 162,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 199
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 199
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 199
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 199
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/PwdTelnet.java#L34",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command.impl;\n\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\n\nimport java.util.Arrays;\n\n@Cmd(\n        name = \"pwd\",\n        summary = \"Print working default service.\",\n        example = {\"pwd\"})\npublic class PwdTelnet implements BaseCommand {\n    @Override\n    public String execute(CommandContext commandContext, String[] args) {\n        if (args.length > 0) {\n            return \"Unsupported parameter \" + Arrays.toString(args) + \" for pwd.\";\n        }\n        String service =\n                commandContext.getRemote().attr(ChangeTelnet.SERVICE_KEY).get();\n        StringBuilder buf = new StringBuilder();\n        if (StringUtils.isEmpty(service)) {\n            buf.append('/');\n        } else {\n            buf.append(service);\n        }\n        return buf.toString();\n    }\n}\n",
        "methodName": null,
        "exampleID": 200,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/PwdTelnet.java",
        "line": 34,
        "sink": "java.util.Arrays.toString",
        "source": "-",
        "sourceLine": 34,
        "qualifier": "Call to java.util.Arrays.toString with untrusted data from [msg : HttpRequest](1).\nCall to java.util.Arrays.toString with untrusted data from [msg : String](2).",
        "line_number": 34,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 201
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 201
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 201
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 201
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/PublishMetadata.java#L72",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command.impl;\n\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.threadpool.manager.FrameworkExecutorRepository;\nimport org.apache.dubbo.common.utils.ArrayUtils;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.registry.client.metadata.ServiceInstanceMetadataUtils;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.CONFIG_PARAMETER_FORMAT_ERROR;\n\n@Cmd(\n        name = \"publishMetadata\",\n        summary = \"update service metadata and service instance\",\n        example = {\"publishMetadata\", \"publishMetadata 5\"})\npublic class PublishMetadata implements BaseCommand {\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(PublishMetadata.class);\n    private final FrameworkModel frameworkModel;\n\n    public PublishMetadata(FrameworkModel frameworkModel) {\n        this.frameworkModel = frameworkModel;\n    }\n\n    @Override\n    public String execute(CommandContext commandContext, String[] args) {\n        logger.info(\"received publishMetadata command.\");\n\n        StringBuilder stringBuilder = new StringBuilder();\n        List<ApplicationModel> applicationModels = frameworkModel.getApplicationModels();\n\n        for (ApplicationModel applicationModel : applicationModels) {\n            if (ArrayUtils.isEmpty(args)) {\n                ServiceInstanceMetadataUtils.refreshMetadataAndInstance(applicationModel);\n                stringBuilder\n                        .append(\"publish metadata succeeded. App:\")\n                        .append(applicationModel.getApplicationName())\n                        .append(\"\\n\");\n            } else {\n                try {\n                    int delay = Integer.parseInt(args[0]);\n                    FrameworkExecutorRepository frameworkExecutorRepository = applicationModel\n                            .getFrameworkModel()\n                            .getBeanFactory()\n                            .getBean(FrameworkExecutorRepository.class);\n                    frameworkExecutorRepository\n                            .nextScheduledExecutor()\n                            .schedule(\n                                    () -> ServiceInstanceMetadataUtils.refreshMetadataAndInstance(applicationModel),\n                                    delay,\n                                    TimeUnit.SECONDS);\n                } catch (NumberFormatException e) {\n                    logger.error(CONFIG_PARAMETER_FORMAT_ERROR, \"\", \"\", \"Wrong delay param\", e);\n                    return \"publishMetadata failed! Wrong delay param!\";\n                }\n                stringBuilder\n                        .append(\"publish task submitted, will publish in \")\n                        .append(args[0])\n                        .append(\" seconds. App:\")\n                        .append(applicationModel.getApplicationName())\n                        .append(\"\\n\");\n            }\n        }\n        return stringBuilder.toString();\n    }\n}\n",
        "methodName": null,
        "exampleID": 202,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/PublishMetadata.java",
        "line": 72,
        "sink": "java.util.concurrent.ScheduledExecutorService.schedule",
        "source": "-",
        "sourceLine": 72,
        "qualifier": "Call to java.util.concurrent.ScheduledExecutorService.schedule with untrusted data from [msg : HttpRequest](1).\nCall to java.util.concurrent.ScheduledExecutorService.schedule with untrusted data from [msg : String](2).",
        "line_number": 72,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 203
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 203
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 203
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 203
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/ShutdownTelnet.java#L55",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command.impl;\n\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\nimport org.apache.dubbo.rpc.model.ApplicationModel;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Cmd(\n        name = \"shutdown\",\n        summary = \"Shutdown Dubbo Application.\",\n        example = {\"shutdown -t <milliseconds>\"})\npublic class ShutdownTelnet implements BaseCommand {\n\n    private final FrameworkModel frameworkModel;\n\n    public ShutdownTelnet(FrameworkModel frameworkModel) {\n        this.frameworkModel = frameworkModel;\n    }\n\n    @Override\n    public String execute(CommandContext commandContext, String[] args) {\n\n        int sleepMilliseconds = 0;\n        if (args != null && args.length > 0) {\n            if (args.length == 2 && \"-t\".equals(args[0]) && StringUtils.isNumber(args[1])) {\n                sleepMilliseconds = Integer.parseInt(args[1]);\n            } else {\n                return \"Invalid parameter,please input like shutdown -t 10000\";\n            }\n        }\n        long start = System.currentTimeMillis();\n        if (sleepMilliseconds > 0) {\n            try {\n                Thread.sleep(sleepMilliseconds);\n            } catch (InterruptedException e) {\n                return \"Failed to invoke shutdown command, cause: \" + e.getMessage();\n            }\n        }\n        StringBuilder buf = new StringBuilder();\n        List<ApplicationModel> applicationModels = frameworkModel.getApplicationModels();\n        for (ApplicationModel applicationModel : new ArrayList<>(applicationModels)) {\n            applicationModel.destroy();\n        }\n        // TODO change to ApplicationDeployer.destroy() or ApplicationModel.destroy()\n        //        DubboShutdownHook.getDubboShutdownHook().unregister();\n        //        DubboShutdownHook.getDubboShutdownHook().doDestroy();\n        long end = System.currentTimeMillis();\n        buf.append(\"Application has shutdown successfully\");\n        buf.append(\"\\r\\nelapsed: \");\n        buf.append(end - start);\n        buf.append(\" ms.\");\n        return buf.toString();\n    }\n}\n",
        "methodName": null,
        "exampleID": 204,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/ShutdownTelnet.java",
        "line": 55,
        "sink": "java.lang.Thread.sleep",
        "source": "-",
        "sourceLine": 55,
        "qualifier": "Call to java.lang.Thread.sleep with untrusted data from [msg : HttpRequest](1).\nCall to java.lang.Thread.sleep with untrusted data from [msg : String](2).",
        "line_number": 55,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 205
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 205
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 205
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 205
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/SwitchLogLevel.java#L61",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.command.impl;\n\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.qos.api.BaseCommand;\nimport org.apache.dubbo.qos.api.Cmd;\nimport org.apache.dubbo.qos.api.CommandContext;\n\nimport java.util.Locale;\n\n@Cmd(\n        name = \"switchLogLevel\",\n        summary = \"Switch log level\",\n        example = {\"switchLogLevel info\"})\npublic class SwitchLogLevel implements BaseCommand {\n    @Override\n    public String execute(CommandContext commandContext, String[] args) {\n        if (args.length != 1) {\n            return \"Unexpected argument length.\";\n        }\n        Level level;\n        switch (args[0]) {\n            case \"0\":\n                level = Level.ALL;\n                break;\n            case \"1\":\n                level = Level.TRACE;\n                break;\n            case \"2\":\n                level = Level.DEBUG;\n                break;\n            case \"3\":\n                level = Level.INFO;\n                break;\n            case \"4\":\n                level = Level.WARN;\n                break;\n            case \"5\":\n                level = Level.ERROR;\n                break;\n            case \"6\":\n                level = Level.OFF;\n                break;\n            default:\n                level = Level.valueOf(args[0].toUpperCase(Locale.ROOT));\n                break;\n        }\n        LoggerFactory.setLevel(level);\n        return \"OK\";\n    }\n}\n",
        "methodName": null,
        "exampleID": 206,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/command/impl/SwitchLogLevel.java",
        "line": 61,
        "sink": "org.apache.dubbo.common.logger.Level.valueOf",
        "source": "-",
        "sourceLine": 61,
        "qualifier": "Call to org.apache.dubbo.common.logger.Level.valueOf with untrusted data from [msg : HttpRequest](1).\nCall to org.apache.dubbo.common.logger.Level.valueOf with untrusted data from [msg : String](2).",
        "line_number": 61,
        "steps": [
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 207
            },
            {
                "line": 88,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/HttpProcessHandler.java",
                "methodName": null,
                "exampleID": 207
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 207
            },
            {
                "line": 56,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/TelnetProcessHandler.java",
                "methodName": null,
                "exampleID": 207
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/legacy/LogTelnetHandler.java#L53",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.legacy;\n\nimport org.apache.dubbo.common.extension.Activate;\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.remoting.Channel;\nimport org.apache.dubbo.remoting.telnet.TelnetHandler;\nimport org.apache.dubbo.remoting.telnet.support.Help;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * LogTelnetHandler\n */\n@Activate\n@Help(parameter = \"level\", summary = \"Change log level or show log \", detail = \"Change log level or show log\")\npublic class LogTelnetHandler implements TelnetHandler {\n\n    public static final String SERVICE_KEY = \"telnet.log\";\n\n    @Override\n    public String telnet(Channel channel, String message) {\n        long size;\n        File file = LoggerFactory.getFile();\n        StringBuilder buf = new StringBuilder();\n        if (message == null || message.trim().length() == 0) {\n            buf.append(\"EXAMPLE: log error / log 100\");\n        } else {\n            String[] str = message.split(\" \");\n            if (!StringUtils.isNumber(str[0])) {\n                LoggerFactory.setLevel(Level.valueOf(message.toUpperCase()));\n            } else {\n                int showLogLength = Integer.parseInt(str[0]);\n\n                if (file != null && file.exists()) {\n                    try (FileInputStream fis = new FileInputStream(file)) {\n                        FileChannel filechannel = fis.getChannel();\n                        size = filechannel.size();\n                        ByteBuffer bb;\n                        if (size <= showLogLength) {\n                            bb = ByteBuffer.allocate((int) size);\n                            filechannel.read(bb, 0);\n                        } else {\n                            int pos = (int) (size - showLogLength);\n                            bb = ByteBuffer.allocate(showLogLength);\n                            filechannel.read(bb, pos);\n                        }\n                        bb.flip();\n                        String content = new String(bb.array())\n                                .replace(\"<\", \"&lt;\")\n                                .replace(\">\", \"&gt;\")\n                                .replace(\"\\n\", \"<br/><br/>\");\n                        buf.append(\"\\r\\ncontent:\").append(content);\n\n                        buf.append(\"\\r\\nmodified:\")\n                                .append(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")\n                                        .format(new Date(file.lastModified())));\n                        buf.append(\"\\r\\nsize:\").append(size).append(\"\\r\\n\");\n                    } catch (Exception e) {\n                        buf.append(e.getMessage());\n                    }\n                } else {\n                    buf.append(\"\\r\\nMESSAGE: log file not exists or log appender is console .\");\n                }\n            }\n        }\n        buf.append(\"\\r\\nCURRENT LOG LEVEL:\")\n                .append(LoggerFactory.getLevel())\n                .append(\"\\r\\nCURRENT LOG APPENDER:\")\n                .append(file == null ? \"console\" : file.getAbsolutePath());\n        return buf.toString();\n    }\n}\n",
        "methodName": null,
        "exampleID": 208,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/legacy/LogTelnetHandler.java",
        "line": 53,
        "sink": "org.apache.dubbo.common.logger.Level.valueOf",
        "source": "-",
        "sourceLine": 53,
        "qualifier": "Call to org.apache.dubbo.common.logger.Level.valueOf with untrusted data from [msg : Object](1).\nCall to org.apache.dubbo.common.logger.Level.valueOf with untrusted data from [msg : Object](2).\nCall to org.apache.dubbo.common.logger.Level.valueOf with untrusted data from [msg : Object](3).",
        "line_number": 53,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 209
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 209
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 209
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 209
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/legacy/LogTelnetHandler.java#L67",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.legacy;\n\nimport org.apache.dubbo.common.extension.Activate;\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.remoting.Channel;\nimport org.apache.dubbo.remoting.telnet.TelnetHandler;\nimport org.apache.dubbo.remoting.telnet.support.Help;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * LogTelnetHandler\n */\n@Activate\n@Help(parameter = \"level\", summary = \"Change log level or show log \", detail = \"Change log level or show log\")\npublic class LogTelnetHandler implements TelnetHandler {\n\n    public static final String SERVICE_KEY = \"telnet.log\";\n\n    @Override\n    public String telnet(Channel channel, String message) {\n        long size;\n        File file = LoggerFactory.getFile();\n        StringBuilder buf = new StringBuilder();\n        if (message == null || message.trim().length() == 0) {\n            buf.append(\"EXAMPLE: log error / log 100\");\n        } else {\n            String[] str = message.split(\" \");\n            if (!StringUtils.isNumber(str[0])) {\n                LoggerFactory.setLevel(Level.valueOf(message.toUpperCase()));\n            } else {\n                int showLogLength = Integer.parseInt(str[0]);\n\n                if (file != null && file.exists()) {\n                    try (FileInputStream fis = new FileInputStream(file)) {\n                        FileChannel filechannel = fis.getChannel();\n                        size = filechannel.size();\n                        ByteBuffer bb;\n                        if (size <= showLogLength) {\n                            bb = ByteBuffer.allocate((int) size);\n                            filechannel.read(bb, 0);\n                        } else {\n                            int pos = (int) (size - showLogLength);\n                            bb = ByteBuffer.allocate(showLogLength);\n                            filechannel.read(bb, pos);\n                        }\n                        bb.flip();\n                        String content = new String(bb.array())\n                                .replace(\"<\", \"&lt;\")\n                                .replace(\">\", \"&gt;\")\n                                .replace(\"\\n\", \"<br/><br/>\");\n                        buf.append(\"\\r\\ncontent:\").append(content);\n\n                        buf.append(\"\\r\\nmodified:\")\n                                .append(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")\n                                        .format(new Date(file.lastModified())));\n                        buf.append(\"\\r\\nsize:\").append(size).append(\"\\r\\n\");\n                    } catch (Exception e) {\n                        buf.append(e.getMessage());\n                    }\n                } else {\n                    buf.append(\"\\r\\nMESSAGE: log file not exists or log appender is console .\");\n                }\n            }\n        }\n        buf.append(\"\\r\\nCURRENT LOG LEVEL:\")\n                .append(LoggerFactory.getLevel())\n                .append(\"\\r\\nCURRENT LOG APPENDER:\")\n                .append(file == null ? \"console\" : file.getAbsolutePath());\n        return buf.toString();\n    }\n}\n",
        "methodName": null,
        "exampleID": 210,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/legacy/LogTelnetHandler.java",
        "line": 67,
        "sink": "java.nio.ByteBuffer.allocate",
        "source": "-",
        "sourceLine": 67,
        "qualifier": "Call to java.nio.ByteBuffer.allocate with untrusted data from [msg : Object](1).\nCall to java.nio.ByteBuffer.allocate with untrusted data from [msg : Object](2).\nCall to java.nio.ByteBuffer.allocate with untrusted data from [msg : Object](3).",
        "line_number": 67,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 211
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 211
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 211
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 211
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/QosProcessHandler.java#L78",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.qos.server.handler;\n\nimport org.apache.dubbo.common.utils.ExecutorUtil;\nimport org.apache.dubbo.qos.api.QosConfiguration;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.codec.LineBasedFrameDecoder;\nimport io.netty.handler.codec.http.HttpObjectAggregator;\nimport io.netty.handler.codec.http.HttpServerCodec;\nimport io.netty.handler.codec.string.StringDecoder;\nimport io.netty.handler.codec.string.StringEncoder;\nimport io.netty.handler.timeout.IdleStateEvent;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.concurrent.ScheduledFuture;\n\npublic class QosProcessHandler extends ByteToMessageDecoder {\n\n    private ScheduledFuture<?> welcomeFuture;\n\n    private final FrameworkModel frameworkModel;\n\n    public static final String PROMPT = \"dubbo>\";\n\n    private final QosConfiguration qosConfiguration;\n\n    public QosProcessHandler(FrameworkModel frameworkModel, QosConfiguration qosConfiguration) {\n        this.frameworkModel = frameworkModel;\n        this.qosConfiguration = qosConfiguration;\n    }\n\n    @Override\n    public void channelActive(final ChannelHandlerContext ctx) throws Exception {\n        welcomeFuture = ctx.executor()\n                .schedule(\n                        () -> {\n                            final String welcome = qosConfiguration.getWelcome();\n                            if (welcome != null) {\n                                ctx.write(Unpooled.wrappedBuffer(welcome.getBytes()));\n                                ctx.writeAndFlush(Unpooled.wrappedBuffer(PROMPT.getBytes()));\n                            }\n                        },\n                        500,\n                        TimeUnit.MILLISECONDS);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        if (in.readableBytes() < 1) {\n            return;\n        }\n\n        // read one byte to guess protocol\n        final int magic = in.getByte(in.readerIndex());\n\n        ChannelPipeline p = ctx.pipeline();\n        p.addLast(new ForeignHostPermitHandler(qosConfiguration));\n        if (isHttp(magic)) {\n            // no welcome output for http protocol\n            if (welcomeFuture != null && welcomeFuture.isCancellable()) {\n                welcomeFuture.cancel(false);\n            }\n            p.addLast(new HttpServerCodec());\n            p.addLast(new HttpObjectAggregator(1048576));\n            p.addLast(new HttpProcessHandler(frameworkModel, qosConfiguration));\n            p.remove(this);\n        } else {\n            p.addLast(new LineBasedFrameDecoder(2048));\n            p.addLast(new StringDecoder(CharsetUtil.UTF_8));\n            p.addLast(new StringEncoder(CharsetUtil.UTF_8));\n            p.addLast(new IdleStateHandler(0, 0, 5 * 60));\n            p.addLast(new TelnetIdleEventHandler());\n            p.addLast(new TelnetProcessHandler(frameworkModel, qosConfiguration));\n            p.remove(this);\n        }\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        if (evt instanceof IdleStateEvent) {\n            ExecutorUtil.cancelScheduledFuture(welcomeFuture);\n            ctx.close();\n        }\n    }\n\n    // G for GET, and P for POST\n    private static boolean isHttp(int magic) {\n        return magic == 'G' || magic == 'P';\n    }\n}\n",
        "methodName": null,
        "exampleID": 212,
        "dataset": "codeql",
        "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/QosProcessHandler.java",
        "line": 78,
        "sink": "io.netty.buffer.ByteBuf.readerIndex",
        "source": "-",
        "sourceLine": 78,
        "qualifier": "Call to io.netty.buffer.ByteBuf.readerIndex with untrusted data from [in : ByteBuf](1).",
        "line_number": 78,
        "steps": [
            {
                "line": 72,
                "source": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/QosProcessHandler.java",
                "filepath": "dubbo-plugin/dubbo-qos/src/main/java/org/apache/dubbo/qos/server/handler/QosProcessHandler.java",
                "methodName": null,
                "exampleID": 213
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java#L214",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.registry.integration;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.Version;\nimport org.apache.dubbo.common.config.ConfigurationUtils;\nimport org.apache.dubbo.common.extension.ExtensionLoader;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.common.utils.NetUtils;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.registry.AddressListener;\nimport org.apache.dubbo.registry.NotifyListener;\nimport org.apache.dubbo.registry.Registry;\nimport org.apache.dubbo.registry.client.event.listener.ServiceInstancesChangedListener;\nimport org.apache.dubbo.registry.client.migration.InvokersChangedListener;\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.Protocol;\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.cluster.Cluster;\nimport org.apache.dubbo.rpc.cluster.Configurator;\nimport org.apache.dubbo.rpc.cluster.Constants;\nimport org.apache.dubbo.rpc.cluster.RouterChain;\nimport org.apache.dubbo.rpc.cluster.RouterFactory;\nimport org.apache.dubbo.rpc.cluster.SingleRouterChain;\nimport org.apache.dubbo.rpc.cluster.directory.AbstractDirectory;\nimport org.apache.dubbo.rpc.cluster.router.state.BitList;\nimport org.apache.dubbo.rpc.model.ModuleModel;\n\nimport java.util.List;\n\nimport static org.apache.dubbo.common.constants.CommonConstants.ANY_VALUE;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.CLUSTER_FAILED_SITE_SELECTION;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_FAILED_DESTROY_SERVICE;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.REGISTRY_FAILED_DESTROY_UNREGISTER_URL;\nimport static org.apache.dubbo.common.constants.RegistryConstants.CATEGORY_KEY;\nimport static org.apache.dubbo.common.constants.RegistryConstants.CONSUMERS_CATEGORY;\nimport static org.apache.dubbo.registry.Constants.REGISTER_KEY;\nimport static org.apache.dubbo.registry.Constants.SIMPLIFIED_KEY;\nimport static org.apache.dubbo.registry.integration.InterfaceCompatibleRegistryProtocol.DEFAULT_REGISTER_CONSUMER_KEYS;\nimport static org.apache.dubbo.remoting.Constants.CHECK_KEY;\n\n/**\n * DynamicDirectory\n */\npublic abstract class DynamicDirectory<T> extends AbstractDirectory<T> implements NotifyListener {\n\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(DynamicDirectory.class);\n\n    protected final Cluster cluster;\n\n    protected final RouterFactory routerFactory;\n\n    /**\n     * Initialization at construction time, assertion not null\n     */\n    protected final String serviceKey;\n\n    /**\n     * Initialization at construction time, assertion not null\n     */\n    protected final Class<T> serviceType;\n\n    /**\n     * Initialization at construction time, assertion not null, and always assign non-null value\n     */\n    protected volatile URL directoryUrl;\n\n    protected final boolean multiGroup;\n\n    /**\n     * Initialization at the time of injection, the assertion is not null\n     */\n    protected Protocol protocol;\n\n    /**\n     * Initialization at the time of injection, the assertion is not null\n     */\n    protected Registry registry;\n\n    protected volatile boolean forbidden = false;\n    protected boolean shouldRegister;\n    protected boolean shouldSimplified;\n\n    /**\n     * Initialization at construction time, assertion not null, and always assign not null value\n     */\n    protected volatile URL subscribeUrl;\n\n    protected volatile URL registeredConsumerUrl;\n\n    /**\n     * The initial value is null and the midway may be assigned to null, please use the local variable reference\n     * override rules\n     * Priority: override>-D>consumer>provider\n     * Rule one: for a certain provider <ip:port,timeout=100>\n     * Rule two: for all providers <* ,timeout=5000>\n     */\n    protected volatile List<Configurator> configurators;\n\n    protected ServiceInstancesChangedListener serviceListener;\n\n    /**\n     * Should continue route if directory is empty\n     */\n    private final boolean shouldFailFast;\n\n    private volatile InvokersChangedListener invokersChangedListener;\n    private volatile boolean invokersChanged;\n\n    public DynamicDirectory(Class<T> serviceType, URL url) {\n        super(url, true);\n\n        ModuleModel moduleModel = url.getOrDefaultModuleModel();\n\n        this.cluster = moduleModel.getExtensionLoader(Cluster.class).getAdaptiveExtension();\n        this.routerFactory = moduleModel.getExtensionLoader(RouterFactory.class).getAdaptiveExtension();\n\n        if (serviceType == null) {\n            throw new IllegalArgumentException(\"service type is null.\");\n        }\n\n        if (StringUtils.isEmpty(url.getServiceKey())) {\n            throw new IllegalArgumentException(\"registry serviceKey is null.\");\n        }\n\n        this.shouldRegister = !ANY_VALUE.equals(url.getServiceInterface()) && url.getParameter(REGISTER_KEY, true);\n        this.shouldSimplified = url.getParameter(SIMPLIFIED_KEY, false);\n\n        this.serviceType = serviceType;\n        this.serviceKey = super.getConsumerUrl().getServiceKey();\n\n        this.directoryUrl = consumerUrl;\n        String group = directoryUrl.getGroup(\"\");\n        this.multiGroup = group != null && (ANY_VALUE.equals(group) || group.contains(\",\"));\n\n        this.shouldFailFast = Boolean.parseBoolean(\n                ConfigurationUtils.getProperty(moduleModel, Constants.SHOULD_FAIL_FAST_KEY, \"true\"));\n    }\n\n    @Override\n    public void addServiceListener(ServiceInstancesChangedListener instanceListener) {\n        this.serviceListener = instanceListener;\n    }\n\n    @Override\n    public ServiceInstancesChangedListener getServiceListener() {\n        return this.serviceListener;\n    }\n\n    public void setProtocol(Protocol protocol) {\n        this.protocol = protocol;\n    }\n\n    public void setRegistry(Registry registry) {\n        this.registry = registry;\n    }\n\n    public Registry getRegistry() {\n        return registry;\n    }\n\n    public boolean isShouldRegister() {\n        return shouldRegister;\n    }\n\n    public void subscribe(URL url) {\n        setSubscribeUrl(url);\n        registry.subscribe(url, this);\n    }\n\n    public void unSubscribe(URL url) {\n        setSubscribeUrl(null);\n        registry.unsubscribe(url, this);\n    }\n\n    @Override\n    public List<Invoker<T>> doList(\n            SingleRouterChain<T> singleRouterChain, BitList<Invoker<T>> invokers, Invocation invocation) {\n        if (forbidden && shouldFailFast) {\n            // 1. No service provider 2. Service providers are disabled\n            throw new RpcException(\n                    RpcException.FORBIDDEN_EXCEPTION,\n                    \"No provider available from registry \" + this\n                            + \" for service \" + getConsumerUrl().getServiceKey() + \" on consumer \"\n                            + NetUtils.getLocalHost()\n                            + \" use dubbo version \" + Version.getVersion()\n                            + \", please check status of providers(disabled, not registered or in blocklist).\");\n        }\n\n        if (multiGroup) {\n            return this.getInvokers();\n        }\n\n        try {\n            // Get invokers from cache, only runtime routers will be executed.\n            List<Invoker<T>> result = singleRouterChain.route(getConsumerUrl(), invokers, invocation);\n            return result == null ? BitList.emptyList() : result;\n        } catch (Throwable t) {\n            // 2-1 - Failed to execute routing.\n            logger.error(\n                    CLUSTER_FAILED_SITE_SELECTION,\n                    \"\",\n                    \"\",\n                    \"Failed to execute router: \" + getUrl() + \", cause: \" + t.getMessage(),\n                    t);\n\n            return BitList.emptyList();\n        }\n    }\n\n    @Override\n    public Class<T> getInterface() {\n        return serviceType;\n    }\n\n    @Override\n    public List<Invoker<T>> getAllInvokers() {\n        return this.getInvokers();\n    }\n\n    /**\n     * The currently effective consumer url\n     *\n     * @return URL\n     */\n    @Override\n    public URL getConsumerUrl() {\n        return this.directoryUrl;\n    }\n\n    /**\n     * The original consumer url\n     *\n     * @return URL\n     */\n    public URL getOriginalConsumerUrl() {\n        return this.consumerUrl;\n    }\n\n    /**\n     * The url registered to registry or metadata center\n     *\n     * @return URL\n     */\n    public URL getRegisteredConsumerUrl() {\n        return registeredConsumerUrl;\n    }\n\n    /**\n     * The url used to subscribe from registry\n     *\n     * @return URL\n     */\n    public URL getSubscribeUrl() {\n        return subscribeUrl;\n    }\n\n    public void setSubscribeUrl(URL subscribeUrl) {\n        this.subscribeUrl = subscribeUrl;\n    }\n\n    public void setRegisteredConsumerUrl(URL url) {\n        if (!shouldSimplified) {\n            this.registeredConsumerUrl =\n                    url.addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false));\n        } else {\n            this.registeredConsumerUrl = URL.valueOf(url, DEFAULT_REGISTER_CONSUMER_KEYS, null)\n                    .addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false));\n        }\n    }\n\n    public void buildRouterChain(URL url) {\n        this.setRouterChain(RouterChain.buildChain(getInterface(), url));\n    }\n\n    @Override\n    public boolean isAvailable() {\n        if (isDestroyed() || this.forbidden) {\n            return false;\n        }\n        for (Invoker<T> validInvoker : getValidInvokers()) {\n            if (validInvoker.isAvailable()) {\n                return true;\n            } else {\n                addInvalidateInvoker(validInvoker);\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public void destroy() {\n        if (isDestroyed()) {\n            return;\n        }\n\n        // unregister.\n        try {\n            if (getRegisteredConsumerUrl() != null && registry != null && registry.isAvailable()) {\n                registry.unregister(getRegisteredConsumerUrl());\n            }\n        } catch (Throwable t) {\n            // 1-8: Failed to unregister / unsubscribe url on destroy.\n            logger.warn(\n                    REGISTRY_FAILED_DESTROY_UNREGISTER_URL,\n                    \"\",\n                    \"\",\n                    \"unexpected error when unregister service \" + serviceKey + \" from registry: \" + registry.getUrl(),\n                    t);\n        }\n\n        // unsubscribe.\n        try {\n            if (getSubscribeUrl() != null && registry != null && registry.isAvailable()) {\n                registry.unsubscribe(getSubscribeUrl(), this);\n            }\n        } catch (Throwable t) {\n            // 1-8: Failed to unregister / unsubscribe url on destroy.\n            logger.warn(\n                    REGISTRY_FAILED_DESTROY_UNREGISTER_URL,\n                    \"\",\n                    \"\",\n                    \"unexpected error when unsubscribe service \" + serviceKey + \" from registry: \" + registry.getUrl(),\n                    t);\n        }\n\n        ExtensionLoader<AddressListener> addressListenerExtensionLoader =\n                getUrl().getOrDefaultModuleModel().getExtensionLoader(AddressListener.class);\n        List<AddressListener> supportedListeners =\n                addressListenerExtensionLoader.getActivateExtension(getUrl(), (String[]) null);\n        if (CollectionUtils.isNotEmpty(supportedListeners)) {\n            for (AddressListener addressListener : supportedListeners) {\n                addressListener.destroy(getConsumerUrl(), this);\n            }\n        }\n\n        synchronized (this) {\n            try {\n                destroyAllInvokers();\n            } catch (Throwable t) {\n                // 1-15 - Failed to destroy service.\n                logger.warn(REGISTRY_FAILED_DESTROY_SERVICE, \"\", \"\", \"Failed to destroy service \" + serviceKey, t);\n            }\n            routerChain.destroy();\n            invokersChangedListener = null;\n            serviceListener = null;\n\n            super.destroy(); // must be executed after unsubscribing\n        }\n    }\n\n    @Override\n    public void discordAddresses() {\n        try {\n            destroyAllInvokers();\n        } catch (Throwable t) {\n            // 1-15 - Failed to destroy service.\n            logger.warn(REGISTRY_FAILED_DESTROY_SERVICE, \"\", \"\", \"Failed to destroy service \" + serviceKey, t);\n        }\n    }\n\n    public synchronized void setInvokersChangedListener(InvokersChangedListener listener) {\n        this.invokersChangedListener = listener;\n        if (invokersChangedListener != null && invokersChanged) {\n            invokersChangedListener.onChange();\n        }\n    }\n\n    protected synchronized void invokersChanged() {\n        refreshInvoker();\n        invokersChanged = true;\n        if (invokersChangedListener != null) {\n            invokersChangedListener.onChange();\n            invokersChanged = false;\n        }\n    }\n\n    @Override\n    public boolean isNotificationReceived() {\n        return invokersChanged;\n    }\n\n    protected abstract void destroyAllInvokers();\n\n    protected abstract void refreshOverrideAndInvoker(List<URL> urls);\n}\n",
        "methodName": null,
        "exampleID": 214,
        "dataset": "codeql",
        "filepath": "dubbo-registry/dubbo-registry-api/src/main/java/org/apache/dubbo/registry/integration/DynamicDirectory.java",
        "line": 214,
        "sink": "org.apache.dubbo.rpc.cluster.SingleRouterChain<T>.route",
        "source": "-",
        "sourceLine": 214,
        "qualifier": "Call to org.apache.dubbo.rpc.cluster.SingleRouterChain<T>.route with untrusted data from [msg : Object](1).\nCall to org.apache.dubbo.rpc.cluster.SingleRouterChain<T>.route with untrusted data from [msg : Object](2).\nCall to org.apache.dubbo.rpc.cluster.SingleRouterChain<T>.route with untrusted data from [msg : Object](3).",
        "line_number": 214,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 215
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 215
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 215
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 215
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/command/ClearTelnetHandler.java#L40",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.telnet.support.command;\n\nimport org.apache.dubbo.common.extension.Activate;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.remoting.Channel;\nimport org.apache.dubbo.remoting.telnet.TelnetHandler;\nimport org.apache.dubbo.remoting.telnet.support.Help;\n\n/**\n * ClearTelnetHandler\n */\n@Activate\n@Help(parameter = \"[lines]\", summary = \"Clear screen.\", detail = \"Clear screen.\")\npublic class ClearTelnetHandler implements TelnetHandler {\n    private static final int MAX_LINES = 1000;\n\n    @Override\n    public String telnet(Channel channel, String message) {\n        int lines = 100;\n        if (message.length() > 0) {\n            if (!StringUtils.isNumber(message)) {\n                return \"Illegal lines \" + message + \", must be integer.\";\n            }\n            lines = Math.min(MAX_LINES, Integer.parseInt(message));\n        }\n        StringBuilder buf = new StringBuilder();\n        for (int i = 0; i < lines; i++) {\n            buf.append(\"\\r\\n\");\n        }\n        return buf.toString();\n    }\n}\n",
        "methodName": null,
        "exampleID": 216,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/command/ClearTelnetHandler.java",
        "line": 40,
        "sink": "java.lang.Math.min",
        "source": "-",
        "sourceLine": 40,
        "qualifier": "Call to java.lang.Math.min with untrusted data from [msg : Object](1).\nCall to java.lang.Math.min with untrusted data from [msg : Object](2).\nCall to java.lang.Math.min with untrusted data from [msg : Object](3).",
        "line_number": 40,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 217
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 217
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 217
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 217
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/TelnetHandlerAdapter.java#L64",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.telnet.support;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.extension.ExtensionLoader;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.remoting.Channel;\nimport org.apache.dubbo.remoting.Constants;\nimport org.apache.dubbo.remoting.RemotingException;\nimport org.apache.dubbo.remoting.telnet.TelnetHandler;\nimport org.apache.dubbo.remoting.transport.ChannelHandlerAdapter;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport static org.apache.dubbo.common.constants.CommonConstants.COMMA_SPLIT_PATTERN;\nimport static org.apache.dubbo.remoting.Constants.TELNET_KEY;\n\npublic class TelnetHandlerAdapter extends ChannelHandlerAdapter implements TelnetHandler {\n\n    private final ExtensionLoader<TelnetHandler> extensionLoader;\n\n    public TelnetHandlerAdapter(FrameworkModel frameworkModel) {\n        extensionLoader = frameworkModel.getExtensionLoader(TelnetHandler.class);\n    }\n\n    @Override\n    public String telnet(Channel channel, String message) throws RemotingException {\n        String prompt = channel.getUrl().getParameterAndDecoded(Constants.PROMPT_KEY, Constants.DEFAULT_PROMPT);\n        boolean noprompt = message.contains(\"--no-prompt\");\n        message = message.replace(\"--no-prompt\", \"\");\n        StringBuilder buf = new StringBuilder();\n        message = message.trim();\n        String command;\n        if (message.length() > 0) {\n            int i = message.indexOf(' ');\n            if (i > 0) {\n                command = message.substring(0, i).trim();\n                message = message.substring(i + 1).trim();\n            } else {\n                command = message;\n                message = \"\";\n            }\n        } else {\n            command = \"\";\n        }\n        if (command.length() > 0) {\n            if (extensionLoader.hasExtension(command)) {\n                if (commandEnabled(channel.getUrl(), command)) {\n                    try {\n                        String result = extensionLoader.getExtension(command).telnet(channel, message);\n                        if (result == null) {\n                            return null;\n                        }\n                        buf.append(result);\n                    } catch (Throwable t) {\n                        buf.append(t.getMessage());\n                    }\n                } else {\n                    buf.append(\"Command: \");\n                    buf.append(command);\n                    buf.append(\n                            \" disabled for security reasons, please enable support by listing the commands through 'telnet'\");\n                }\n            } else {\n                buf.append(\"Unsupported command: \");\n                buf.append(command);\n            }\n        }\n        if (buf.length() > 0) {\n            buf.append(\"\\r\\n\");\n        }\n        if (StringUtils.isNotEmpty(prompt) && !noprompt) {\n            buf.append(prompt);\n        }\n        return buf.toString();\n    }\n\n    private boolean commandEnabled(URL url, String command) {\n        String supportCommands = url.getParameter(TELNET_KEY);\n        if (StringUtils.isEmpty(supportCommands)) {\n            return false;\n        }\n        String[] commands = COMMA_SPLIT_PATTERN.split(supportCommands);\n        for (String c : commands) {\n            if (command.equals(c)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n",
        "methodName": null,
        "exampleID": 218,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/TelnetHandlerAdapter.java",
        "line": 64,
        "sink": "org.apache.dubbo.common.extension.ExtensionLoader<TelnetHandler>.getExtension",
        "source": "-",
        "sourceLine": 64,
        "qualifier": "Call to org.apache.dubbo.common.extension.ExtensionLoader<TelnetHandler>.getExtension with untrusted data from [msg : Object](1).\nCall to org.apache.dubbo.common.extension.ExtensionLoader<TelnetHandler>.getExtension with untrusted data from [msg : Object](2).\nCall to org.apache.dubbo.common.extension.ExtensionLoader<TelnetHandler>.getExtension with untrusted data from [msg : Object](3).",
        "line_number": 64,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 219
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 219
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 219
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 219
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/command/LogTelnetHandler.java#L53",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.telnet.support.command;\n\nimport org.apache.dubbo.common.extension.Activate;\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.remoting.Channel;\nimport org.apache.dubbo.remoting.telnet.TelnetHandler;\nimport org.apache.dubbo.remoting.telnet.support.Help;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * LogTelnetHandler\n */\n@Activate\n@Help(parameter = \"level\", summary = \"Change log level or show log \", detail = \"Change log level or show log\")\npublic class LogTelnetHandler implements TelnetHandler {\n\n    public static final String SERVICE_KEY = \"telnet.log\";\n\n    @Override\n    public String telnet(Channel channel, String message) {\n        long size = 0;\n        File file = LoggerFactory.getFile();\n        StringBuilder buf = new StringBuilder();\n        if (message == null || message.trim().length() == 0) {\n            buf.append(\"EXAMPLE: log error / log 100\");\n        } else {\n            String[] str = message.split(\" \");\n            if (!StringUtils.isNumber(str[0])) {\n                LoggerFactory.setLevel(Level.valueOf(message.toUpperCase()));\n            } else {\n                int showLogLength = Integer.parseInt(str[0]);\n\n                if (file != null && file.exists()) {\n                    try {\n                        try (FileInputStream fis = new FileInputStream(file)) {\n                            try (FileChannel filechannel = fis.getChannel()) {\n                                size = filechannel.size();\n                                ByteBuffer bb;\n                                if (size <= showLogLength) {\n                                    bb = ByteBuffer.allocate((int) size);\n                                    filechannel.read(bb, 0);\n                                } else {\n                                    int pos = (int) (size - showLogLength);\n                                    bb = ByteBuffer.allocate(showLogLength);\n                                    filechannel.read(bb, pos);\n                                }\n                                bb.flip();\n                                String content = new String(bb.array())\n                                        .replace(\"<\", \"&lt;\")\n                                        .replace(\">\", \"&gt;\")\n                                        .replace(\"\\n\", \"<br/><br/>\");\n                                buf.append(\"\\r\\ncontent:\" + content);\n\n                                buf.append(\"\\r\\nmodified:\"\n                                        + (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")\n                                                .format(new Date(file.lastModified()))));\n                                buf.append(\"\\r\\nsize:\" + size + \"\\r\\n\");\n                            }\n                        }\n                    } catch (Exception e) {\n                        buf.append(e.getMessage());\n                    }\n                } else {\n                    size = 0;\n                    buf.append(\"\\r\\nMESSAGE: log file not exists or log appender is console .\");\n                }\n            }\n        }\n        buf.append(\"\\r\\nCURRENT LOG LEVEL:\" + LoggerFactory.getLevel())\n                .append(\"\\r\\nCURRENT LOG APPENDER:\" + (file == null ? \"console\" : file.getAbsolutePath()));\n        return buf.toString();\n    }\n}\n",
        "methodName": null,
        "exampleID": 220,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/command/LogTelnetHandler.java",
        "line": 53,
        "sink": "org.apache.dubbo.common.logger.Level.valueOf",
        "source": "-",
        "sourceLine": 53,
        "qualifier": "Call to org.apache.dubbo.common.logger.Level.valueOf with untrusted data from [msg : Object](1).\nCall to org.apache.dubbo.common.logger.Level.valueOf with untrusted data from [msg : Object](2).\nCall to org.apache.dubbo.common.logger.Level.valueOf with untrusted data from [msg : Object](3).",
        "line_number": 53,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 221
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 221
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 221
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 221
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/command/LogTelnetHandler.java#L68",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.telnet.support.command;\n\nimport org.apache.dubbo.common.extension.Activate;\nimport org.apache.dubbo.common.logger.Level;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.remoting.Channel;\nimport org.apache.dubbo.remoting.telnet.TelnetHandler;\nimport org.apache.dubbo.remoting.telnet.support.Help;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * LogTelnetHandler\n */\n@Activate\n@Help(parameter = \"level\", summary = \"Change log level or show log \", detail = \"Change log level or show log\")\npublic class LogTelnetHandler implements TelnetHandler {\n\n    public static final String SERVICE_KEY = \"telnet.log\";\n\n    @Override\n    public String telnet(Channel channel, String message) {\n        long size = 0;\n        File file = LoggerFactory.getFile();\n        StringBuilder buf = new StringBuilder();\n        if (message == null || message.trim().length() == 0) {\n            buf.append(\"EXAMPLE: log error / log 100\");\n        } else {\n            String[] str = message.split(\" \");\n            if (!StringUtils.isNumber(str[0])) {\n                LoggerFactory.setLevel(Level.valueOf(message.toUpperCase()));\n            } else {\n                int showLogLength = Integer.parseInt(str[0]);\n\n                if (file != null && file.exists()) {\n                    try {\n                        try (FileInputStream fis = new FileInputStream(file)) {\n                            try (FileChannel filechannel = fis.getChannel()) {\n                                size = filechannel.size();\n                                ByteBuffer bb;\n                                if (size <= showLogLength) {\n                                    bb = ByteBuffer.allocate((int) size);\n                                    filechannel.read(bb, 0);\n                                } else {\n                                    int pos = (int) (size - showLogLength);\n                                    bb = ByteBuffer.allocate(showLogLength);\n                                    filechannel.read(bb, pos);\n                                }\n                                bb.flip();\n                                String content = new String(bb.array())\n                                        .replace(\"<\", \"&lt;\")\n                                        .replace(\">\", \"&gt;\")\n                                        .replace(\"\\n\", \"<br/><br/>\");\n                                buf.append(\"\\r\\ncontent:\" + content);\n\n                                buf.append(\"\\r\\nmodified:\"\n                                        + (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")\n                                                .format(new Date(file.lastModified()))));\n                                buf.append(\"\\r\\nsize:\" + size + \"\\r\\n\");\n                            }\n                        }\n                    } catch (Exception e) {\n                        buf.append(e.getMessage());\n                    }\n                } else {\n                    size = 0;\n                    buf.append(\"\\r\\nMESSAGE: log file not exists or log appender is console .\");\n                }\n            }\n        }\n        buf.append(\"\\r\\nCURRENT LOG LEVEL:\" + LoggerFactory.getLevel())\n                .append(\"\\r\\nCURRENT LOG APPENDER:\" + (file == null ? \"console\" : file.getAbsolutePath()));\n        return buf.toString();\n    }\n}\n",
        "methodName": null,
        "exampleID": 222,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/command/LogTelnetHandler.java",
        "line": 68,
        "sink": "java.nio.ByteBuffer.allocate",
        "source": "-",
        "sourceLine": 68,
        "qualifier": "Call to java.nio.ByteBuffer.allocate with untrusted data from [msg : Object](1).\nCall to java.nio.ByteBuffer.allocate with untrusted data from [msg : Object](2).\nCall to java.nio.ByteBuffer.allocate with untrusted data from [msg : Object](3).",
        "line_number": 68,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 223
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 223
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 223
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 223
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/command/HelpTelnetHandler.java#L53",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.telnet.support.command;\n\nimport org.apache.dubbo.common.extension.Activate;\nimport org.apache.dubbo.common.extension.ExtensionLoader;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.remoting.Channel;\nimport org.apache.dubbo.remoting.telnet.TelnetHandler;\nimport org.apache.dubbo.remoting.telnet.support.Help;\nimport org.apache.dubbo.remoting.telnet.support.TelnetUtils;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.WeakHashMap;\n\n/**\n * HelpTelnetHandler\n */\n@Activate\n@Help(parameter = \"[command]\", summary = \"Show help.\", detail = \"Show help.\")\npublic class HelpTelnetHandler implements TelnetHandler {\n\n    private final ExtensionLoader<TelnetHandler> extensionLoader;\n\n    private static final String MAIN_HELP = \"mainHelp\";\n\n    private static Map<String, String> processedTable = new WeakHashMap<>();\n\n    public HelpTelnetHandler(FrameworkModel frameworkModel) {\n        extensionLoader = frameworkModel.getExtensionLoader(TelnetHandler.class);\n    }\n\n    @Override\n    public String telnet(Channel channel, String message) {\n        if (message.length() > 0) {\n            return processedTable.computeIfAbsent(message, commandName -> generateForOneCommand(commandName));\n        } else {\n            return processedTable.computeIfAbsent(MAIN_HELP, commandName -> generateForAllCommand(channel));\n        }\n    }\n\n    private String generateForOneCommand(String message) {\n        if (!extensionLoader.hasExtension(message)) {\n            return \"No such command \" + message;\n        }\n        TelnetHandler handler = extensionLoader.getExtension(message);\n        Help help = handler.getClass().getAnnotation(Help.class);\n        StringBuilder buf = new StringBuilder();\n        buf.append(\"Command:\\r\\n    \");\n        buf.append(message + \" \" + help.parameter().replace(\"\\r\\n\", \" \").replace(\"\\n\", \" \"));\n        buf.append(\"\\r\\nSummary:\\r\\n    \");\n        buf.append(help.summary().replace(\"\\r\\n\", \" \").replace(\"\\n\", \" \"));\n        buf.append(\"\\r\\nDetail:\\r\\n    \");\n        buf.append(help.detail().replace(\"\\r\\n\", \"    \\r\\n\").replace(\"\\n\", \"    \\n\"));\n        return buf.toString();\n    }\n\n    private String generateForAllCommand(Channel channel) {\n        List<List<String>> table = new ArrayList<>();\n        List<TelnetHandler> handlers = extensionLoader.getActivateExtension(channel.getUrl(), \"telnet\");\n        if (CollectionUtils.isNotEmpty(handlers)) {\n            for (TelnetHandler handler : handlers) {\n                Help help = handler.getClass().getAnnotation(Help.class);\n                List<String> row = new ArrayList<>();\n                String parameter = \" \" + extensionLoader.getExtensionName(handler) + \" \"\n                        + (help != null ? help.parameter().replace(\"\\r\\n\", \" \").replace(\"\\n\", \" \") : \"\");\n                row.add(parameter.length() > 55 ? parameter.substring(0, 55) + \"...\" : parameter);\n                String summary =\n                        help != null ? help.summary().replace(\"\\r\\n\", \" \").replace(\"\\n\", \" \") : \"\";\n                row.add(summary.length() > 55 ? summary.substring(0, 55) + \"...\" : summary);\n                table.add(row);\n            }\n        }\n        return \"Please input \\\"help [command]\\\" show detail.\\r\\n\" + TelnetUtils.toList(table);\n    }\n}\n",
        "methodName": null,
        "exampleID": 224,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-api/src/main/java/org/apache/dubbo/remoting/telnet/support/command/HelpTelnetHandler.java",
        "line": 53,
        "sink": "java.util.Map<String,String>.computeIfAbsent",
        "source": "-",
        "sourceLine": 53,
        "qualifier": "Call to java.util.Map<String,String>.computeIfAbsent with untrusted data from [msg : Object](1).\nCall to java.util.Map<String,String>.computeIfAbsent with untrusted data from [msg : Object](2).\nCall to java.util.Map<String,String>.computeIfAbsent with untrusted data from [msg : Object](3).",
        "line_number": 53,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 225
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 225
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 225
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 225
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/restclient/HttpClientRestClient.java#L104",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.http.restclient;\n\nimport org.apache.dubbo.remoting.http.RequestTemplate;\nimport org.apache.dubbo.remoting.http.RestClient;\nimport org.apache.dubbo.remoting.http.RestResult;\nimport org.apache.dubbo.remoting.http.config.HttpClientConfig;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.http.Header;\nimport org.apache.http.HttpEntityEnclosingRequest;\nimport org.apache.http.client.config.RequestConfig;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.apache.http.client.methods.HttpDelete;\nimport org.apache.http.client.methods.HttpEntityEnclosingRequestBase;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.client.methods.HttpHead;\nimport org.apache.http.client.methods.HttpOptions;\nimport org.apache.http.client.methods.HttpPatch;\nimport org.apache.http.client.methods.HttpPost;\nimport org.apache.http.client.methods.HttpPut;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.client.methods.HttpTrace;\nimport org.apache.http.entity.ByteArrayEntity;\nimport org.apache.http.impl.client.CloseableHttpClient;\nimport org.apache.http.impl.client.HttpClients;\nimport org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n\npublic class HttpClientRestClient implements RestClient {\n    private final CloseableHttpClient closeableHttpClient;\n    private final HttpClientConfig httpClientConfig;\n\n    public HttpClientRestClient(HttpClientConfig clientConfig) {\n        closeableHttpClient = createHttpClient();\n        httpClientConfig = clientConfig;\n    }\n\n    @Override\n    public CompletableFuture<RestResult> send(RequestTemplate requestTemplate) {\n\n        HttpRequestBase httpRequest = null;\n        String httpMethod = requestTemplate.getHttpMethod();\n\n        httpRequest = createHttpUriRequest(httpMethod, requestTemplate);\n\n        if (httpRequest instanceof HttpEntityEnclosingRequest) {\n            ((HttpEntityEnclosingRequestBase) httpRequest)\n                    .setEntity(new ByteArrayEntity(requestTemplate.getSerializedBody()));\n        }\n\n        Map<String, Collection<String>> allHeaders = requestTemplate.getAllHeaders();\n\n        allHeaders.remove(\"Content-Length\");\n        // header\n        for (String headerName : allHeaders.keySet()) {\n            Collection<String> headerValues = allHeaders.get(headerName);\n\n            for (String headerValue : headerValues) {\n                httpRequest.addHeader(headerName, headerValue);\n            }\n        }\n\n        httpRequest.setConfig(getRequestConfig(httpClientConfig));\n\n        CompletableFuture<RestResult> future = new CompletableFuture<>();\n        try {\n            CloseableHttpResponse response = closeableHttpClient.execute(httpRequest);\n            future.complete(new RestResult() {\n                @Override\n                public String getContentType() {\n                    Header header = response.getFirstHeader(\"Content-Type\");\n                    return header == null ? null : header.getValue();\n                }\n\n                @Override\n                public byte[] getBody() throws IOException {\n                    if (response.getEntity() == null) {\n                        return new byte[0];\n                    }\n                    return IOUtils.toByteArray(response.getEntity().getContent());\n                }\n\n                @Override\n                public Map<String, List<String>> headers() {\n                    return Arrays.stream(response.getAllHeaders())\n                            .collect(Collectors.toMap(Header::getName, h -> Collections.singletonList(h.getValue())));\n                }\n\n                @Override\n                public byte[] getErrorResponse() throws IOException {\n                    return getBody();\n                }\n\n                @Override\n                public int getResponseCode() {\n                    return response.getStatusLine().getStatusCode();\n                }\n\n                @Override\n                public String getMessage() throws IOException {\n                    return appendErrorMessage(\n                            response.getStatusLine().getReasonPhrase(), new String(getErrorResponse()));\n                }\n            });\n        } catch (IOException e) {\n            future.completeExceptionally(e);\n        }\n        return future;\n    }\n\n    private RequestConfig getRequestConfig(HttpClientConfig clientConfig) {\n\n        // TODO config\n        return RequestConfig.custom().build();\n    }\n\n    @Override\n    public void close() {\n        try {\n            closeableHttpClient.close();\n        } catch (IOException e) {\n\n        }\n    }\n\n    @Override\n    public void close(int timeout) {}\n\n    @Override\n    public boolean isClosed() {\n        // TODO close judge\n        return true;\n    }\n\n    public CloseableHttpClient createHttpClient() {\n        PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();\n        return HttpClients.custom().setConnectionManager(connectionManager).build();\n    }\n\n    protected HttpRequestBase createHttpUriRequest(String httpMethod, RequestTemplate requestTemplate) {\n        String uri = requestTemplate.getURL();\n        HttpRequestBase httpUriRequest = null;\n        if (HttpGet.METHOD_NAME.equals(httpMethod)) {\n            httpUriRequest = new HttpGet(uri);\n        } else if (HttpHead.METHOD_NAME.equals(httpMethod)) {\n            httpUriRequest = new HttpHead(uri);\n        } else if (HttpPost.METHOD_NAME.equals(httpMethod)) {\n            httpUriRequest = new HttpPost(uri);\n        } else if (HttpPut.METHOD_NAME.equals(httpMethod)) {\n            httpUriRequest = new HttpPut(uri);\n        } else if (HttpPatch.METHOD_NAME.equals(httpMethod)) {\n            httpUriRequest = new HttpPatch(uri);\n        } else if (HttpDelete.METHOD_NAME.equals(httpMethod)) {\n            httpUriRequest = new HttpDelete(uri);\n        } else if (HttpOptions.METHOD_NAME.equals(httpMethod)) {\n            httpUriRequest = new HttpOptions(uri);\n        } else if (HttpTrace.METHOD_NAME.equals(httpMethod)) {\n            httpUriRequest = new HttpTrace(uri);\n        } else {\n            throw new IllegalArgumentException(\"Invalid HTTP method: \" + httpMethod);\n        }\n        return httpUriRequest;\n    }\n}\n",
        "methodName": null,
        "exampleID": 226,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/restclient/HttpClientRestClient.java",
        "line": 104,
        "sink": "org.apache.commons.io.IOUtils.toByteArray",
        "source": "-",
        "sourceLine": 104,
        "qualifier": "Call to org.apache.commons.io.IOUtils.toByteArray with untrusted data from [getContent(...)](1).",
        "line_number": 104,
        "steps": []
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/restclient/URLConnectionRestClient.java#L124",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.http.restclient;\n\nimport org.apache.dubbo.remoting.http.RequestTemplate;\nimport org.apache.dubbo.remoting.http.RestClient;\nimport org.apache.dubbo.remoting.http.RestResult;\nimport org.apache.dubbo.remoting.http.config.HttpClientConfig;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.zip.DeflaterOutputStream;\nimport java.util.zip.GZIPOutputStream;\n\nimport org.apache.commons.io.IOUtils;\n\npublic class URLConnectionRestClient implements RestClient {\n    private final HttpClientConfig clientConfig;\n\n    public URLConnectionRestClient(HttpClientConfig clientConfig) {\n        this.clientConfig = clientConfig;\n    }\n\n    @Override\n    public CompletableFuture<RestResult> send(RequestTemplate requestTemplate) {\n\n        CompletableFuture<RestResult> future = new CompletableFuture<>();\n\n        try {\n            HttpURLConnection connection = (HttpURLConnection) new URL(requestTemplate.getURL()).openConnection();\n            connection.setConnectTimeout(clientConfig.getConnectTimeout());\n            connection.setReadTimeout(clientConfig.getReadTimeout());\n            connection.setRequestMethod(requestTemplate.getHttpMethod());\n\n            prepareConnection(connection, requestTemplate.getHttpMethod());\n\n            // writeHeaders\n\n            for (String field : requestTemplate.getAllHeaders().keySet()) {\n                for (String value : requestTemplate.getHeaders(field)) {\n                    connection.addRequestProperty(field, value);\n                }\n            }\n\n            // writeBody\n\n            boolean gzipEncodedRequest = requestTemplate.isGzipEncodedRequest();\n            boolean deflateEncodedRequest = requestTemplate.isDeflateEncodedRequest();\n            if (requestTemplate.isBodyEmpty()) {\n                future.complete(getRestResultFromConnection(connection));\n                return future;\n            }\n            Integer contentLength = requestTemplate.getContentLength();\n\n            if (contentLength != null) {\n                connection.setFixedLengthStreamingMode(contentLength);\n            } else {\n                connection.setChunkedStreamingMode(clientConfig.getChunkLength());\n            }\n\n            OutputStream out = connection.getOutputStream();\n            if (gzipEncodedRequest) {\n                out = new GZIPOutputStream(out);\n            } else if (deflateEncodedRequest) {\n                out = new DeflaterOutputStream(out);\n            }\n            try {\n                out.write(requestTemplate.getSerializedBody());\n            } finally {\n                try {\n                    out.close();\n                } catch (IOException suppressed) {\n                }\n            }\n\n            future.complete(getRestResultFromConnection(connection));\n        } catch (Exception e) {\n            future.completeExceptionally(e);\n        }\n\n        return future;\n    }\n\n    @Override\n    public void close() {}\n\n    @Override\n    public void close(int timeout) {}\n\n    @Override\n    public boolean isClosed() {\n        return true;\n    }\n\n    private RestResult getRestResultFromConnection(HttpURLConnection connection) {\n\n        return new RestResult() {\n            @Override\n            public String getContentType() {\n                return connection.getContentType();\n            }\n\n            @Override\n            public byte[] getBody() throws IOException {\n                return IOUtils.toByteArray(connection.getInputStream());\n            }\n\n            @Override\n            public Map<String, List<String>> headers() {\n                return connection.getHeaderFields();\n            }\n\n            @Override\n            public byte[] getErrorResponse() throws IOException {\n                return IOUtils.toByteArray(connection.getErrorStream());\n            }\n\n            @Override\n            public int getResponseCode() throws IOException {\n                return connection.getResponseCode();\n            }\n\n            @Override\n            public String getMessage() throws IOException {\n                return appendErrorMessage(connection.getResponseMessage(), new String(getErrorResponse()));\n            }\n        };\n    }\n\n    private void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException {\n\n        connection.setDoInput(true);\n\n        if (\"GET\".equals(httpMethod)) {\n            connection.setInstanceFollowRedirects(true);\n        } else {\n            connection.setInstanceFollowRedirects(false);\n        }\n\n        if (\"POST\".equals(httpMethod)\n                || \"PUT\".equals(httpMethod)\n                || \"PATCH\".equals(httpMethod)\n                || \"DELETE\".equals(httpMethod)) {\n            connection.setDoOutput(true);\n        } else {\n            connection.setDoOutput(false);\n        }\n\n        connection.setRequestMethod(httpMethod);\n    }\n}\n",
        "methodName": null,
        "exampleID": 228,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-http/src/main/java/org/apache/dubbo/remoting/http/restclient/URLConnectionRestClient.java",
        "line": 124,
        "sink": "org.apache.commons.io.IOUtils.toByteArray",
        "source": "-",
        "sourceLine": 124,
        "qualifier": "Call to org.apache.commons.io.IOUtils.toByteArray with untrusted data from [getInputStream(...)](1).",
        "line_number": 124,
        "steps": []
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java#L59",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.transport.netty4;\n\nimport org.apache.dubbo.common.utils.Assert;\nimport org.apache.dubbo.remoting.buffer.ChannelBuffer;\nimport org.apache.dubbo.remoting.buffer.ChannelBufferFactory;\nimport org.apache.dubbo.remoting.buffer.ChannelBuffers;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.util.ReferenceCountUtil;\n\npublic class NettyBackedChannelBuffer implements ChannelBuffer {\n\n    private final ByteBuf buffer;\n\n    public NettyBackedChannelBuffer(ByteBuf buffer) {\n        Assert.notNull(buffer, \"buffer == null\");\n        this.buffer = buffer;\n    }\n\n    @Override\n    public int capacity() {\n        return buffer.capacity();\n    }\n\n    @Override\n    public ChannelBuffer copy(int index, int length) {\n        return new NettyBackedChannelBuffer(buffer.copy(index, length));\n    }\n\n    // has nothing use\n    @Override\n    public ChannelBufferFactory factory() {\n        return null;\n    }\n\n    @Override\n    public byte getByte(int index) {\n        return buffer.getByte(index);\n    }\n\n    @Override\n    public void getBytes(int index, byte[] dst, int dstIndex, int length) {\n        buffer.getBytes(index, dst, dstIndex, length);\n    }\n\n    @Override\n    public void getBytes(int index, ByteBuffer dst) {\n        buffer.getBytes(index, dst);\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst, int dstIndex, int length) {\n        // careful\n        byte[] data = new byte[length];\n        buffer.getBytes(index, data, 0, length);\n        dst.setBytes(dstIndex, data, 0, length);\n    }\n\n    @Override\n    public void getBytes(int index, OutputStream dst, int length) throws IOException {\n        buffer.getBytes(index, dst, length);\n    }\n\n    @Override\n    public boolean isDirect() {\n        return buffer.isDirect();\n    }\n\n    @Override\n    public void setByte(int index, int value) {\n        buffer.setByte(index, value);\n    }\n\n    @Override\n    public void setBytes(int index, byte[] src, int srcIndex, int length) {\n        buffer.setBytes(index, src, srcIndex, length);\n    }\n\n    @Override\n    public void setBytes(int index, ByteBuffer src) {\n        buffer.setBytes(index, src);\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src, int srcIndex, int length) {\n        if (length > src.readableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        // careful\n        byte[] data = new byte[length];\n        src.getBytes(srcIndex, data, 0, length);\n        setBytes(index, data, 0, length);\n    }\n\n    @Override\n    public int setBytes(int index, InputStream src, int length) throws IOException {\n        return buffer.setBytes(index, src, length);\n    }\n\n    @Override\n    public ByteBuffer toByteBuffer(int index, int length) {\n        return buffer.nioBuffer(index, length);\n    }\n\n    @Override\n    public byte[] array() {\n        return buffer.array();\n    }\n\n    @Override\n    public boolean hasArray() {\n        return buffer.hasArray();\n    }\n\n    @Override\n    public int arrayOffset() {\n        return buffer.arrayOffset();\n    }\n\n    // AbstractChannelBuffer\n\n    @Override\n    public void clear() {\n        buffer.clear();\n    }\n\n    @Override\n    public ChannelBuffer copy() {\n        return new NettyBackedChannelBuffer(buffer.copy());\n    }\n\n    @Override\n    public void discardReadBytes() {\n        buffer.discardReadBytes();\n    }\n\n    @Override\n    public void ensureWritableBytes(int writableBytes) {\n        buffer.ensureWritable(writableBytes);\n    }\n\n    @Override\n    public void getBytes(int index, byte[] dst) {\n        buffer.getBytes(index, dst);\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst) {\n        // careful\n        getBytes(index, dst, dst.writableBytes());\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst, int length) {\n        // careful\n        if (length > dst.writableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        getBytes(index, dst, dst.writerIndex(), length);\n        dst.writerIndex(dst.writerIndex() + length);\n    }\n\n    @Override\n    public void markReaderIndex() {\n        buffer.markReaderIndex();\n    }\n\n    @Override\n    public void markWriterIndex() {\n        buffer.markWriterIndex();\n    }\n\n    @Override\n    public boolean readable() {\n        return buffer.isReadable();\n    }\n\n    @Override\n    public int readableBytes() {\n        return buffer.readableBytes();\n    }\n\n    @Override\n    public byte readByte() {\n        return buffer.readByte();\n    }\n\n    @Override\n    public void readBytes(byte[] dst) {\n        buffer.readBytes(dst);\n    }\n\n    @Override\n    public void readBytes(byte[] dst, int dstIndex, int length) {\n        buffer.readBytes(dst, dstIndex, length);\n    }\n\n    @Override\n    public void readBytes(ByteBuffer dst) {\n        buffer.readBytes(dst);\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst) {\n        // careful\n        readBytes(dst, dst.writableBytes());\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst, int length) {\n        // careful\n        if (length > dst.writableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        readBytes(dst, dst.writerIndex(), length);\n        dst.writerIndex(dst.writerIndex() + length);\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst, int dstIndex, int length) {\n        // careful\n        if (readableBytes() < length) {\n            throw new IndexOutOfBoundsException();\n        }\n        byte[] data = new byte[length];\n        buffer.readBytes(data, 0, length);\n        dst.setBytes(dstIndex, data, 0, length);\n    }\n\n    @Override\n    public ChannelBuffer readBytes(int length) {\n        return new NettyBackedChannelBuffer(buffer.readBytes(length));\n    }\n\n    @Override\n    public void resetReaderIndex() {\n        buffer.resetReaderIndex();\n    }\n\n    @Override\n    public void resetWriterIndex() {\n        buffer.resetWriterIndex();\n    }\n\n    @Override\n    public int readerIndex() {\n        return buffer.readerIndex();\n    }\n\n    @Override\n    public void readerIndex(int readerIndex) {\n        buffer.readerIndex(readerIndex);\n    }\n\n    @Override\n    public void readBytes(OutputStream dst, int length) throws IOException {\n        buffer.readBytes(dst, length);\n    }\n\n    @Override\n    public void setBytes(int index, byte[] src) {\n        buffer.setBytes(index, src);\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src) {\n        // careful\n        setBytes(index, src, src.readableBytes());\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src, int length) {\n        // careful\n        if (length > src.readableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        setBytes(index, src, src.readerIndex(), length);\n        src.readerIndex(src.readerIndex() + length);\n    }\n\n    @Override\n    public void setIndex(int readerIndex, int writerIndex) {\n        buffer.setIndex(readerIndex, writerIndex);\n    }\n\n    @Override\n    public void skipBytes(int length) {\n        buffer.skipBytes(length);\n    }\n\n    @Override\n    public ByteBuffer toByteBuffer() {\n        return buffer.nioBuffer();\n    }\n\n    @Override\n    public boolean writable() {\n        return buffer.isWritable();\n    }\n\n    @Override\n    public int writableBytes() {\n        return buffer.writableBytes();\n    }\n\n    @Override\n    public void writeByte(int value) {\n        buffer.writeByte(value);\n    }\n\n    @Override\n    public void writeBytes(byte[] src) {\n        buffer.writeBytes(src);\n    }\n\n    @Override\n    public void writeBytes(byte[] src, int index, int length) {\n        buffer.writeBytes(src, index, length);\n    }\n\n    @Override\n    public void writeBytes(ByteBuffer src) {\n        buffer.writeBytes(src);\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src) {\n        // careful\n        writeBytes(src, src.readableBytes());\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src, int length) {\n        // careful\n        if (length > src.readableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        writeBytes(src, src.readerIndex(), length);\n        src.readerIndex(src.readerIndex() + length);\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src, int srcIndex, int length) {\n        // careful\n        byte[] data = new byte[length];\n        src.getBytes(srcIndex, data, 0, length);\n        writeBytes(data, 0, length);\n    }\n\n    @Override\n    public int writeBytes(InputStream src, int length) throws IOException {\n        return buffer.writeBytes(src, length);\n    }\n\n    @Override\n    public int writerIndex() {\n        return buffer.writerIndex();\n    }\n\n    @Override\n    public void writerIndex(int writerIndex) {\n        buffer.ensureWritable(writerIndex);\n        buffer.writerIndex(writerIndex);\n    }\n\n    @Override\n    public int compareTo(ChannelBuffer o) {\n        return ChannelBuffers.compare(this, o);\n    }\n\n    public void release() {\n        ReferenceCountUtil.safeRelease(buffer);\n    }\n}\n",
        "methodName": null,
        "exampleID": 230,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java",
        "line": 59,
        "sink": "io.netty.buffer.ByteBuf.getByte",
        "source": "-",
        "sourceLine": 59,
        "qualifier": "Call to io.netty.buffer.ByteBuf.getByte with untrusted data from [in : ByteBuf](1).",
        "line_number": 59,
        "steps": [
            {
                "line": 106,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "methodName": null,
                "exampleID": 231
            },
            {
                "line": 106,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "methodName": null,
                "exampleID": 231
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java#L201",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.transport.netty4;\n\nimport org.apache.dubbo.common.utils.Assert;\nimport org.apache.dubbo.remoting.buffer.ChannelBuffer;\nimport org.apache.dubbo.remoting.buffer.ChannelBufferFactory;\nimport org.apache.dubbo.remoting.buffer.ChannelBuffers;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.util.ReferenceCountUtil;\n\npublic class NettyBackedChannelBuffer implements ChannelBuffer {\n\n    private final ByteBuf buffer;\n\n    public NettyBackedChannelBuffer(ByteBuf buffer) {\n        Assert.notNull(buffer, \"buffer == null\");\n        this.buffer = buffer;\n    }\n\n    @Override\n    public int capacity() {\n        return buffer.capacity();\n    }\n\n    @Override\n    public ChannelBuffer copy(int index, int length) {\n        return new NettyBackedChannelBuffer(buffer.copy(index, length));\n    }\n\n    // has nothing use\n    @Override\n    public ChannelBufferFactory factory() {\n        return null;\n    }\n\n    @Override\n    public byte getByte(int index) {\n        return buffer.getByte(index);\n    }\n\n    @Override\n    public void getBytes(int index, byte[] dst, int dstIndex, int length) {\n        buffer.getBytes(index, dst, dstIndex, length);\n    }\n\n    @Override\n    public void getBytes(int index, ByteBuffer dst) {\n        buffer.getBytes(index, dst);\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst, int dstIndex, int length) {\n        // careful\n        byte[] data = new byte[length];\n        buffer.getBytes(index, data, 0, length);\n        dst.setBytes(dstIndex, data, 0, length);\n    }\n\n    @Override\n    public void getBytes(int index, OutputStream dst, int length) throws IOException {\n        buffer.getBytes(index, dst, length);\n    }\n\n    @Override\n    public boolean isDirect() {\n        return buffer.isDirect();\n    }\n\n    @Override\n    public void setByte(int index, int value) {\n        buffer.setByte(index, value);\n    }\n\n    @Override\n    public void setBytes(int index, byte[] src, int srcIndex, int length) {\n        buffer.setBytes(index, src, srcIndex, length);\n    }\n\n    @Override\n    public void setBytes(int index, ByteBuffer src) {\n        buffer.setBytes(index, src);\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src, int srcIndex, int length) {\n        if (length > src.readableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        // careful\n        byte[] data = new byte[length];\n        src.getBytes(srcIndex, data, 0, length);\n        setBytes(index, data, 0, length);\n    }\n\n    @Override\n    public int setBytes(int index, InputStream src, int length) throws IOException {\n        return buffer.setBytes(index, src, length);\n    }\n\n    @Override\n    public ByteBuffer toByteBuffer(int index, int length) {\n        return buffer.nioBuffer(index, length);\n    }\n\n    @Override\n    public byte[] array() {\n        return buffer.array();\n    }\n\n    @Override\n    public boolean hasArray() {\n        return buffer.hasArray();\n    }\n\n    @Override\n    public int arrayOffset() {\n        return buffer.arrayOffset();\n    }\n\n    // AbstractChannelBuffer\n\n    @Override\n    public void clear() {\n        buffer.clear();\n    }\n\n    @Override\n    public ChannelBuffer copy() {\n        return new NettyBackedChannelBuffer(buffer.copy());\n    }\n\n    @Override\n    public void discardReadBytes() {\n        buffer.discardReadBytes();\n    }\n\n    @Override\n    public void ensureWritableBytes(int writableBytes) {\n        buffer.ensureWritable(writableBytes);\n    }\n\n    @Override\n    public void getBytes(int index, byte[] dst) {\n        buffer.getBytes(index, dst);\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst) {\n        // careful\n        getBytes(index, dst, dst.writableBytes());\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst, int length) {\n        // careful\n        if (length > dst.writableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        getBytes(index, dst, dst.writerIndex(), length);\n        dst.writerIndex(dst.writerIndex() + length);\n    }\n\n    @Override\n    public void markReaderIndex() {\n        buffer.markReaderIndex();\n    }\n\n    @Override\n    public void markWriterIndex() {\n        buffer.markWriterIndex();\n    }\n\n    @Override\n    public boolean readable() {\n        return buffer.isReadable();\n    }\n\n    @Override\n    public int readableBytes() {\n        return buffer.readableBytes();\n    }\n\n    @Override\n    public byte readByte() {\n        return buffer.readByte();\n    }\n\n    @Override\n    public void readBytes(byte[] dst) {\n        buffer.readBytes(dst);\n    }\n\n    @Override\n    public void readBytes(byte[] dst, int dstIndex, int length) {\n        buffer.readBytes(dst, dstIndex, length);\n    }\n\n    @Override\n    public void readBytes(ByteBuffer dst) {\n        buffer.readBytes(dst);\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst) {\n        // careful\n        readBytes(dst, dst.writableBytes());\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst, int length) {\n        // careful\n        if (length > dst.writableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        readBytes(dst, dst.writerIndex(), length);\n        dst.writerIndex(dst.writerIndex() + length);\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst, int dstIndex, int length) {\n        // careful\n        if (readableBytes() < length) {\n            throw new IndexOutOfBoundsException();\n        }\n        byte[] data = new byte[length];\n        buffer.readBytes(data, 0, length);\n        dst.setBytes(dstIndex, data, 0, length);\n    }\n\n    @Override\n    public ChannelBuffer readBytes(int length) {\n        return new NettyBackedChannelBuffer(buffer.readBytes(length));\n    }\n\n    @Override\n    public void resetReaderIndex() {\n        buffer.resetReaderIndex();\n    }\n\n    @Override\n    public void resetWriterIndex() {\n        buffer.resetWriterIndex();\n    }\n\n    @Override\n    public int readerIndex() {\n        return buffer.readerIndex();\n    }\n\n    @Override\n    public void readerIndex(int readerIndex) {\n        buffer.readerIndex(readerIndex);\n    }\n\n    @Override\n    public void readBytes(OutputStream dst, int length) throws IOException {\n        buffer.readBytes(dst, length);\n    }\n\n    @Override\n    public void setBytes(int index, byte[] src) {\n        buffer.setBytes(index, src);\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src) {\n        // careful\n        setBytes(index, src, src.readableBytes());\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src, int length) {\n        // careful\n        if (length > src.readableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        setBytes(index, src, src.readerIndex(), length);\n        src.readerIndex(src.readerIndex() + length);\n    }\n\n    @Override\n    public void setIndex(int readerIndex, int writerIndex) {\n        buffer.setIndex(readerIndex, writerIndex);\n    }\n\n    @Override\n    public void skipBytes(int length) {\n        buffer.skipBytes(length);\n    }\n\n    @Override\n    public ByteBuffer toByteBuffer() {\n        return buffer.nioBuffer();\n    }\n\n    @Override\n    public boolean writable() {\n        return buffer.isWritable();\n    }\n\n    @Override\n    public int writableBytes() {\n        return buffer.writableBytes();\n    }\n\n    @Override\n    public void writeByte(int value) {\n        buffer.writeByte(value);\n    }\n\n    @Override\n    public void writeBytes(byte[] src) {\n        buffer.writeBytes(src);\n    }\n\n    @Override\n    public void writeBytes(byte[] src, int index, int length) {\n        buffer.writeBytes(src, index, length);\n    }\n\n    @Override\n    public void writeBytes(ByteBuffer src) {\n        buffer.writeBytes(src);\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src) {\n        // careful\n        writeBytes(src, src.readableBytes());\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src, int length) {\n        // careful\n        if (length > src.readableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        writeBytes(src, src.readerIndex(), length);\n        src.readerIndex(src.readerIndex() + length);\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src, int srcIndex, int length) {\n        // careful\n        byte[] data = new byte[length];\n        src.getBytes(srcIndex, data, 0, length);\n        writeBytes(data, 0, length);\n    }\n\n    @Override\n    public int writeBytes(InputStream src, int length) throws IOException {\n        return buffer.writeBytes(src, length);\n    }\n\n    @Override\n    public int writerIndex() {\n        return buffer.writerIndex();\n    }\n\n    @Override\n    public void writerIndex(int writerIndex) {\n        buffer.ensureWritable(writerIndex);\n        buffer.writerIndex(writerIndex);\n    }\n\n    @Override\n    public int compareTo(ChannelBuffer o) {\n        return ChannelBuffers.compare(this, o);\n    }\n\n    public void release() {\n        ReferenceCountUtil.safeRelease(buffer);\n    }\n}\n",
        "methodName": null,
        "exampleID": 232,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java",
        "line": 201,
        "sink": "io.netty.buffer.ByteBuf.readableBytes",
        "source": "-",
        "sourceLine": 201,
        "qualifier": "Call to io.netty.buffer.ByteBuf.readableBytes with untrusted data from [input : ByteBuf](1).\nCall to io.netty.buffer.ByteBuf.readableBytes with untrusted data from [in : ByteBuf](2).",
        "line_number": 201,
        "steps": [
            {
                "line": 94,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "methodName": null,
                "exampleID": 233
            },
            {
                "line": 94,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "methodName": null,
                "exampleID": 233
            },
            {
                "line": 106,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "methodName": null,
                "exampleID": 233
            },
            {
                "line": 106,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "methodName": null,
                "exampleID": 233
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java#L216",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.transport.netty4;\n\nimport org.apache.dubbo.common.utils.Assert;\nimport org.apache.dubbo.remoting.buffer.ChannelBuffer;\nimport org.apache.dubbo.remoting.buffer.ChannelBufferFactory;\nimport org.apache.dubbo.remoting.buffer.ChannelBuffers;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.util.ReferenceCountUtil;\n\npublic class NettyBackedChannelBuffer implements ChannelBuffer {\n\n    private final ByteBuf buffer;\n\n    public NettyBackedChannelBuffer(ByteBuf buffer) {\n        Assert.notNull(buffer, \"buffer == null\");\n        this.buffer = buffer;\n    }\n\n    @Override\n    public int capacity() {\n        return buffer.capacity();\n    }\n\n    @Override\n    public ChannelBuffer copy(int index, int length) {\n        return new NettyBackedChannelBuffer(buffer.copy(index, length));\n    }\n\n    // has nothing use\n    @Override\n    public ChannelBufferFactory factory() {\n        return null;\n    }\n\n    @Override\n    public byte getByte(int index) {\n        return buffer.getByte(index);\n    }\n\n    @Override\n    public void getBytes(int index, byte[] dst, int dstIndex, int length) {\n        buffer.getBytes(index, dst, dstIndex, length);\n    }\n\n    @Override\n    public void getBytes(int index, ByteBuffer dst) {\n        buffer.getBytes(index, dst);\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst, int dstIndex, int length) {\n        // careful\n        byte[] data = new byte[length];\n        buffer.getBytes(index, data, 0, length);\n        dst.setBytes(dstIndex, data, 0, length);\n    }\n\n    @Override\n    public void getBytes(int index, OutputStream dst, int length) throws IOException {\n        buffer.getBytes(index, dst, length);\n    }\n\n    @Override\n    public boolean isDirect() {\n        return buffer.isDirect();\n    }\n\n    @Override\n    public void setByte(int index, int value) {\n        buffer.setByte(index, value);\n    }\n\n    @Override\n    public void setBytes(int index, byte[] src, int srcIndex, int length) {\n        buffer.setBytes(index, src, srcIndex, length);\n    }\n\n    @Override\n    public void setBytes(int index, ByteBuffer src) {\n        buffer.setBytes(index, src);\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src, int srcIndex, int length) {\n        if (length > src.readableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        // careful\n        byte[] data = new byte[length];\n        src.getBytes(srcIndex, data, 0, length);\n        setBytes(index, data, 0, length);\n    }\n\n    @Override\n    public int setBytes(int index, InputStream src, int length) throws IOException {\n        return buffer.setBytes(index, src, length);\n    }\n\n    @Override\n    public ByteBuffer toByteBuffer(int index, int length) {\n        return buffer.nioBuffer(index, length);\n    }\n\n    @Override\n    public byte[] array() {\n        return buffer.array();\n    }\n\n    @Override\n    public boolean hasArray() {\n        return buffer.hasArray();\n    }\n\n    @Override\n    public int arrayOffset() {\n        return buffer.arrayOffset();\n    }\n\n    // AbstractChannelBuffer\n\n    @Override\n    public void clear() {\n        buffer.clear();\n    }\n\n    @Override\n    public ChannelBuffer copy() {\n        return new NettyBackedChannelBuffer(buffer.copy());\n    }\n\n    @Override\n    public void discardReadBytes() {\n        buffer.discardReadBytes();\n    }\n\n    @Override\n    public void ensureWritableBytes(int writableBytes) {\n        buffer.ensureWritable(writableBytes);\n    }\n\n    @Override\n    public void getBytes(int index, byte[] dst) {\n        buffer.getBytes(index, dst);\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst) {\n        // careful\n        getBytes(index, dst, dst.writableBytes());\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst, int length) {\n        // careful\n        if (length > dst.writableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        getBytes(index, dst, dst.writerIndex(), length);\n        dst.writerIndex(dst.writerIndex() + length);\n    }\n\n    @Override\n    public void markReaderIndex() {\n        buffer.markReaderIndex();\n    }\n\n    @Override\n    public void markWriterIndex() {\n        buffer.markWriterIndex();\n    }\n\n    @Override\n    public boolean readable() {\n        return buffer.isReadable();\n    }\n\n    @Override\n    public int readableBytes() {\n        return buffer.readableBytes();\n    }\n\n    @Override\n    public byte readByte() {\n        return buffer.readByte();\n    }\n\n    @Override\n    public void readBytes(byte[] dst) {\n        buffer.readBytes(dst);\n    }\n\n    @Override\n    public void readBytes(byte[] dst, int dstIndex, int length) {\n        buffer.readBytes(dst, dstIndex, length);\n    }\n\n    @Override\n    public void readBytes(ByteBuffer dst) {\n        buffer.readBytes(dst);\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst) {\n        // careful\n        readBytes(dst, dst.writableBytes());\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst, int length) {\n        // careful\n        if (length > dst.writableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        readBytes(dst, dst.writerIndex(), length);\n        dst.writerIndex(dst.writerIndex() + length);\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst, int dstIndex, int length) {\n        // careful\n        if (readableBytes() < length) {\n            throw new IndexOutOfBoundsException();\n        }\n        byte[] data = new byte[length];\n        buffer.readBytes(data, 0, length);\n        dst.setBytes(dstIndex, data, 0, length);\n    }\n\n    @Override\n    public ChannelBuffer readBytes(int length) {\n        return new NettyBackedChannelBuffer(buffer.readBytes(length));\n    }\n\n    @Override\n    public void resetReaderIndex() {\n        buffer.resetReaderIndex();\n    }\n\n    @Override\n    public void resetWriterIndex() {\n        buffer.resetWriterIndex();\n    }\n\n    @Override\n    public int readerIndex() {\n        return buffer.readerIndex();\n    }\n\n    @Override\n    public void readerIndex(int readerIndex) {\n        buffer.readerIndex(readerIndex);\n    }\n\n    @Override\n    public void readBytes(OutputStream dst, int length) throws IOException {\n        buffer.readBytes(dst, length);\n    }\n\n    @Override\n    public void setBytes(int index, byte[] src) {\n        buffer.setBytes(index, src);\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src) {\n        // careful\n        setBytes(index, src, src.readableBytes());\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src, int length) {\n        // careful\n        if (length > src.readableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        setBytes(index, src, src.readerIndex(), length);\n        src.readerIndex(src.readerIndex() + length);\n    }\n\n    @Override\n    public void setIndex(int readerIndex, int writerIndex) {\n        buffer.setIndex(readerIndex, writerIndex);\n    }\n\n    @Override\n    public void skipBytes(int length) {\n        buffer.skipBytes(length);\n    }\n\n    @Override\n    public ByteBuffer toByteBuffer() {\n        return buffer.nioBuffer();\n    }\n\n    @Override\n    public boolean writable() {\n        return buffer.isWritable();\n    }\n\n    @Override\n    public int writableBytes() {\n        return buffer.writableBytes();\n    }\n\n    @Override\n    public void writeByte(int value) {\n        buffer.writeByte(value);\n    }\n\n    @Override\n    public void writeBytes(byte[] src) {\n        buffer.writeBytes(src);\n    }\n\n    @Override\n    public void writeBytes(byte[] src, int index, int length) {\n        buffer.writeBytes(src, index, length);\n    }\n\n    @Override\n    public void writeBytes(ByteBuffer src) {\n        buffer.writeBytes(src);\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src) {\n        // careful\n        writeBytes(src, src.readableBytes());\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src, int length) {\n        // careful\n        if (length > src.readableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        writeBytes(src, src.readerIndex(), length);\n        src.readerIndex(src.readerIndex() + length);\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src, int srcIndex, int length) {\n        // careful\n        byte[] data = new byte[length];\n        src.getBytes(srcIndex, data, 0, length);\n        writeBytes(data, 0, length);\n    }\n\n    @Override\n    public int writeBytes(InputStream src, int length) throws IOException {\n        return buffer.writeBytes(src, length);\n    }\n\n    @Override\n    public int writerIndex() {\n        return buffer.writerIndex();\n    }\n\n    @Override\n    public void writerIndex(int writerIndex) {\n        buffer.ensureWritable(writerIndex);\n        buffer.writerIndex(writerIndex);\n    }\n\n    @Override\n    public int compareTo(ChannelBuffer o) {\n        return ChannelBuffers.compare(this, o);\n    }\n\n    public void release() {\n        ReferenceCountUtil.safeRelease(buffer);\n    }\n}\n",
        "methodName": null,
        "exampleID": 234,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java",
        "line": 216,
        "sink": "io.netty.buffer.ByteBuf.readBytes",
        "source": "-",
        "sourceLine": 216,
        "qualifier": "Call to io.netty.buffer.ByteBuf.readBytes with untrusted data from [input : ByteBuf](1).",
        "line_number": 216,
        "steps": [
            {
                "line": 94,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "methodName": null,
                "exampleID": 235
            },
            {
                "line": 94,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "methodName": null,
                "exampleID": 235
            },
            {
                "line": 94,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "methodName": null,
                "exampleID": 235
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java#L268",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.transport.netty4;\n\nimport org.apache.dubbo.common.utils.Assert;\nimport org.apache.dubbo.remoting.buffer.ChannelBuffer;\nimport org.apache.dubbo.remoting.buffer.ChannelBufferFactory;\nimport org.apache.dubbo.remoting.buffer.ChannelBuffers;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.util.ReferenceCountUtil;\n\npublic class NettyBackedChannelBuffer implements ChannelBuffer {\n\n    private final ByteBuf buffer;\n\n    public NettyBackedChannelBuffer(ByteBuf buffer) {\n        Assert.notNull(buffer, \"buffer == null\");\n        this.buffer = buffer;\n    }\n\n    @Override\n    public int capacity() {\n        return buffer.capacity();\n    }\n\n    @Override\n    public ChannelBuffer copy(int index, int length) {\n        return new NettyBackedChannelBuffer(buffer.copy(index, length));\n    }\n\n    // has nothing use\n    @Override\n    public ChannelBufferFactory factory() {\n        return null;\n    }\n\n    @Override\n    public byte getByte(int index) {\n        return buffer.getByte(index);\n    }\n\n    @Override\n    public void getBytes(int index, byte[] dst, int dstIndex, int length) {\n        buffer.getBytes(index, dst, dstIndex, length);\n    }\n\n    @Override\n    public void getBytes(int index, ByteBuffer dst) {\n        buffer.getBytes(index, dst);\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst, int dstIndex, int length) {\n        // careful\n        byte[] data = new byte[length];\n        buffer.getBytes(index, data, 0, length);\n        dst.setBytes(dstIndex, data, 0, length);\n    }\n\n    @Override\n    public void getBytes(int index, OutputStream dst, int length) throws IOException {\n        buffer.getBytes(index, dst, length);\n    }\n\n    @Override\n    public boolean isDirect() {\n        return buffer.isDirect();\n    }\n\n    @Override\n    public void setByte(int index, int value) {\n        buffer.setByte(index, value);\n    }\n\n    @Override\n    public void setBytes(int index, byte[] src, int srcIndex, int length) {\n        buffer.setBytes(index, src, srcIndex, length);\n    }\n\n    @Override\n    public void setBytes(int index, ByteBuffer src) {\n        buffer.setBytes(index, src);\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src, int srcIndex, int length) {\n        if (length > src.readableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        // careful\n        byte[] data = new byte[length];\n        src.getBytes(srcIndex, data, 0, length);\n        setBytes(index, data, 0, length);\n    }\n\n    @Override\n    public int setBytes(int index, InputStream src, int length) throws IOException {\n        return buffer.setBytes(index, src, length);\n    }\n\n    @Override\n    public ByteBuffer toByteBuffer(int index, int length) {\n        return buffer.nioBuffer(index, length);\n    }\n\n    @Override\n    public byte[] array() {\n        return buffer.array();\n    }\n\n    @Override\n    public boolean hasArray() {\n        return buffer.hasArray();\n    }\n\n    @Override\n    public int arrayOffset() {\n        return buffer.arrayOffset();\n    }\n\n    // AbstractChannelBuffer\n\n    @Override\n    public void clear() {\n        buffer.clear();\n    }\n\n    @Override\n    public ChannelBuffer copy() {\n        return new NettyBackedChannelBuffer(buffer.copy());\n    }\n\n    @Override\n    public void discardReadBytes() {\n        buffer.discardReadBytes();\n    }\n\n    @Override\n    public void ensureWritableBytes(int writableBytes) {\n        buffer.ensureWritable(writableBytes);\n    }\n\n    @Override\n    public void getBytes(int index, byte[] dst) {\n        buffer.getBytes(index, dst);\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst) {\n        // careful\n        getBytes(index, dst, dst.writableBytes());\n    }\n\n    @Override\n    public void getBytes(int index, ChannelBuffer dst, int length) {\n        // careful\n        if (length > dst.writableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        getBytes(index, dst, dst.writerIndex(), length);\n        dst.writerIndex(dst.writerIndex() + length);\n    }\n\n    @Override\n    public void markReaderIndex() {\n        buffer.markReaderIndex();\n    }\n\n    @Override\n    public void markWriterIndex() {\n        buffer.markWriterIndex();\n    }\n\n    @Override\n    public boolean readable() {\n        return buffer.isReadable();\n    }\n\n    @Override\n    public int readableBytes() {\n        return buffer.readableBytes();\n    }\n\n    @Override\n    public byte readByte() {\n        return buffer.readByte();\n    }\n\n    @Override\n    public void readBytes(byte[] dst) {\n        buffer.readBytes(dst);\n    }\n\n    @Override\n    public void readBytes(byte[] dst, int dstIndex, int length) {\n        buffer.readBytes(dst, dstIndex, length);\n    }\n\n    @Override\n    public void readBytes(ByteBuffer dst) {\n        buffer.readBytes(dst);\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst) {\n        // careful\n        readBytes(dst, dst.writableBytes());\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst, int length) {\n        // careful\n        if (length > dst.writableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        readBytes(dst, dst.writerIndex(), length);\n        dst.writerIndex(dst.writerIndex() + length);\n    }\n\n    @Override\n    public void readBytes(ChannelBuffer dst, int dstIndex, int length) {\n        // careful\n        if (readableBytes() < length) {\n            throw new IndexOutOfBoundsException();\n        }\n        byte[] data = new byte[length];\n        buffer.readBytes(data, 0, length);\n        dst.setBytes(dstIndex, data, 0, length);\n    }\n\n    @Override\n    public ChannelBuffer readBytes(int length) {\n        return new NettyBackedChannelBuffer(buffer.readBytes(length));\n    }\n\n    @Override\n    public void resetReaderIndex() {\n        buffer.resetReaderIndex();\n    }\n\n    @Override\n    public void resetWriterIndex() {\n        buffer.resetWriterIndex();\n    }\n\n    @Override\n    public int readerIndex() {\n        return buffer.readerIndex();\n    }\n\n    @Override\n    public void readerIndex(int readerIndex) {\n        buffer.readerIndex(readerIndex);\n    }\n\n    @Override\n    public void readBytes(OutputStream dst, int length) throws IOException {\n        buffer.readBytes(dst, length);\n    }\n\n    @Override\n    public void setBytes(int index, byte[] src) {\n        buffer.setBytes(index, src);\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src) {\n        // careful\n        setBytes(index, src, src.readableBytes());\n    }\n\n    @Override\n    public void setBytes(int index, ChannelBuffer src, int length) {\n        // careful\n        if (length > src.readableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        setBytes(index, src, src.readerIndex(), length);\n        src.readerIndex(src.readerIndex() + length);\n    }\n\n    @Override\n    public void setIndex(int readerIndex, int writerIndex) {\n        buffer.setIndex(readerIndex, writerIndex);\n    }\n\n    @Override\n    public void skipBytes(int length) {\n        buffer.skipBytes(length);\n    }\n\n    @Override\n    public ByteBuffer toByteBuffer() {\n        return buffer.nioBuffer();\n    }\n\n    @Override\n    public boolean writable() {\n        return buffer.isWritable();\n    }\n\n    @Override\n    public int writableBytes() {\n        return buffer.writableBytes();\n    }\n\n    @Override\n    public void writeByte(int value) {\n        buffer.writeByte(value);\n    }\n\n    @Override\n    public void writeBytes(byte[] src) {\n        buffer.writeBytes(src);\n    }\n\n    @Override\n    public void writeBytes(byte[] src, int index, int length) {\n        buffer.writeBytes(src, index, length);\n    }\n\n    @Override\n    public void writeBytes(ByteBuffer src) {\n        buffer.writeBytes(src);\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src) {\n        // careful\n        writeBytes(src, src.readableBytes());\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src, int length) {\n        // careful\n        if (length > src.readableBytes()) {\n            throw new IndexOutOfBoundsException();\n        }\n        writeBytes(src, src.readerIndex(), length);\n        src.readerIndex(src.readerIndex() + length);\n    }\n\n    @Override\n    public void writeBytes(ChannelBuffer src, int srcIndex, int length) {\n        // careful\n        byte[] data = new byte[length];\n        src.getBytes(srcIndex, data, 0, length);\n        writeBytes(data, 0, length);\n    }\n\n    @Override\n    public int writeBytes(InputStream src, int length) throws IOException {\n        return buffer.writeBytes(src, length);\n    }\n\n    @Override\n    public int writerIndex() {\n        return buffer.writerIndex();\n    }\n\n    @Override\n    public void writerIndex(int writerIndex) {\n        buffer.ensureWritable(writerIndex);\n        buffer.writerIndex(writerIndex);\n    }\n\n    @Override\n    public int compareTo(ChannelBuffer o) {\n        return ChannelBuffers.compare(this, o);\n    }\n\n    public void release() {\n        ReferenceCountUtil.safeRelease(buffer);\n    }\n}\n",
        "methodName": null,
        "exampleID": 236,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyBackedChannelBuffer.java",
        "line": 268,
        "sink": "io.netty.buffer.ByteBuf.readerIndex",
        "source": "-",
        "sourceLine": 268,
        "qualifier": "Call to io.netty.buffer.ByteBuf.readerIndex with untrusted data from [input : ByteBuf](1).\nCall to io.netty.buffer.ByteBuf.readerIndex with untrusted data from [in : ByteBuf](2).",
        "line_number": 268,
        "steps": [
            {
                "line": 94,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "methodName": null,
                "exampleID": 237
            },
            {
                "line": 94,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyCodecAdapter.java",
                "methodName": null,
                "exampleID": 237
            },
            {
                "line": 106,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "methodName": null,
                "exampleID": 237
            },
            {
                "line": 106,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "methodName": null,
                "exampleID": 237
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java#L161",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.transport.netty4;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.io.Bytes;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.ssl.CertManager;\nimport org.apache.dubbo.common.ssl.ProviderCert;\nimport org.apache.dubbo.remoting.ChannelHandler;\nimport org.apache.dubbo.remoting.api.ProtocolDetector;\nimport org.apache.dubbo.remoting.api.WireProtocol;\nimport org.apache.dubbo.remoting.buffer.ChannelBuffer;\nimport org.apache.dubbo.remoting.transport.netty4.ssl.SslContexts;\n\nimport javax.net.ssl.SSLSession;\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslHandshakeCompletionEvent;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n\npublic class NettyPortUnificationServerHandler extends ByteToMessageDecoder {\n\n    private static final ErrorTypeAwareLogger LOGGER =\n            LoggerFactory.getErrorTypeAwareLogger(NettyPortUnificationServerHandler.class);\n    private final URL url;\n    private final ChannelHandler handler;\n    private final boolean detectSsl;\n    private final Map<String, WireProtocol> protocols;\n    private final Map<String, URL> urlMapper;\n    private final Map<String, ChannelHandler> handlerMapper;\n\n    public NettyPortUnificationServerHandler(\n            URL url,\n            boolean detectSsl,\n            Map<String, WireProtocol> protocols,\n            ChannelHandler handler,\n            Map<String, URL> urlMapper,\n            Map<String, ChannelHandler> handlerMapper) {\n        this.url = url;\n        this.protocols = protocols;\n        this.detectSsl = detectSsl;\n        this.handler = handler;\n        this.urlMapper = urlMapper;\n        this.handlerMapper = handlerMapper;\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        LOGGER.error(\n                INTERNAL_ERROR,\n                \"unknown error in remoting module\",\n                \"\",\n                \"Unexpected exception from downstream before protocol detected.\",\n                cause);\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        if (evt instanceof SslHandshakeCompletionEvent) {\n            SslHandshakeCompletionEvent handshakeEvent = (SslHandshakeCompletionEvent) evt;\n            if (handshakeEvent.isSuccess()) {\n                SSLSession session =\n                        ctx.pipeline().get(SslHandler.class).engine().getSession();\n                LOGGER.info(\"TLS negotiation succeed with session: \" + session);\n            } else {\n                LOGGER.error(\n                        INTERNAL_ERROR,\n                        \"\",\n                        \"\",\n                        \"TLS negotiation failed when trying to accept new connection.\",\n                        handshakeEvent.cause());\n                ctx.close();\n            }\n        }\n        super.userEventTriggered(ctx, evt);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n        // Will use the first five bytes to detect a protocol.\n        // size of telnet command ls is 2 bytes\n        if (in.readableBytes() < 2) {\n            return;\n        }\n\n        CertManager certManager =\n                url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);\n        ProviderCert providerConnectionConfig =\n                certManager.getProviderConnectionConfig(url, ctx.channel().remoteAddress());\n\n        if (providerConnectionConfig != null && isSsl(in)) {\n            enableSsl(ctx, providerConnectionConfig);\n        } else {\n            Set<String> supportedProtocolNames = new HashSet<>(protocols.keySet());\n            supportedProtocolNames.retainAll(urlMapper.keySet());\n\n            for (final String name : supportedProtocolNames) {\n                WireProtocol protocol = protocols.get(name);\n                in.markReaderIndex();\n                ChannelBuffer buf = new NettyBackedChannelBuffer(in);\n                final ProtocolDetector.Result result = protocol.detector().detect(buf);\n                in.resetReaderIndex();\n                switch (result) {\n                    case UNRECOGNIZED:\n                        continue;\n                    case RECOGNIZED:\n                        ChannelHandler localHandler = this.handlerMapper.getOrDefault(name, handler);\n                        URL localURL = this.urlMapper.getOrDefault(name, url);\n                        channel.setUrl(localURL);\n                        NettyConfigOperator operator = new NettyConfigOperator(channel, localHandler);\n                        protocol.configServerProtocolHandler(url, operator);\n                        ctx.pipeline().remove(this);\n                    case NEED_MORE_DATA:\n                        return;\n                    default:\n                        return;\n                }\n            }\n            byte[] preface = new byte[in.readableBytes()];\n            in.readBytes(preface);\n            Set<String> supported = url.getApplicationModel()\n                    .getExtensionLoader(WireProtocol.class)\n                    .getSupportedExtensions();\n            LOGGER.error(\n                    INTERNAL_ERROR,\n                    \"unknown error in remoting module\",\n                    \"\",\n                    String.format(\n                            \"Can not recognize protocol from downstream=%s . \" + \"preface=%s protocols=%s\",\n                            ctx.channel().remoteAddress(), Bytes.bytes2hex(preface), supported));\n\n            // Unknown protocol; discard everything and close the connection.\n            in.clear();\n            ctx.close();\n        }\n    }\n\n    private void enableSsl(ChannelHandlerContext ctx, ProviderCert providerConnectionConfig) {\n        ChannelPipeline p = ctx.pipeline();\n        SslContext sslContext = SslContexts.buildServerSslContext(providerConnectionConfig);\n        p.addLast(\"ssl\", sslContext.newHandler(ctx.alloc()));\n        p.addLast(\n                \"unificationA\",\n                new NettyPortUnificationServerHandler(url, false, protocols, handler, urlMapper, handlerMapper));\n        p.remove(this);\n    }\n\n    private boolean isSsl(ByteBuf buf) {\n        // at least 5 bytes to determine if data is encrypted\n        if (detectSsl && buf.readableBytes() >= 5) {\n            return SslHandler.isEncrypted(buf);\n        }\n        return false;\n    }\n}\n",
        "methodName": null,
        "exampleID": 238,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
        "line": 161,
        "sink": "io.netty.buffer.ByteBuf.clear",
        "source": "-",
        "sourceLine": 161,
        "qualifier": "Call to io.netty.buffer.ByteBuf.clear with untrusted data from [in : ByteBuf](1).",
        "line_number": 161,
        "steps": [
            {
                "line": 106,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "methodName": null,
                "exampleID": 239
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java#L179",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.transport.netty4;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.io.Bytes;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.ssl.CertManager;\nimport org.apache.dubbo.common.ssl.ProviderCert;\nimport org.apache.dubbo.remoting.ChannelHandler;\nimport org.apache.dubbo.remoting.api.ProtocolDetector;\nimport org.apache.dubbo.remoting.api.WireProtocol;\nimport org.apache.dubbo.remoting.buffer.ChannelBuffer;\nimport org.apache.dubbo.remoting.transport.netty4.ssl.SslContexts;\n\nimport javax.net.ssl.SSLSession;\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslHandshakeCompletionEvent;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n\npublic class NettyPortUnificationServerHandler extends ByteToMessageDecoder {\n\n    private static final ErrorTypeAwareLogger LOGGER =\n            LoggerFactory.getErrorTypeAwareLogger(NettyPortUnificationServerHandler.class);\n    private final URL url;\n    private final ChannelHandler handler;\n    private final boolean detectSsl;\n    private final Map<String, WireProtocol> protocols;\n    private final Map<String, URL> urlMapper;\n    private final Map<String, ChannelHandler> handlerMapper;\n\n    public NettyPortUnificationServerHandler(\n            URL url,\n            boolean detectSsl,\n            Map<String, WireProtocol> protocols,\n            ChannelHandler handler,\n            Map<String, URL> urlMapper,\n            Map<String, ChannelHandler> handlerMapper) {\n        this.url = url;\n        this.protocols = protocols;\n        this.detectSsl = detectSsl;\n        this.handler = handler;\n        this.urlMapper = urlMapper;\n        this.handlerMapper = handlerMapper;\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        LOGGER.error(\n                INTERNAL_ERROR,\n                \"unknown error in remoting module\",\n                \"\",\n                \"Unexpected exception from downstream before protocol detected.\",\n                cause);\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        if (evt instanceof SslHandshakeCompletionEvent) {\n            SslHandshakeCompletionEvent handshakeEvent = (SslHandshakeCompletionEvent) evt;\n            if (handshakeEvent.isSuccess()) {\n                SSLSession session =\n                        ctx.pipeline().get(SslHandler.class).engine().getSession();\n                LOGGER.info(\"TLS negotiation succeed with session: \" + session);\n            } else {\n                LOGGER.error(\n                        INTERNAL_ERROR,\n                        \"\",\n                        \"\",\n                        \"TLS negotiation failed when trying to accept new connection.\",\n                        handshakeEvent.cause());\n                ctx.close();\n            }\n        }\n        super.userEventTriggered(ctx, evt);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n        // Will use the first five bytes to detect a protocol.\n        // size of telnet command ls is 2 bytes\n        if (in.readableBytes() < 2) {\n            return;\n        }\n\n        CertManager certManager =\n                url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);\n        ProviderCert providerConnectionConfig =\n                certManager.getProviderConnectionConfig(url, ctx.channel().remoteAddress());\n\n        if (providerConnectionConfig != null && isSsl(in)) {\n            enableSsl(ctx, providerConnectionConfig);\n        } else {\n            Set<String> supportedProtocolNames = new HashSet<>(protocols.keySet());\n            supportedProtocolNames.retainAll(urlMapper.keySet());\n\n            for (final String name : supportedProtocolNames) {\n                WireProtocol protocol = protocols.get(name);\n                in.markReaderIndex();\n                ChannelBuffer buf = new NettyBackedChannelBuffer(in);\n                final ProtocolDetector.Result result = protocol.detector().detect(buf);\n                in.resetReaderIndex();\n                switch (result) {\n                    case UNRECOGNIZED:\n                        continue;\n                    case RECOGNIZED:\n                        ChannelHandler localHandler = this.handlerMapper.getOrDefault(name, handler);\n                        URL localURL = this.urlMapper.getOrDefault(name, url);\n                        channel.setUrl(localURL);\n                        NettyConfigOperator operator = new NettyConfigOperator(channel, localHandler);\n                        protocol.configServerProtocolHandler(url, operator);\n                        ctx.pipeline().remove(this);\n                    case NEED_MORE_DATA:\n                        return;\n                    default:\n                        return;\n                }\n            }\n            byte[] preface = new byte[in.readableBytes()];\n            in.readBytes(preface);\n            Set<String> supported = url.getApplicationModel()\n                    .getExtensionLoader(WireProtocol.class)\n                    .getSupportedExtensions();\n            LOGGER.error(\n                    INTERNAL_ERROR,\n                    \"unknown error in remoting module\",\n                    \"\",\n                    String.format(\n                            \"Can not recognize protocol from downstream=%s . \" + \"preface=%s protocols=%s\",\n                            ctx.channel().remoteAddress(), Bytes.bytes2hex(preface), supported));\n\n            // Unknown protocol; discard everything and close the connection.\n            in.clear();\n            ctx.close();\n        }\n    }\n\n    private void enableSsl(ChannelHandlerContext ctx, ProviderCert providerConnectionConfig) {\n        ChannelPipeline p = ctx.pipeline();\n        SslContext sslContext = SslContexts.buildServerSslContext(providerConnectionConfig);\n        p.addLast(\"ssl\", sslContext.newHandler(ctx.alloc()));\n        p.addLast(\n                \"unificationA\",\n                new NettyPortUnificationServerHandler(url, false, protocols, handler, urlMapper, handlerMapper));\n        p.remove(this);\n    }\n\n    private boolean isSsl(ByteBuf buf) {\n        // at least 5 bytes to determine if data is encrypted\n        if (detectSsl && buf.readableBytes() >= 5) {\n            return SslHandler.isEncrypted(buf);\n        }\n        return false;\n    }\n}\n",
        "methodName": null,
        "exampleID": 240,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
        "line": 179,
        "sink": "io.netty.handler.ssl.SslHandler.isEncrypted",
        "source": "-",
        "sourceLine": 179,
        "qualifier": "Call to io.netty.handler.ssl.SslHandler.isEncrypted with untrusted data from [in : ByteBuf](1).",
        "line_number": 179,
        "steps": [
            {
                "line": 106,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyPortUnificationServerHandler.java",
                "methodName": null,
                "exampleID": 241
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/ssl/SslServerTlsHandler.java#L128",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.transport.netty4.ssl;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.ssl.AuthPolicy;\nimport org.apache.dubbo.common.ssl.CertManager;\nimport org.apache.dubbo.common.ssl.ProviderCert;\n\nimport javax.net.ssl.SSLSession;\n\nimport java.util.List;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslHandshakeCompletionEvent;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n\npublic class SslServerTlsHandler extends ByteToMessageDecoder {\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(SslServerTlsHandler.class);\n\n    private final URL url;\n\n    private final boolean sslDetected;\n\n    public SslServerTlsHandler(URL url) {\n        this.url = url;\n        this.sslDetected = false;\n    }\n\n    public SslServerTlsHandler(URL url, boolean sslDetected) {\n        this.url = url;\n        this.sslDetected = sslDetected;\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        logger.error(\n                INTERNAL_ERROR,\n                \"unknown error in remoting module\",\n                \"\",\n                \"TLS negotiation failed when trying to accept new connection.\",\n                cause);\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        if (evt instanceof SslHandshakeCompletionEvent) {\n            SslHandshakeCompletionEvent handshakeEvent = (SslHandshakeCompletionEvent) evt;\n            if (handshakeEvent.isSuccess()) {\n                SSLSession session =\n                        ctx.pipeline().get(SslHandler.class).engine().getSession();\n                logger.info(\"TLS negotiation succeed with: \" + session.getPeerHost());\n                // Remove after handshake success.\n                ctx.pipeline().remove(this);\n            } else {\n                logger.error(\n                        INTERNAL_ERROR,\n                        \"\",\n                        \"\",\n                        \"TLS negotiation failed when trying to accept new connection.\",\n                        handshakeEvent.cause());\n                ctx.close();\n            }\n        }\n        super.userEventTriggered(ctx, evt);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list)\n            throws Exception {\n        // Will use the first five bytes to detect a protocol.\n        if (byteBuf.readableBytes() < 5) {\n            return;\n        }\n\n        if (sslDetected) {\n            return;\n        }\n\n        CertManager certManager =\n                url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);\n        ProviderCert providerConnectionConfig = certManager.getProviderConnectionConfig(\n                url, channelHandlerContext.channel().remoteAddress());\n\n        if (providerConnectionConfig == null) {\n            channelHandlerContext.pipeline().remove(this);\n            return;\n        }\n\n        if (isSsl(byteBuf)) {\n            SslContext sslContext = SslContexts.buildServerSslContext(providerConnectionConfig);\n            enableSsl(channelHandlerContext, sslContext);\n            return;\n        }\n\n        if (providerConnectionConfig.getAuthPolicy() == AuthPolicy.NONE) {\n            channelHandlerContext.pipeline().remove(this);\n            return;\n        }\n\n        logger.error(INTERNAL_ERROR, \"\", \"\", \"TLS negotiation failed when trying to accept new connection.\");\n        channelHandlerContext.close();\n    }\n\n    private boolean isSsl(ByteBuf buf) {\n        return SslHandler.isEncrypted(buf);\n    }\n\n    private void enableSsl(ChannelHandlerContext ctx, SslContext sslContext) {\n        ChannelPipeline p = ctx.pipeline();\n        ctx.pipeline().addAfter(ctx.name(), null, sslContext.newHandler(ctx.alloc()));\n        p.addLast(\"unificationA\", new SslServerTlsHandler(url, true));\n        p.remove(this);\n    }\n}\n",
        "methodName": null,
        "exampleID": 242,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/ssl/SslServerTlsHandler.java",
        "line": 128,
        "sink": "io.netty.handler.ssl.SslHandler.isEncrypted",
        "source": "-",
        "sourceLine": 128,
        "qualifier": "Call to io.netty.handler.ssl.SslHandler.isEncrypted with untrusted data from [byteBuf : ByteBuf](1).",
        "line_number": 128,
        "steps": [
            {
                "line": 91,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/ssl/SslServerTlsHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/ssl/SslServerTlsHandler.java",
                "methodName": null,
                "exampleID": 243
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java#L103",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.transport.netty4;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.NetUtils;\nimport org.apache.dubbo.remoting.Channel;\nimport org.apache.dubbo.remoting.ChannelHandler;\n\nimport java.net.InetSocketAddress;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport io.netty.channel.ChannelDuplexHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.handler.timeout.IdleStateEvent;\n\n/**\n * NettyServerHandler.\n */\n@io.netty.channel.ChannelHandler.Sharable\npublic class NettyServerHandler extends ChannelDuplexHandler {\n    private static final Logger logger = LoggerFactory.getLogger(NettyServerHandler.class);\n    /**\n     * the cache for alive worker channel.\n     * <ip:port, dubbo channel>\n     */\n    private final Map<String, Channel> channels = new ConcurrentHashMap<>();\n\n    private final URL url;\n\n    private final ChannelHandler handler;\n\n    public NettyServerHandler(URL url, ChannelHandler handler) {\n        if (url == null) {\n            throw new IllegalArgumentException(\"url == null\");\n        }\n        if (handler == null) {\n            throw new IllegalArgumentException(\"handler == null\");\n        }\n        this.url = url;\n        this.handler = handler;\n    }\n\n    public Map<String, Channel> getChannels() {\n        return channels;\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n        if (channel != null) {\n            channels.put(\n                    NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()), channel);\n        }\n        handler.connected(channel);\n\n        if (logger.isInfoEnabled()) {\n            logger.info(\"The connection of \" + channel.getRemoteAddress() + \" -> \" + channel.getLocalAddress()\n                    + \" is established.\");\n        }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n        try {\n            channels.remove(\n                    NetUtils.toAddressString((InetSocketAddress) ctx.channel().remoteAddress()));\n            handler.disconnected(channel);\n        } finally {\n            NettyChannel.removeChannel(ctx.channel());\n        }\n\n        if (logger.isInfoEnabled()) {\n            logger.info(\"The connection of \" + channel.getRemoteAddress() + \" -> \" + channel.getLocalAddress()\n                    + \" is disconnected.\");\n        }\n    }\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n        handler.received(channel, msg);\n        // trigger qos handler\n        ctx.fireChannelRead(msg);\n    }\n\n    @Override\n    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n        super.write(ctx, msg, promise);\n        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n        handler.sent(channel, msg);\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        // server will close channel when server don't receive any heartbeat from client util timeout.\n        if (evt instanceof IdleStateEvent) {\n            NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n            try {\n                logger.info(\"IdleStateEvent triggered, close channel \" + channel);\n                channel.close();\n            } finally {\n                NettyChannel.removeChannelIfDisconnected(ctx.channel());\n            }\n        }\n        super.userEventTriggered(ctx, evt);\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler);\n        try {\n            handler.caught(channel, cause);\n        } finally {\n            NettyChannel.removeChannelIfDisconnected(ctx.channel());\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 244,
        "dataset": "codeql",
        "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
        "line": 103,
        "sink": "io.netty.channel.ChannelHandlerContext.fireChannelRead",
        "source": "-",
        "sourceLine": 103,
        "qualifier": "Call to io.netty.channel.ChannelHandlerContext.fireChannelRead with untrusted data from [msg : Object](1).",
        "line_number": 103,
        "steps": [
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 245
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/stub/FutureToObserverAdaptor.java#L36",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.stub;\n\nimport org.apache.dubbo.common.stream.StreamObserver;\n\nimport java.util.concurrent.CompletableFuture;\n\npublic class FutureToObserverAdaptor<T> implements StreamObserver<T> {\n\n    private final CompletableFuture<T> future;\n\n    public FutureToObserverAdaptor(CompletableFuture<T> future) {\n        this.future = future;\n    }\n\n    @Override\n    public void onNext(T data) {\n        if (future.isDone() || future.isCancelled() || future.isCompletedExceptionally()) {\n            throw new IllegalStateException(\"Too many response for unary method\");\n        }\n        future.complete(data);\n    }\n\n    @Override\n    public void onError(Throwable throwable) {\n        if (future.isDone() || future.isCancelled() || future.isCompletedExceptionally()) {\n            throw new IllegalStateException(\"Too many response for unary method\");\n        }\n        future.completeExceptionally(throwable);\n    }\n\n    @Override\n    public void onCompleted() {\n        if (future.isDone() || future.isCancelled() || future.isCompletedExceptionally()) {\n            return;\n        }\n        throw new IllegalStateException(\"Completed without value or exception \");\n    }\n}\n",
        "methodName": null,
        "exampleID": 246,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-api/src/main/java/org/apache/dubbo/rpc/stub/FutureToObserverAdaptor.java",
        "line": 36,
        "sink": "java.util.concurrent.CompletableFuture<T>.complete",
        "source": "-",
        "sourceLine": 36,
        "qualifier": "Call to java.util.concurrent.CompletableFuture<T>.complete with untrusted data from [msg : Http2StreamFrame](1).\nCall to java.util.concurrent.CompletableFuture<T>.complete with untrusted data from [msg : Object](2).",
        "line_number": 36,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 247
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 247
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 247
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 247
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/filter/TraceFilter.java#L63",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.dubbo.filter;\n\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.extension.Activate;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.common.utils.ConcurrentHashSet;\nimport org.apache.dubbo.common.utils.JsonUtils;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.remoting.Channel;\nimport org.apache.dubbo.remoting.Constants;\nimport org.apache.dubbo.rpc.Filter;\nimport org.apache.dubbo.rpc.Invocation;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.Result;\nimport org.apache.dubbo.rpc.RpcContext;\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.support.RpcUtils;\n\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_PARSE;\n\n/**\n * TraceFilter\n */\n@Activate(group = CommonConstants.PROVIDER)\npublic class TraceFilter implements Filter {\n\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(TraceFilter.class);\n\n    private static final String TRACE_MAX = \"trace.max\";\n\n    private static final String TRACE_COUNT = \"trace.count\";\n\n    private static final ConcurrentMap<String, Set<Channel>> TRACERS = new ConcurrentHashMap<>();\n\n    public static void addTracer(Class<?> type, String method, Channel channel, int max) {\n        channel.setAttribute(TRACE_MAX, max);\n        channel.setAttribute(TRACE_COUNT, new AtomicInteger());\n        String key = StringUtils.isNotEmpty(method) ? type.getName() + \".\" + method : type.getName();\n        Set<Channel> channels = TRACERS.computeIfAbsent(key, k -> new ConcurrentHashSet<>());\n        channels.add(channel);\n    }\n\n    public static void removeTracer(Class<?> type, String method, Channel channel) {\n        channel.removeAttribute(TRACE_MAX);\n        channel.removeAttribute(TRACE_COUNT);\n        String key = StringUtils.isNotEmpty(method) ? type.getName() + \".\" + method : type.getName();\n        Set<Channel> channels = TRACERS.get(key);\n        if (channels != null) {\n            channels.remove(channel);\n        }\n    }\n\n    @Override\n    public Result invoke(Invoker<?> invoker, Invocation invocation) throws RpcException {\n        long start = System.currentTimeMillis();\n        Result result = invoker.invoke(invocation);\n        long end = System.currentTimeMillis();\n        if (TRACERS.size() > 0) {\n            String key = invoker.getInterface().getName() + \".\" + RpcUtils.getMethodName(invocation);\n            Set<Channel> channels = TRACERS.get(key);\n            if (CollectionUtils.isEmpty(channels)) {\n                key = invoker.getInterface().getName();\n                channels = TRACERS.get(key);\n            }\n            if (CollectionUtils.isNotEmpty(channels)) {\n                for (Channel channel : new ArrayList<>(channels)) {\n                    if (channel.isConnected()) {\n                        try {\n                            int max = 1;\n                            Integer m = (Integer) channel.getAttribute(TRACE_MAX);\n                            if (m != null) {\n                                max = m;\n                            }\n                            int count;\n                            AtomicInteger c = (AtomicInteger) channel.getAttribute(TRACE_COUNT);\n                            if (c == null) {\n                                c = new AtomicInteger();\n                                channel.setAttribute(TRACE_COUNT, c);\n                            }\n                            count = c.getAndIncrement();\n                            if (count < max) {\n                                String prompt =\n                                        channel.getUrl().getParameter(Constants.PROMPT_KEY, Constants.DEFAULT_PROMPT);\n                                channel.send(\n                                        \"\\r\\n\" + RpcContext.getServiceContext().getRemoteAddress() + \" -> \"\n                                                + invoker.getInterface().getName()\n                                                + \".\" + RpcUtils.getMethodName(invocation)\n                                                + \"(\" + JsonUtils.toJson(invocation.getArguments()) + \")\" + \" -> \"\n                                                + JsonUtils.toJson(result.getValue())\n                                                + \"\\r\\nelapsed: \" + (end - start) + \" ms.\"\n                                                + \"\\r\\n\\r\\n\" + prompt);\n                            }\n                            if (count >= max - 1) {\n                                channels.remove(channel);\n                            }\n                        } catch (Throwable e) {\n                            channels.remove(channel);\n                            logger.warn(PROTOCOL_FAILED_PARSE, \"\", \"\", e.getMessage(), e);\n                        }\n                    } else {\n                        channels.remove(channel);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\n",
        "methodName": null,
        "exampleID": 248,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/main/java/org/apache/dubbo/rpc/protocol/dubbo/filter/TraceFilter.java",
        "line": 63,
        "sink": "java.util.concurrent.ConcurrentMap<String,Set<Channel>>.computeIfAbsent",
        "source": "-",
        "sourceLine": 63,
        "qualifier": "Call to java.util.concurrent.ConcurrentMap<String,Set<Channel>>.computeIfAbsent with untrusted data from [msg : Object](1).\nCall to java.util.concurrent.ConcurrentMap<String,Set<Channel>>.computeIfAbsent with untrusted data from [msg : Object](2).\nCall to java.util.concurrent.ConcurrentMap<String,Set<Channel>>.computeIfAbsent with untrusted data from [msg : Object](3).",
        "line_number": 63,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 249
            },
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 249
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 249
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 249
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/ResteasyContext.java#L122",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.rest.extension.resteasy;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.metadata.rest.media.MediaType;\nimport org.apache.dubbo.rpc.protocol.rest.deploy.ServiceDeployer;\nimport org.apache.dubbo.rpc.protocol.rest.extension.resteasy.filter.DubboContainerResponseContextImpl;\nimport org.apache.dubbo.rpc.protocol.rest.extension.resteasy.filter.DubboPreMatchContainerRequestContext;\nimport org.apache.dubbo.rpc.protocol.rest.filter.ServiceInvokeRestFilter;\nimport org.apache.dubbo.rpc.protocol.rest.netty.ChunkOutputStream;\nimport org.apache.dubbo.rpc.protocol.rest.netty.NettyHttpResponse;\nimport org.apache.dubbo.rpc.protocol.rest.request.NettyRequestFacade;\nimport org.apache.dubbo.rpc.protocol.rest.request.RequestFacade;\nimport org.apache.dubbo.rpc.protocol.rest.util.MediaTypeUtil;\n\nimport javax.ws.rs.container.ContainerRequestFilter;\nimport javax.ws.rs.container.ContainerResponseFilter;\nimport javax.ws.rs.core.MultivaluedMap;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.List;\nimport java.util.Map;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpRequest;\nimport org.jboss.resteasy.core.interception.ResponseContainerRequestContext;\nimport org.jboss.resteasy.plugins.server.netty.NettyHttpRequest;\nimport org.jboss.resteasy.plugins.server.netty.NettyUtil;\nimport org.jboss.resteasy.specimpl.BuiltResponse;\nimport org.jboss.resteasy.specimpl.ResteasyHttpHeaders;\nimport org.jboss.resteasy.spi.HttpResponse;\nimport org.jboss.resteasy.spi.ResteasyUriInfo;\n\npublic interface ResteasyContext {\n    String HTTP_PROTOCOL = \"http://\";\n    String HTTP = \"http\";\n    String HTTPS_PROTOCOL = \"https://\";\n\n    /**\n     * return extensions that are  filtered by  extension type\n     *\n     * @param extension\n     * @param <T>\n     * @return\n     */\n    default <T> List<T> getExtension(ServiceDeployer serviceDeployer, Class<T> extension) {\n\n        return serviceDeployer.getExtensions(extension);\n    }\n\n    default DubboPreMatchContainerRequestContext convertHttpRequestToContainerRequestContext(\n            RequestFacade requestFacade, ContainerRequestFilter[] requestFilters) {\n\n        NettyRequestFacade nettyRequestFacade = (NettyRequestFacade) requestFacade;\n        HttpRequest request = (HttpRequest) requestFacade.getRequest();\n\n        NettyHttpRequest nettyRequest = createNettyHttpRequest(nettyRequestFacade, request);\n\n        if (request instanceof HttpContent) {\n\n            try {\n                byte[] inputStream = requestFacade.getInputStream();\n                ByteBuf buffer =\n                        nettyRequestFacade.getNettyChannelContext().alloc().buffer();\n                buffer.writeBytes(inputStream);\n                nettyRequest.setContentBuffer(buffer);\n            } catch (IOException e) {\n            }\n        }\n\n        return new DubboPreMatchContainerRequestContext(nettyRequest, requestFilters, null);\n    }\n\n    default ResteasyUriInfo extractUriInfo(HttpRequest request) {\n        String host = HttpHeaders.getHost(request, \"unknown\");\n        if (\"\".equals(host)) {\n            host = \"unknown\";\n        }\n        String uri = request.getUri();\n\n        String uriString;\n\n        // If we appear to have an absolute URL, don't try to recreate it from the host and request line.\n        if (uri.startsWith(HTTP_PROTOCOL) || uri.startsWith(HTTPS_PROTOCOL)) {\n            uriString = uri;\n        } else {\n            uriString = HTTP + \"://\" + host + uri;\n        }\n\n        URI absoluteURI = URI.create(uriString);\n        return new ResteasyUriInfo(uriString, absoluteURI.getRawQuery(), \"\");\n    }\n\n    default NettyHttpRequest createNettyHttpRequest(NettyRequestFacade nettyRequestFacade, HttpRequest request) {\n        ResteasyHttpHeaders headers = NettyUtil.extractHttpHeaders(request);\n        ResteasyUriInfo uriInfo = extractUriInfo(request);\n        NettyHttpRequest nettyRequest = new NettyHttpRequest(\n                nettyRequestFacade.getNettyChannelContext(),\n                headers,\n                uriInfo,\n                request.getMethod().name(),\n                null,\n                null,\n                HttpHeaders.is100ContinueExpected(request));\n\n        return nettyRequest;\n    }\n\n    default NettyHttpRequest createNettyHttpRequest(RequestFacade requestFacade) {\n        NettyRequestFacade nettyRequestFacade = (NettyRequestFacade) requestFacade;\n        HttpRequest request = (HttpRequest) requestFacade.getRequest();\n\n        ResteasyHttpHeaders headers = NettyUtil.extractHttpHeaders(request);\n        ResteasyUriInfo uriInfo = extractUriInfo(request);\n        NettyHttpRequest nettyRequest = new NettyHttpRequest(\n                nettyRequestFacade.getNettyChannelContext(),\n                headers,\n                uriInfo,\n                request.getMethod().name(),\n                null,\n                null,\n                HttpHeaders.is100ContinueExpected(request));\n\n        return nettyRequest;\n    }\n\n    default void writeResteasyResponse(\n            URL url, RequestFacade requestFacade, NettyHttpResponse response, BuiltResponse restResponse)\n            throws Exception {\n        if (restResponse.getMediaType() != null) {\n            MediaType mediaType = MediaTypeUtil.convertMediaType(\n                    restResponse.getEntityClass(), restResponse.getMediaType().toString());\n            ServiceInvokeRestFilter.writeResult(\n                    response, url, restResponse.getEntity(), restResponse.getEntityClass(), mediaType);\n        } else {\n            ServiceInvokeRestFilter.writeResult(\n                    response, requestFacade, url, restResponse.getEntity(), restResponse.getEntityClass());\n        }\n    }\n\n    default MediaType getAcceptMediaType(RequestFacade request, Class<?> returnType) {\n\n        return ServiceInvokeRestFilter.getAcceptMediaType(request, returnType);\n    }\n\n    default void addResponseHeaders(NettyHttpResponse response, MultivaluedMap<String, Object> headers) {\n        if (headers == null || headers.isEmpty()) {\n\n            return;\n        }\n        for (Map.Entry<String, List<Object>> entry : headers.entrySet()) {\n\n            String key = entry.getKey();\n            List<Object> value = entry.getValue();\n            if (value == null || value.isEmpty()) {\n                continue;\n            }\n            for (Object tmp : value) {\n                response.addOutputHeaders(key, tmp.toString());\n            }\n        }\n    }\n\n    default DubboContainerResponseContextImpl createContainerResponseContext(\n            Object originRequest,\n            RequestFacade request,\n            HttpResponse httpResponse,\n            BuiltResponse jaxrsResponse,\n            ContainerResponseFilter[] responseFilters) {\n\n        NettyHttpRequest nettyHttpRequest =\n                originRequest == null ? createNettyHttpRequest(request) : (NettyHttpRequest) originRequest;\n\n        ResponseContainerRequestContext requestContext = new ResponseContainerRequestContext(nettyHttpRequest);\n        DubboContainerResponseContextImpl responseContext = new DubboContainerResponseContextImpl(\n                nettyHttpRequest, httpResponse, jaxrsResponse, requestContext, responseFilters, null, null);\n\n        return responseContext;\n    }\n\n    default void restOutputStream(NettyHttpResponse response) throws IOException {\n        ChunkOutputStream outputStream = (ChunkOutputStream) response.getOutputStream();\n        outputStream.reset();\n    }\n}\n",
        "methodName": null,
        "exampleID": 250,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/ResteasyContext.java",
        "line": 122,
        "sink": "io.netty.handler.codec.http.HttpHeaders.is100ContinueExpected",
        "source": "-",
        "sourceLine": 122,
        "qualifier": "Call to io.netty.handler.codec.http.HttpHeaders.is100ContinueExpected with untrusted data from [request : FullHttpRequest](1).",
        "line_number": 122,
        "steps": [
            {
                "line": 58,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "methodName": null,
                "exampleID": 251
            },
            {
                "line": 58,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "methodName": null,
                "exampleID": 251
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/ResteasyContext.java#L140",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.rest.extension.resteasy;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.metadata.rest.media.MediaType;\nimport org.apache.dubbo.rpc.protocol.rest.deploy.ServiceDeployer;\nimport org.apache.dubbo.rpc.protocol.rest.extension.resteasy.filter.DubboContainerResponseContextImpl;\nimport org.apache.dubbo.rpc.protocol.rest.extension.resteasy.filter.DubboPreMatchContainerRequestContext;\nimport org.apache.dubbo.rpc.protocol.rest.filter.ServiceInvokeRestFilter;\nimport org.apache.dubbo.rpc.protocol.rest.netty.ChunkOutputStream;\nimport org.apache.dubbo.rpc.protocol.rest.netty.NettyHttpResponse;\nimport org.apache.dubbo.rpc.protocol.rest.request.NettyRequestFacade;\nimport org.apache.dubbo.rpc.protocol.rest.request.RequestFacade;\nimport org.apache.dubbo.rpc.protocol.rest.util.MediaTypeUtil;\n\nimport javax.ws.rs.container.ContainerRequestFilter;\nimport javax.ws.rs.container.ContainerResponseFilter;\nimport javax.ws.rs.core.MultivaluedMap;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.List;\nimport java.util.Map;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpRequest;\nimport org.jboss.resteasy.core.interception.ResponseContainerRequestContext;\nimport org.jboss.resteasy.plugins.server.netty.NettyHttpRequest;\nimport org.jboss.resteasy.plugins.server.netty.NettyUtil;\nimport org.jboss.resteasy.specimpl.BuiltResponse;\nimport org.jboss.resteasy.specimpl.ResteasyHttpHeaders;\nimport org.jboss.resteasy.spi.HttpResponse;\nimport org.jboss.resteasy.spi.ResteasyUriInfo;\n\npublic interface ResteasyContext {\n    String HTTP_PROTOCOL = \"http://\";\n    String HTTP = \"http\";\n    String HTTPS_PROTOCOL = \"https://\";\n\n    /**\n     * return extensions that are  filtered by  extension type\n     *\n     * @param extension\n     * @param <T>\n     * @return\n     */\n    default <T> List<T> getExtension(ServiceDeployer serviceDeployer, Class<T> extension) {\n\n        return serviceDeployer.getExtensions(extension);\n    }\n\n    default DubboPreMatchContainerRequestContext convertHttpRequestToContainerRequestContext(\n            RequestFacade requestFacade, ContainerRequestFilter[] requestFilters) {\n\n        NettyRequestFacade nettyRequestFacade = (NettyRequestFacade) requestFacade;\n        HttpRequest request = (HttpRequest) requestFacade.getRequest();\n\n        NettyHttpRequest nettyRequest = createNettyHttpRequest(nettyRequestFacade, request);\n\n        if (request instanceof HttpContent) {\n\n            try {\n                byte[] inputStream = requestFacade.getInputStream();\n                ByteBuf buffer =\n                        nettyRequestFacade.getNettyChannelContext().alloc().buffer();\n                buffer.writeBytes(inputStream);\n                nettyRequest.setContentBuffer(buffer);\n            } catch (IOException e) {\n            }\n        }\n\n        return new DubboPreMatchContainerRequestContext(nettyRequest, requestFilters, null);\n    }\n\n    default ResteasyUriInfo extractUriInfo(HttpRequest request) {\n        String host = HttpHeaders.getHost(request, \"unknown\");\n        if (\"\".equals(host)) {\n            host = \"unknown\";\n        }\n        String uri = request.getUri();\n\n        String uriString;\n\n        // If we appear to have an absolute URL, don't try to recreate it from the host and request line.\n        if (uri.startsWith(HTTP_PROTOCOL) || uri.startsWith(HTTPS_PROTOCOL)) {\n            uriString = uri;\n        } else {\n            uriString = HTTP + \"://\" + host + uri;\n        }\n\n        URI absoluteURI = URI.create(uriString);\n        return new ResteasyUriInfo(uriString, absoluteURI.getRawQuery(), \"\");\n    }\n\n    default NettyHttpRequest createNettyHttpRequest(NettyRequestFacade nettyRequestFacade, HttpRequest request) {\n        ResteasyHttpHeaders headers = NettyUtil.extractHttpHeaders(request);\n        ResteasyUriInfo uriInfo = extractUriInfo(request);\n        NettyHttpRequest nettyRequest = new NettyHttpRequest(\n                nettyRequestFacade.getNettyChannelContext(),\n                headers,\n                uriInfo,\n                request.getMethod().name(),\n                null,\n                null,\n                HttpHeaders.is100ContinueExpected(request));\n\n        return nettyRequest;\n    }\n\n    default NettyHttpRequest createNettyHttpRequest(RequestFacade requestFacade) {\n        NettyRequestFacade nettyRequestFacade = (NettyRequestFacade) requestFacade;\n        HttpRequest request = (HttpRequest) requestFacade.getRequest();\n\n        ResteasyHttpHeaders headers = NettyUtil.extractHttpHeaders(request);\n        ResteasyUriInfo uriInfo = extractUriInfo(request);\n        NettyHttpRequest nettyRequest = new NettyHttpRequest(\n                nettyRequestFacade.getNettyChannelContext(),\n                headers,\n                uriInfo,\n                request.getMethod().name(),\n                null,\n                null,\n                HttpHeaders.is100ContinueExpected(request));\n\n        return nettyRequest;\n    }\n\n    default void writeResteasyResponse(\n            URL url, RequestFacade requestFacade, NettyHttpResponse response, BuiltResponse restResponse)\n            throws Exception {\n        if (restResponse.getMediaType() != null) {\n            MediaType mediaType = MediaTypeUtil.convertMediaType(\n                    restResponse.getEntityClass(), restResponse.getMediaType().toString());\n            ServiceInvokeRestFilter.writeResult(\n                    response, url, restResponse.getEntity(), restResponse.getEntityClass(), mediaType);\n        } else {\n            ServiceInvokeRestFilter.writeResult(\n                    response, requestFacade, url, restResponse.getEntity(), restResponse.getEntityClass());\n        }\n    }\n\n    default MediaType getAcceptMediaType(RequestFacade request, Class<?> returnType) {\n\n        return ServiceInvokeRestFilter.getAcceptMediaType(request, returnType);\n    }\n\n    default void addResponseHeaders(NettyHttpResponse response, MultivaluedMap<String, Object> headers) {\n        if (headers == null || headers.isEmpty()) {\n\n            return;\n        }\n        for (Map.Entry<String, List<Object>> entry : headers.entrySet()) {\n\n            String key = entry.getKey();\n            List<Object> value = entry.getValue();\n            if (value == null || value.isEmpty()) {\n                continue;\n            }\n            for (Object tmp : value) {\n                response.addOutputHeaders(key, tmp.toString());\n            }\n        }\n    }\n\n    default DubboContainerResponseContextImpl createContainerResponseContext(\n            Object originRequest,\n            RequestFacade request,\n            HttpResponse httpResponse,\n            BuiltResponse jaxrsResponse,\n            ContainerResponseFilter[] responseFilters) {\n\n        NettyHttpRequest nettyHttpRequest =\n                originRequest == null ? createNettyHttpRequest(request) : (NettyHttpRequest) originRequest;\n\n        ResponseContainerRequestContext requestContext = new ResponseContainerRequestContext(nettyHttpRequest);\n        DubboContainerResponseContextImpl responseContext = new DubboContainerResponseContextImpl(\n                nettyHttpRequest, httpResponse, jaxrsResponse, requestContext, responseFilters, null, null);\n\n        return responseContext;\n    }\n\n    default void restOutputStream(NettyHttpResponse response) throws IOException {\n        ChunkOutputStream outputStream = (ChunkOutputStream) response.getOutputStream();\n        outputStream.reset();\n    }\n}\n",
        "methodName": null,
        "exampleID": 252,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/extension/resteasy/ResteasyContext.java",
        "line": 140,
        "sink": "io.netty.handler.codec.http.HttpHeaders.is100ContinueExpected",
        "source": "-",
        "sourceLine": 140,
        "qualifier": "Call to io.netty.handler.codec.http.HttpHeaders.is100ContinueExpected with untrusted data from [request : FullHttpRequest](1).",
        "line_number": 140,
        "steps": [
            {
                "line": 58,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "methodName": null,
                "exampleID": 253
            },
            {
                "line": 58,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "methodName": null,
                "exampleID": 253
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/ssl/SslServerTlsHandler.java#L128",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.rest.netty.ssl;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.ssl.AuthPolicy;\nimport org.apache.dubbo.common.ssl.CertManager;\nimport org.apache.dubbo.common.ssl.ProviderCert;\n\nimport javax.net.ssl.SSLSession;\n\nimport java.util.List;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.handler.ssl.SslHandshakeCompletionEvent;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\n\npublic class SslServerTlsHandler extends ByteToMessageDecoder {\n    private static final ErrorTypeAwareLogger logger = LoggerFactory.getErrorTypeAwareLogger(SslServerTlsHandler.class);\n\n    private final URL url;\n\n    private final boolean sslDetected;\n\n    public SslServerTlsHandler(URL url) {\n        this.url = url;\n        this.sslDetected = false;\n    }\n\n    public SslServerTlsHandler(URL url, boolean sslDetected) {\n        this.url = url;\n        this.sslDetected = sslDetected;\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        logger.error(\n                INTERNAL_ERROR,\n                \"unknown error in remoting module\",\n                \"\",\n                \"TLS negotiation failed when trying to accept new connection.\",\n                cause);\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        if (evt instanceof SslHandshakeCompletionEvent) {\n            SslHandshakeCompletionEvent handshakeEvent = (SslHandshakeCompletionEvent) evt;\n            if (handshakeEvent.isSuccess()) {\n                SSLSession session =\n                        ctx.pipeline().get(SslHandler.class).engine().getSession();\n                logger.info(\"TLS negotiation succeed with: \" + session.getPeerHost());\n                // Remove after handshake success.\n                ctx.pipeline().remove(this);\n            } else {\n                logger.error(\n                        INTERNAL_ERROR,\n                        \"\",\n                        \"\",\n                        \"TLS negotiation failed when trying to accept new connection.\",\n                        handshakeEvent.cause());\n                ctx.close();\n            }\n        }\n        super.userEventTriggered(ctx, evt);\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List<Object> list)\n            throws Exception {\n        // Will use the first five bytes to detect a protocol.\n        if (byteBuf.readableBytes() < 5) {\n            return;\n        }\n\n        if (sslDetected) {\n            return;\n        }\n\n        CertManager certManager =\n                url.getOrDefaultFrameworkModel().getBeanFactory().getBean(CertManager.class);\n        ProviderCert providerConnectionConfig = certManager.getProviderConnectionConfig(\n                url, channelHandlerContext.channel().remoteAddress());\n\n        if (providerConnectionConfig == null) {\n            channelHandlerContext.pipeline().remove(this);\n            return;\n        }\n\n        if (isSsl(byteBuf)) {\n            SslContext sslContext = SslContexts.buildServerSslContext(providerConnectionConfig);\n            enableSsl(channelHandlerContext, sslContext);\n            return;\n        }\n\n        if (providerConnectionConfig.getAuthPolicy() == AuthPolicy.NONE) {\n            channelHandlerContext.pipeline().remove(this);\n            return;\n        }\n\n        logger.error(INTERNAL_ERROR, \"\", \"\", \"TLS negotiation failed when trying to accept new connection.\");\n        channelHandlerContext.close();\n    }\n\n    private boolean isSsl(ByteBuf buf) {\n        return SslHandler.isEncrypted(buf);\n    }\n\n    private void enableSsl(ChannelHandlerContext ctx, SslContext sslContext) {\n        ChannelPipeline p = ctx.pipeline();\n        ctx.pipeline().addAfter(ctx.name(), null, sslContext.newHandler(ctx.alloc()));\n        p.addLast(\"unificationA\", new SslServerTlsHandler(url, true));\n        p.remove(this);\n    }\n}\n",
        "methodName": null,
        "exampleID": 254,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/ssl/SslServerTlsHandler.java",
        "line": 128,
        "sink": "io.netty.handler.ssl.SslHandler.isEncrypted",
        "source": "-",
        "sourceLine": 128,
        "qualifier": "Call to io.netty.handler.ssl.SslHandler.isEncrypted with untrusted data from [byteBuf : ByteBuf](1).",
        "line_number": 128,
        "steps": [
            {
                "line": 91,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/ssl/SslServerTlsHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/ssl/SslServerTlsHandler.java",
                "methodName": null,
                "exampleID": 255
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/util/DataParseUtils.java#L54",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.rest.util;\n\nimport org.apache.dubbo.common.lang.Nullable;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.common.utils.JsonUtils;\nimport org.apache.dubbo.common.utils.StringUtils;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Type;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\nimport static org.apache.dubbo.rpc.protocol.rest.constans.RestConstant.WEIGHT_IDENTIFIER;\n\npublic class DataParseUtils {\n\n    public static Object stringTypeConvert(Class<?> targetType, String value) {\n\n        if (StringUtils.isEmpty(value)) {\n            return null;\n        }\n\n        if (targetType == Boolean.class || targetType == boolean.class) {\n            return Boolean.valueOf(value);\n        }\n\n        if (targetType == String.class) {\n            return value;\n        }\n\n        if (Number.class.isAssignableFrom(targetType)) {\n            return NumberUtils.parseNumber(value, targetType);\n        }\n\n        if (targetType != null && targetType.isPrimitive()) {\n            return NumberUtils.parseNumber(value, targetType);\n        }\n\n        return value;\n    }\n\n    public static boolean isTextType(Class targetType) {\n        if (targetType == null) {\n            return false;\n        }\n\n        return targetType == Boolean.class\n                || targetType == boolean.class\n                || targetType == String.class\n                || Number.class.isAssignableFrom(targetType)\n                || targetType.isPrimitive();\n    }\n\n    /**\n     * content-type text\n     *\n     * @param object\n     * @param outputStream\n     * @throws IOException\n     */\n    public static void writeTextContent(Object object, OutputStream outputStream) throws IOException {\n        outputStream.write(objectTextConvertToByteArray(object));\n    }\n\n    /**\n     * content-type json\n     *\n     * @param object\n     * @param outputStream\n     * @throws Exception\n     */\n    public static void writeJsonContent(Object object, OutputStream outputStream) throws Exception {\n        outputStream.write(JsonUtils.toJson(object).getBytes(StandardCharsets.UTF_8));\n    }\n\n    /**\n     * content-type form\n     *\n     * @param formData\n     * @param outputStream\n     * @throws Exception\n     */\n    public static void writeFormContent(Map formData, OutputStream outputStream) throws Exception {\n        outputStream.write(serializeForm(formData, Charset.defaultCharset()).getBytes());\n    }\n\n    // TODO file multipart\n\n    public static String serializeForm(Map formData, Charset charset) {\n        StringBuilder builder = new StringBuilder();\n        formData.forEach((name, values) -> {\n            if (name == null) {\n\n                return;\n            }\n            ((List) values).forEach(value -> {\n                try {\n                    if (builder.length() != 0) {\n                        builder.append('&');\n                    }\n                    builder.append(URLEncoder.encode((String) name, charset.name()));\n                    if (value != null) {\n                        builder.append('=');\n                        builder.append(URLEncoder.encode(String.valueOf(value), charset.name()));\n                    }\n                } catch (UnsupportedEncodingException ex) {\n                    throw new IllegalStateException(ex);\n                }\n            });\n        });\n\n        return builder.toString();\n    }\n\n    public static byte[] objectTextConvertToByteArray(Object object) {\n        Class<?> objectClass = object.getClass();\n\n        if (objectClass == Boolean.class || objectClass == boolean.class) {\n            return object.toString().getBytes();\n        }\n\n        if (objectClass == String.class) {\n            return ((String) object).getBytes();\n        }\n\n        if (objectClass.isAssignableFrom(Number.class) || objectClass.isPrimitive()) {\n            return (byte[]) NumberUtils.numberToBytes((Number) object);\n        }\n\n        return object.toString().getBytes();\n    }\n\n    public static Object jsonConvert(Type targetType, byte[] body) throws Exception {\n        return JsonUtils.toJavaObject(new String(body, StandardCharsets.UTF_8), targetType);\n    }\n\n    public static Object multipartFormConvert(byte[] body, Charset charset, Class<?> targetType) throws Exception {\n        String[] pairs = tokenizeToStringArray(new String(body, StandardCharsets.UTF_8), \"&\");\n        Object result = MultiValueCreator.providerCreateMultiValueMap(targetType);\n        for (String pair : pairs) {\n            int idx = pair.indexOf('=');\n            if (idx == -1) {\n                MultiValueCreator.add(result, URLDecoder.decode(pair, charset.name()), null);\n            } else {\n                String name = URLDecoder.decode(pair.substring(0, idx), charset.name());\n                String value = URLDecoder.decode(pair.substring(idx + 1), charset.name());\n                MultiValueCreator.add(result, name, value);\n            }\n        }\n\n        return result;\n    }\n\n    public static Object multipartFormConvert(byte[] body, Class<?> targetType) throws Exception {\n        return multipartFormConvert(body, Charset.defaultCharset(), targetType);\n    }\n\n    public static String[] tokenizeToStringArray(String str, String delimiters) {\n        return tokenizeToStringArray(str, delimiters, true, true);\n    }\n\n    public static String[] tokenizeToStringArray(\n            String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {\n        if (str == null) {\n            return null;\n        } else {\n            StringTokenizer st = new StringTokenizer(str, delimiters);\n            ArrayList tokens = new ArrayList();\n\n            while (true) {\n                String token;\n                do {\n                    if (!st.hasMoreTokens()) {\n                        return toStringArray(tokens);\n                    }\n\n                    token = st.nextToken();\n                    if (trimTokens) {\n                        token = token.trim();\n                    }\n                } while (ignoreEmptyTokens && token.length() <= 0);\n\n                tokens.add(token);\n            }\n        }\n    }\n\n    public static String[] toStringArray(Collection<String> collection) {\n        return collection == null ? null : collection.toArray(new String[collection.size()]);\n    }\n\n    @Nullable\n    public static String[] parseAcceptCharset(List<String> acceptCharsets) {\n        if (CollectionUtils.isEmpty(acceptCharsets)) {\n            return new String[0];\n        }\n\n        SortedMap<Float, Set<String>> encodings = new TreeMap<>(Comparator.reverseOrder());\n        float defaultWeight = 1.0f;\n        for (String acceptCharset : acceptCharsets) {\n            String[] charsets = acceptCharset.split(\",\");\n            for (String charset : charsets) {\n                charset = charset.trim();\n                float weight = defaultWeight;\n                String enc = charset;\n                if (charset.contains(WEIGHT_IDENTIFIER)) {\n                    String[] split = charset.split(WEIGHT_IDENTIFIER);\n                    enc = split[0];\n                    weight = Float.parseFloat(split[1]);\n                }\n                encodings.computeIfAbsent(weight, k -> new HashSet<>()).add(enc);\n            }\n        }\n\n        List<String> result = new ArrayList<>();\n        encodings.values().forEach(result::addAll);\n        return result.toArray(new String[0]);\n    }\n}\n",
        "methodName": null,
        "exampleID": 256,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/util/DataParseUtils.java",
        "line": 54,
        "sink": "java.lang.Boolean.valueOf",
        "source": "-",
        "sourceLine": 54,
        "qualifier": "Call to java.lang.Boolean.valueOf with untrusted data from [request : FullHttpRequest](1).",
        "line_number": 54,
        "steps": [
            {
                "line": 58,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "methodName": null,
                "exampleID": 257
            },
            {
                "line": 58,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "methodName": null,
                "exampleID": 257
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/request/RequestFacade.java#L85",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.rest.request;\n\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.protocol.rest.constans.RestConstant;\nimport org.apache.dubbo.rpc.protocol.rest.deploy.ServiceDeployer;\nimport org.apache.dubbo.rpc.protocol.rest.util.DataParseUtils;\n\nimport java.io.IOException;\nimport java.net.URLDecoder;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static org.apache.dubbo.rpc.protocol.rest.constans.RestConstant.DEFAULT_CHARSET;\n\n/**\n * request facade for different request\n *\n * @param <T>\n */\npublic abstract class RequestFacade<T> {\n    protected Map<String, ArrayList<String>> headers = new HashMap<>();\n    protected Map<String, ArrayList<String>> parameters = new HashMap<>();\n\n    protected String path;\n    protected T request;\n    protected byte[] body = new byte[0];\n    protected ServiceDeployer serviceDeployer;\n\n    public RequestFacade(T request) {\n        this.request = request;\n        initHeaders();\n        initParameters();\n        parseBody();\n    }\n\n    public RequestFacade(T request, ServiceDeployer serviceDeployer) {\n        this(request);\n        this.serviceDeployer = serviceDeployer;\n    }\n\n    protected void initHeaders() {}\n\n    protected void initParameters() {\n        String requestURI = getRequestURI();\n        String decodedRequestURI = null;\n\n        try {\n            String enc = DEFAULT_CHARSET;\n            ArrayList<String> charset = headers.get(RestConstant.ACCEPT_CHARSET);\n            // take the highest priority charset\n            String[] parsed = DataParseUtils.parseAcceptCharset(charset);\n            if (parsed != null && parsed.length > 0) {\n                enc = parsed[0].toUpperCase();\n            }\n            decodedRequestURI = URLDecoder.decode(requestURI, enc);\n        } catch (Throwable t) {\n            // do nothing, try best to deliver\n        }\n\n        if (StringUtils.isNotEmpty(decodedRequestURI)) {\n            requestURI = decodedRequestURI;\n        }\n\n        if (requestURI != null && requestURI.contains(\"?\")) {\n\n            String queryString = requestURI.substring(requestURI.indexOf(\"?\") + 1);\n            path = requestURI.substring(0, requestURI.indexOf(\"?\"));\n\n            String[] split = queryString.split(\"&\");\n\n            for (String params : split) {\n                // key a=  ;value b==c\n                int index = params.indexOf(\"=\");\n                if (index <= 0) {\n                    continue;\n                }\n\n                String name = params.substring(0, index);\n                String value = params.substring(index + 1);\n                if (!StringUtils.isEmpty(name)) {\n                    ArrayList<String> values = parameters.get(name);\n\n                    if (values == null) {\n                        values = new ArrayList<>();\n                        parameters.put(name, values);\n                    }\n                    values.add(value);\n                }\n            }\n        } else {\n            path = requestURI;\n        }\n    }\n\n    public T getRequest() {\n        return request;\n    }\n\n    public abstract String getHeader(String name);\n\n    public abstract Enumeration<String> getHeaders(String name);\n\n    public abstract Enumeration<String> getHeaderNames();\n\n    public abstract String getMethod();\n\n    public abstract String getPath();\n\n    public abstract String getContextPath();\n\n    public abstract String getRequestURI();\n\n    public abstract String getParameter(String name);\n\n    public abstract Enumeration<String> getParameterNames();\n\n    public abstract String[] getParameterValues(String name);\n\n    public abstract Map<String, String[]> getParameterMap();\n\n    public abstract String getRemoteAddr();\n\n    public abstract String getRemoteHost();\n\n    public abstract int getRemotePort();\n\n    public abstract String getLocalAddr();\n\n    public abstract String getLocalHost();\n\n    public abstract int getLocalPort();\n\n    public abstract byte[] getInputStream() throws IOException;\n\n    protected abstract void parseBody();\n\n    public ServiceDeployer getServiceDeployer() {\n        return serviceDeployer;\n    }\n}\n",
        "methodName": null,
        "exampleID": 258,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/request/RequestFacade.java",
        "line": 85,
        "sink": "java.lang.String.indexOf",
        "source": "-",
        "sourceLine": 85,
        "qualifier": "Call to java.lang.String.indexOf with untrusted data from [request : FullHttpRequest](1).",
        "line_number": 85,
        "steps": [
            {
                "line": 58,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "methodName": null,
                "exampleID": 259
            },
            {
                "line": 58,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "methodName": null,
                "exampleID": 259
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/request/NettyRequestFacade.java#L131",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.rest.request;\n\nimport org.apache.dubbo.common.utils.IOUtils;\nimport org.apache.dubbo.rpc.protocol.rest.deploy.ServiceDeployer;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufInputStream;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.http.FullHttpRequest;\nimport io.netty.handler.codec.http.HttpContent;\n\n/**\n * netty request facade\n */\npublic class NettyRequestFacade extends RequestFacade<FullHttpRequest> {\n\n    private ChannelHandlerContext context;\n\n    public NettyRequestFacade(Object request, ChannelHandlerContext context) {\n        super((FullHttpRequest) request);\n        this.context = context;\n    }\n\n    public NettyRequestFacade(Object request, ChannelHandlerContext context, ServiceDeployer serviceDeployer) {\n        super((FullHttpRequest) request, serviceDeployer);\n        this.context = context;\n    }\n\n    protected void initHeaders() {\n        for (Map.Entry<String, String> header : request.headers()) {\n\n            String key = header.getKey();\n\n            ArrayList<String> tmpHeaders = headers.get(key);\n\n            if (tmpHeaders == null) {\n                tmpHeaders = new ArrayList<>();\n                headers.put(key, tmpHeaders);\n            }\n\n            tmpHeaders.add(header.getValue());\n        }\n    }\n\n    @Override\n    public String getHeader(String name) {\n\n        List<String> values = headers.get(name);\n\n        if (values == null && name != null) {\n            values = headers.get(name.toLowerCase());\n        }\n\n        if (values == null || values.isEmpty()) {\n            return null;\n        } else {\n            return values.get(0);\n        }\n    }\n\n    @Override\n    public Enumeration<String> getHeaders(String name) {\n\n        List<String> list = headers.get(name);\n\n        if (list == null) {\n            list = new ArrayList<>();\n        }\n\n        ListIterator<String> stringListIterator = list.listIterator();\n\n        return new Enumeration<String>() {\n            @Override\n            public boolean hasMoreElements() {\n                return stringListIterator.hasNext();\n            }\n\n            @Override\n            public String nextElement() {\n                return stringListIterator.next();\n            }\n        };\n    }\n\n    @Override\n    public Enumeration<String> getHeaderNames() {\n\n        Iterator<String> strings = headers.keySet().iterator();\n\n        return new Enumeration<String>() {\n            @Override\n            public boolean hasMoreElements() {\n                return strings.hasNext();\n            }\n\n            @Override\n            public String nextElement() {\n                return strings.next();\n            }\n        };\n    }\n\n    @Override\n    public String getMethod() {\n        return request.method().name();\n    }\n\n    @Override\n    public String getPath() {\n        return path;\n    }\n\n    @Override\n    public String getContextPath() {\n        // TODO add ContextPath\n        return null;\n    }\n\n    @Override\n    public String getRequestURI() {\n        return request.uri();\n    }\n\n    @Override\n    public String getParameter(String name) {\n        ArrayList<String> strings = parameters.get(name);\n\n        String value = null;\n        if (strings != null && !strings.isEmpty()) {\n            value = strings.get(0);\n        }\n        return value;\n    }\n\n    @Override\n    public Enumeration<String> getParameterNames() {\n\n        Iterator<String> iterator = parameters.keySet().iterator();\n\n        return new Enumeration<String>() {\n            @Override\n            public boolean hasMoreElements() {\n                return iterator.hasNext();\n            }\n\n            @Override\n            public String nextElement() {\n                return iterator.next();\n            }\n        };\n    }\n\n    @Override\n    public String[] getParameterValues(String name) {\n\n        if (!parameters.containsKey(name)) {\n\n            return null;\n        }\n        return parameters.get(name).toArray(new String[0]);\n    }\n\n    @Override\n    public Map<String, String[]> getParameterMap() {\n        HashMap<String, String[]> map = new HashMap<>();\n        parameters.entrySet().forEach(entry -> {\n            map.put(entry.getKey(), entry.getValue().toArray(new String[0]));\n        });\n        return map;\n    }\n\n    @Override\n    public String getRemoteAddr() {\n        return getChannel().remoteAddress().getHostString();\n    }\n\n    @Override\n    public String getRemoteHost() {\n        return getRemoteAddr() + \":\" + getRemotePort();\n    }\n\n    @Override\n    public int getRemotePort() {\n        return getChannel().remoteAddress().getPort();\n    }\n\n    @Override\n    public String getLocalAddr() {\n        return getChannel().localAddress().getHostString();\n    }\n\n    @Override\n    public String getLocalHost() {\n        return getRemoteAddr() + \":\" + getLocalPort();\n    }\n\n    private NioSocketChannel getChannel() {\n        return (NioSocketChannel) context.channel();\n    }\n\n    @Override\n    public int getLocalPort() {\n        return getChannel().localAddress().getPort();\n    }\n\n    @Override\n    public byte[] getInputStream() throws IOException {\n\n        return body;\n    }\n\n    protected void parseBody() {\n        ByteBuf byteBuf = ((HttpContent) request).content();\n\n        if (byteBuf.readableBytes() > 0) {\n\n            try {\n                body = IOUtils.toByteArray(new ByteBufInputStream(byteBuf));\n            } catch (IOException e) {\n\n            }\n        }\n    }\n\n    public ChannelHandlerContext getNettyChannelContext() {\n        return context;\n    }\n}\n",
        "methodName": null,
        "exampleID": 260,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/request/NettyRequestFacade.java",
        "line": 131,
        "sink": "io.netty.handler.codec.http.HttpRequest.method",
        "source": "-",
        "sourceLine": 131,
        "qualifier": "Call to io.netty.handler.codec.http.HttpRequest.method with untrusted data from [request : FullHttpRequest](1).",
        "line_number": 131,
        "steps": [
            {
                "line": 58,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "methodName": null,
                "exampleID": 261
            },
            {
                "line": 58,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "methodName": null,
                "exampleID": 261
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/util/NumberUtils.java#L83",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.rest.util;\n\nimport org.apache.dubbo.common.utils.Assert;\nimport org.apache.dubbo.common.utils.StringUtils;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\npublic class NumberUtils {\n\n    public static <T> T parseNumber(String text, Class<T> targetClass) {\n        Assert.notNull(text, \"Text must not be null\");\n        Assert.notNull(targetClass, \"Target class must not be null\");\n        String trimmed = trimAllWhitespace(text);\n\n        if (Byte.class == targetClass || byte.class == targetClass) {\n            return (T) (isHexNumber(trimmed) ? Byte.decode(trimmed) : Byte.valueOf(trimmed));\n        } else if (Short.class == targetClass || short.class == targetClass) {\n            return (T) (isHexNumber(trimmed) ? Short.decode(trimmed) : Short.valueOf(trimmed));\n        } else if (Integer.class == targetClass || int.class == targetClass) {\n            return (T) (isHexNumber(trimmed) ? Integer.decode(trimmed) : Integer.valueOf(trimmed));\n        } else if (Long.class == targetClass || long.class == targetClass) {\n            return (T) (isHexNumber(trimmed) ? Long.decode(trimmed) : Long.valueOf(trimmed));\n        } else if (BigInteger.class == targetClass) {\n            return (T) (isHexNumber(trimmed) ? decodeBigInteger(trimmed) : new BigInteger(trimmed));\n        } else if (Float.class == targetClass || float.class == targetClass) {\n            return (T) Float.valueOf(trimmed);\n        } else if (Double.class == targetClass || double.class == targetClass) {\n            return (T) Double.valueOf(trimmed);\n        } else if (BigDecimal.class == targetClass || Number.class == targetClass) {\n            return (T) new BigDecimal(trimmed);\n        } else {\n            throw new IllegalArgumentException(\n                    \"Cannot convert String [\" + text + \"] to target class [\" + targetClass.getName() + \"]\");\n        }\n    }\n\n    private static boolean isHexNumber(String value) {\n        int index = (value.startsWith(\"-\") ? 1 : 0);\n        return (value.startsWith(\"0x\", index) || value.startsWith(\"0X\", index) || value.startsWith(\"#\", index));\n    }\n\n    private static BigInteger decodeBigInteger(String value) {\n        int radix = 10;\n        int index = 0;\n        boolean negative = false;\n\n        // Handle minus sign, if present.\n        if (value.startsWith(\"-\")) {\n            negative = true;\n            index++;\n        }\n\n        // Handle radix specifier, if present.\n        if (value.startsWith(\"0x\", index) || value.startsWith(\"0X\", index)) {\n            index += 2;\n            radix = 16;\n        } else if (value.startsWith(\"#\", index)) {\n            index++;\n            radix = 16;\n        } else if (value.startsWith(\"0\", index) && value.length() > 1 + index) {\n            index++;\n            radix = 8;\n        }\n\n        BigInteger result = new BigInteger(value.substring(index), radix);\n        return (negative ? result.negate() : result);\n    }\n\n    public static String trimAllWhitespace(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n\n        int len = str.length();\n        StringBuilder sb = new StringBuilder(str.length());\n        for (int i = 0; i < len; i++) {\n            char c = str.charAt(i);\n            if (!Character.isWhitespace(c)) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static Object numberToBytes(Number number) {\n\n        if (number instanceof Byte) {\n            // Use default encoding.\n            return Byte.toString(number.byteValue()).getBytes();\n        } else if (number instanceof Double) {\n            return Double.toString(number.doubleValue()).getBytes();\n        } else if (number instanceof Float) {\n            return Float.toString(number.floatValue()).getBytes();\n        } else if (number instanceof Integer) {\n            return Float.toString(number.intValue()).getBytes();\n        } else if (number instanceof Long) {\n            return Long.toString(number.longValue()).getBytes();\n        } else if (number instanceof Short) {\n            return Short.toString(number.shortValue()).getBytes();\n        } else if (number instanceof BigDecimal) {\n            return BigDecimal.class.cast(number).toString().getBytes();\n        }\n\n        return number;\n    }\n}\n",
        "methodName": null,
        "exampleID": 262,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/util/NumberUtils.java",
        "line": 83,
        "sink": "java.math.BigInteger.negate",
        "source": "-",
        "sourceLine": 83,
        "qualifier": "Call to java.math.BigInteger.negate with untrusted data from [request : FullHttpRequest](1).",
        "line_number": 83,
        "steps": [
            {
                "line": 58,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "methodName": null,
                "exampleID": 263
            },
            {
                "line": 58,
                "source": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "filepath": "dubbo-rpc/dubbo-rpc-rest/src/main/java/org/apache/dubbo/rpc/protocol/rest/netty/RestHttpRequestDecoder.java",
                "methodName": null,
                "exampleID": 263
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/TriRpcStatus.java#L163",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc;\n\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.remoting.TimeoutException;\n\nimport java.io.Serializable;\n\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.QueryStringDecoder;\nimport io.netty.handler.codec.http.QueryStringEncoder;\n\nimport static org.apache.dubbo.rpc.RpcException.FORBIDDEN_EXCEPTION;\nimport static org.apache.dubbo.rpc.RpcException.LIMIT_EXCEEDED_EXCEPTION;\nimport static org.apache.dubbo.rpc.RpcException.METHOD_NOT_FOUND;\nimport static org.apache.dubbo.rpc.RpcException.NETWORK_EXCEPTION;\nimport static org.apache.dubbo.rpc.RpcException.SERIALIZATION_EXCEPTION;\nimport static org.apache.dubbo.rpc.RpcException.TIMEOUT_EXCEPTION;\nimport static org.apache.dubbo.rpc.RpcException.TIMEOUT_TERMINATE;\nimport static org.apache.dubbo.rpc.RpcException.UNKNOWN_EXCEPTION;\n\n/**\n * See https://github.com/grpc/grpc/blob/master/doc/statuscodes.md\n */\npublic class TriRpcStatus implements Serializable {\n\n    public static final TriRpcStatus OK = fromCode(Code.OK);\n    public static final TriRpcStatus UNKNOWN = fromCode(Code.UNKNOWN);\n    public static final TriRpcStatus INTERNAL = fromCode(Code.INTERNAL);\n    public static final TriRpcStatus NOT_FOUND = fromCode(Code.NOT_FOUND);\n    public static final TriRpcStatus CANCELLED = fromCode(Code.CANCELLED);\n    public static final TriRpcStatus UNAVAILABLE = fromCode(Code.UNAVAILABLE);\n    public static final TriRpcStatus UNIMPLEMENTED = fromCode(Code.UNIMPLEMENTED);\n    public static final TriRpcStatus DEADLINE_EXCEEDED = fromCode(Code.DEADLINE_EXCEEDED);\n\n    public final Code code;\n    public final Throwable cause;\n    public final String description;\n\n    public TriRpcStatus(Code code, Throwable cause, String description) {\n        this.code = code;\n        this.cause = cause;\n        this.description = description;\n    }\n\n    public static TriRpcStatus fromCode(int code) {\n        return fromCode(Code.fromCode(code));\n    }\n\n    public static TriRpcStatus fromCode(Code code) {\n        return new TriRpcStatus(code, null, null);\n    }\n\n    /**\n     * todo The remaining exceptions are converted to status\n     */\n    public static TriRpcStatus getStatus(Throwable throwable) {\n        return getStatus(throwable, null);\n    }\n\n    public static TriRpcStatus getStatus(Throwable throwable, String description) {\n        if (throwable instanceof StatusRpcException) {\n            return ((StatusRpcException) throwable).getStatus();\n        }\n        if (throwable instanceof RpcException) {\n            RpcException rpcException = (RpcException) throwable;\n            Code code = dubboCodeToTriCode(rpcException.getCode());\n            return new TriRpcStatus(code, throwable, description);\n        }\n        if (throwable instanceof TimeoutException) {\n            return new TriRpcStatus(Code.DEADLINE_EXCEEDED, throwable, description);\n        }\n        return new TriRpcStatus(Code.UNKNOWN, throwable, description);\n    }\n\n    public static int triCodeToDubboCode(Code triCode) {\n        int code;\n        switch (triCode) {\n            case DEADLINE_EXCEEDED:\n                code = TIMEOUT_EXCEPTION;\n                break;\n            case PERMISSION_DENIED:\n                code = FORBIDDEN_EXCEPTION;\n                break;\n            case UNAVAILABLE:\n                code = NETWORK_EXCEPTION;\n                break;\n            case UNIMPLEMENTED:\n                code = METHOD_NOT_FOUND;\n                break;\n            default:\n                code = UNKNOWN_EXCEPTION;\n        }\n        return code;\n    }\n\n    public static Code dubboCodeToTriCode(int rpcExceptionCode) {\n        Code code;\n        switch (rpcExceptionCode) {\n            case TIMEOUT_EXCEPTION:\n            case TIMEOUT_TERMINATE:\n                code = Code.DEADLINE_EXCEEDED;\n                break;\n            case FORBIDDEN_EXCEPTION:\n                code = Code.PERMISSION_DENIED;\n                break;\n            case LIMIT_EXCEEDED_EXCEPTION:\n            case NETWORK_EXCEPTION:\n                code = Code.UNAVAILABLE;\n                break;\n            case METHOD_NOT_FOUND:\n                code = Code.NOT_FOUND;\n                break;\n            case SERIALIZATION_EXCEPTION:\n                code = Code.INTERNAL;\n                break;\n            default:\n                code = Code.UNKNOWN;\n                break;\n        }\n        return code;\n    }\n\n    public static String limitSizeTo1KB(String desc) {\n        if (desc.length() < 1024) {\n            return desc;\n        } else {\n            return desc.substring(0, 1024);\n        }\n    }\n\n    public static String decodeMessage(String raw) {\n        if (StringUtils.isEmpty(raw)) {\n            return \"\";\n        }\n        return QueryStringDecoder.decodeComponent(raw);\n    }\n\n    public static String encodeMessage(String raw) {\n        if (StringUtils.isEmpty(raw)) {\n            return \"\";\n        }\n        return encodeComponent(raw);\n    }\n\n    private static String encodeComponent(String raw) {\n        QueryStringEncoder encoder = new QueryStringEncoder(\"\");\n        encoder.addParam(\"\", raw);\n        // ?=\n        return encoder.toString().substring(2);\n    }\n\n    public static Code httpStatusToGrpcCode(int httpStatusCode) {\n        if (httpStatusCode >= 100 && httpStatusCode < 200) {\n            return Code.INTERNAL;\n        }\n        if (httpStatusCode == HttpResponseStatus.BAD_REQUEST.code()\n                || httpStatusCode == HttpResponseStatus.REQUEST_HEADER_FIELDS_TOO_LARGE.code()) {\n            return Code.INTERNAL;\n        } else if (httpStatusCode == HttpResponseStatus.UNAUTHORIZED.code()) {\n            return Code.UNAUTHENTICATED;\n        } else if (httpStatusCode == HttpResponseStatus.FORBIDDEN.code()) {\n            return Code.PERMISSION_DENIED;\n        } else if (httpStatusCode == HttpResponseStatus.NOT_FOUND.code()) {\n            return Code.UNIMPLEMENTED;\n        } else if (httpStatusCode == HttpResponseStatus.BAD_GATEWAY.code()\n                || httpStatusCode == HttpResponseStatus.TOO_MANY_REQUESTS.code()\n                || httpStatusCode == HttpResponseStatus.SERVICE_UNAVAILABLE.code()\n                || httpStatusCode == HttpResponseStatus.GATEWAY_TIMEOUT.code()) {\n            return Code.UNAVAILABLE;\n        } else {\n            return Code.UNKNOWN;\n        }\n    }\n\n    public boolean isOk() {\n        return Code.isOk(code.code);\n    }\n\n    public TriRpcStatus withCause(Throwable cause) {\n        return new TriRpcStatus(this.code, cause, this.description);\n    }\n\n    public TriRpcStatus withDescription(String description) {\n        return new TriRpcStatus(code, cause, description);\n    }\n\n    public TriRpcStatus appendDescription(String description) {\n        if (this.description == null) {\n            return withDescription(description);\n        } else {\n            String newDescription = this.description + \"\\n\" + description;\n            return withDescription(newDescription);\n        }\n    }\n\n    public StatusRpcException asException() {\n        return new StatusRpcException(this);\n    }\n\n    public String toEncodedMessage() {\n        String output = limitSizeTo1KB(toMessage());\n        return encodeComponent(output);\n    }\n\n    public String toMessageWithoutCause() {\n        if (description != null) {\n            return String.format(\"%s : %s\", code, description);\n        } else {\n            return code.toString();\n        }\n    }\n\n    public String toMessage() {\n        String msg = \"\";\n        if (cause == null) {\n            msg += description;\n        } else {\n            String placeHolder = description == null ? \"\" : description;\n            msg += StringUtils.toString(placeHolder, cause);\n        }\n        return msg;\n    }\n\n    public enum Code {\n        OK(0),\n        CANCELLED(1),\n        UNKNOWN(2),\n        INVALID_ARGUMENT(3),\n        DEADLINE_EXCEEDED(4),\n        NOT_FOUND(5),\n        ALREADY_EXISTS(6),\n        PERMISSION_DENIED(7),\n        RESOURCE_EXHAUSTED(8),\n        FAILED_PRECONDITION(9),\n        ABORTED(10),\n        OUT_OF_RANGE(11),\n        UNIMPLEMENTED(12),\n        INTERNAL(13),\n        UNAVAILABLE(14),\n        DATA_LOSS(15),\n        /**\n         * The request does not have valid authentication credentials for the operation.\n         */\n        UNAUTHENTICATED(16);\n\n        public final int code;\n\n        Code(int code) {\n            this.code = code;\n        }\n\n        public static boolean isOk(Integer status) {\n            return status == OK.code;\n        }\n\n        public static Code fromCode(int code) {\n            for (Code value : Code.values()) {\n                if (value.code == code) {\n                    return value;\n                }\n            }\n            throw new IllegalStateException(\"Can not find status for code: \" + code);\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 264,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/TriRpcStatus.java",
        "line": 163,
        "sink": "io.netty.handler.codec.http.QueryStringEncoder.addParam",
        "source": "-",
        "sourceLine": 163,
        "qualifier": "Call to io.netty.handler.codec.http.QueryStringEncoder.addParam with untrusted data from [msg : Http2StreamFrame](1).\nCall to io.netty.handler.codec.http.QueryStringEncoder.addParam with untrusted data from [msg : Object](2).",
        "line_number": 163,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 265
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 265
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 265
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 265
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/PbArrayPacker.java#L25",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri;\n\nimport org.apache.dubbo.rpc.model.Pack;\n\nimport com.google.protobuf.Message;\n\npublic class PbArrayPacker implements Pack {\n\n    private static final Pack PB_PACK = o -> ((Message) o).toByteArray();\n\n    private final boolean singleArgument;\n\n    public PbArrayPacker(boolean singleArgument) {\n        this.singleArgument = singleArgument;\n    }\n\n    @Override\n    public byte[] pack(Object obj) throws Exception {\n        if (!singleArgument) {\n            obj = ((Object[]) obj)[0];\n        }\n        return PB_PACK.pack(obj);\n    }\n}\n",
        "methodName": null,
        "exampleID": 266,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/PbArrayPacker.java",
        "line": 25,
        "sink": "com.google.protobuf.MessageLite.toByteArray",
        "source": "-",
        "sourceLine": 25,
        "qualifier": "Call to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Http2StreamFrame](1).\nCall to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Object](2).",
        "line_number": 25,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 267
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 267
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 267
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 267
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java#L53",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.serialize.MultipleSerialization;\nimport org.apache.dubbo.common.stream.StreamObserver;\nimport org.apache.dubbo.config.Constants;\nimport org.apache.dubbo.remoting.transport.CodecSupport;\nimport org.apache.dubbo.remoting.utils.UrlUtils;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.Pack;\nimport org.apache.dubbo.rpc.model.PackableMethod;\nimport org.apache.dubbo.rpc.model.UnPack;\nimport org.apache.dubbo.rpc.model.WrapperUnPack;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.stream.Stream;\n\nimport com.google.protobuf.Message;\n\nimport static org.apache.dubbo.common.constants.CommonConstants.$ECHO;\nimport static org.apache.dubbo.common.utils.ProtobufUtils.isProtobufClass;\n\npublic class ReflectionPackableMethod implements PackableMethod {\n\n    private static final String GRPC_ASYNC_RETURN_CLASS = \"com.google.common.util.concurrent.ListenableFuture\";\n    private static final String TRI_ASYNC_RETURN_CLASS = \"java.util.concurrent.CompletableFuture\";\n    private static final String REACTOR_RETURN_CLASS = \"reactor.core.publisher.Mono\";\n    private static final String RX_RETURN_CLASS = \"io.reactivex.Single\";\n    private static final String GRPC_STREAM_CLASS = \"io.grpc.stub.StreamObserver\";\n    private static final Pack PB_PACK = o -> ((Message) o).toByteArray();\n\n    private final Pack requestPack;\n    private final Pack responsePack;\n    private final UnPack requestUnpack;\n    private final UnPack responseUnpack;\n\n    private final boolean needWrapper;\n\n    private final Collection<String> allSerialize;\n\n    @Override\n    public boolean needWrapper() {\n        return this.needWrapper;\n    }\n\n    public ReflectionPackableMethod(\n            MethodDescriptor method, URL url, String serializeName, Collection<String> allSerialize) {\n        Class<?>[] actualRequestTypes;\n        Class<?> actualResponseType;\n        switch (method.getRpcType()) {\n            case CLIENT_STREAM:\n            case BI_STREAM:\n                actualRequestTypes = new Class<?>[] {\n                    obtainActualTypeInStreamObserver(\n                            ((ParameterizedType) method.getMethod().getGenericReturnType()).getActualTypeArguments()[0])\n                };\n                actualResponseType = obtainActualTypeInStreamObserver(\n                        ((ParameterizedType) method.getMethod().getGenericParameterTypes()[0])\n                                .getActualTypeArguments()[0]);\n                break;\n            case SERVER_STREAM:\n                actualRequestTypes = method.getMethod().getParameterTypes();\n                actualResponseType = obtainActualTypeInStreamObserver(\n                        ((ParameterizedType) method.getMethod().getGenericParameterTypes()[1])\n                                .getActualTypeArguments()[0]);\n                break;\n            case UNARY:\n                actualRequestTypes = method.getParameterClasses();\n                actualResponseType = (Class<?>) method.getReturnTypes()[0];\n                break;\n            default:\n                throw new IllegalStateException(\"Can not reach here\");\n        }\n\n        boolean singleArgument = method.getRpcType() != MethodDescriptor.RpcType.UNARY;\n        this.needWrapper = needWrap(method, actualRequestTypes, actualResponseType);\n        if (!needWrapper) {\n            requestPack = new PbArrayPacker(singleArgument);\n            responsePack = PB_PACK;\n            requestUnpack = new PbUnpack<>(actualRequestTypes[0]);\n            responseUnpack = new PbUnpack<>(actualResponseType);\n        } else {\n            final MultipleSerialization serialization = url.getOrDefaultFrameworkModel()\n                    .getExtensionLoader(MultipleSerialization.class)\n                    .getExtension(url.getParameter(Constants.MULTI_SERIALIZATION_KEY, CommonConstants.DEFAULT_KEY));\n\n            // client\n            this.requestPack =\n                    new WrapRequestPack(serialization, url, serializeName, actualRequestTypes, singleArgument);\n            this.responseUnpack = new WrapResponseUnpack(serialization, url, allSerialize, actualResponseType);\n\n            // server\n            this.responsePack = new WrapResponsePack(serialization, url, serializeName, actualResponseType);\n            this.requestUnpack = new WrapRequestUnpack(serialization, url, allSerialize, actualRequestTypes);\n        }\n        this.allSerialize = allSerialize;\n    }\n\n    public static ReflectionPackableMethod init(MethodDescriptor methodDescriptor, URL url) {\n        String serializeName = UrlUtils.serializationOrDefault(url);\n        Collection<String> allSerialize = UrlUtils.allSerializations(url);\n        return new ReflectionPackableMethod(methodDescriptor, url, serializeName, allSerialize);\n    }\n\n    static boolean isStreamType(Class<?> type) {\n        return StreamObserver.class.isAssignableFrom(type) || GRPC_STREAM_CLASS.equalsIgnoreCase(type.getName());\n    }\n\n    /**\n     * Determine if the request and response instance should be wrapped in Protobuf wrapper object\n     *\n     * @return true if the request and response object is not generated by protobuf\n     */\n    static boolean needWrap(MethodDescriptor methodDescriptor, Class<?>[] parameterClasses, Class<?> returnClass) {\n        String methodName = methodDescriptor.getMethodName();\n        // generic call must be wrapped\n        if (CommonConstants.$INVOKE.equals(methodName) || CommonConstants.$INVOKE_ASYNC.equals(methodName)) {\n            return true;\n        }\n        // echo must be wrapped\n        if ($ECHO.equals(methodName)) {\n            return true;\n        }\n        boolean returnClassProtobuf = isProtobufClass(returnClass);\n        // Response foo()\n        if (parameterClasses.length == 0) {\n            return !returnClassProtobuf;\n        }\n        int protobufParameterCount = 0;\n        int javaParameterCount = 0;\n        int streamParameterCount = 0;\n        boolean secondParameterStream = false;\n        // count normal and protobuf param\n        for (int i = 0; i < parameterClasses.length; i++) {\n            Class<?> parameterClass = parameterClasses[i];\n            if (isProtobufClass(parameterClass)) {\n                protobufParameterCount++;\n            } else {\n                if (isStreamType(parameterClass)) {\n                    if (i == 1) {\n                        secondParameterStream = true;\n                    }\n                    streamParameterCount++;\n                } else {\n                    javaParameterCount++;\n                }\n            }\n        }\n        // more than one stream param\n        if (streamParameterCount > 1) {\n            throw new IllegalStateException(\"method params error: more than one Stream params. method=\" + methodName);\n        }\n        // protobuf only support one param\n        if (protobufParameterCount >= 2) {\n            throw new IllegalStateException(\"method params error: more than one protobuf params. method=\" + methodName);\n        }\n        // server stream support one normal param and one stream param\n        if (streamParameterCount == 1) {\n            if (javaParameterCount + protobufParameterCount > 1) {\n                throw new IllegalStateException(\n                        \"method params error: server stream does not support more than one normal param.\" + \" method=\"\n                                + methodName);\n            }\n            // server stream: void foo(Request, StreamObserver<Response>)\n            if (!secondParameterStream) {\n                throw new IllegalStateException(\n                        \"method params error: server stream's second param must be StreamObserver.\" + \" method=\"\n                                + methodName);\n            }\n        }\n        if (methodDescriptor.getRpcType() != MethodDescriptor.RpcType.UNARY) {\n            if (MethodDescriptor.RpcType.SERVER_STREAM == methodDescriptor.getRpcType()) {\n                if (!secondParameterStream) {\n                    throw new IllegalStateException(\n                            \"method params error:server stream's second param must be StreamObserver.\" + \" method=\"\n                                    + methodName);\n                }\n            }\n            // param type must be consistent\n            if (returnClassProtobuf) {\n                if (javaParameterCount > 0) {\n                    throw new IllegalStateException(\n                            \"method params error: both normal and protobuf param found. method=\" + methodName);\n                }\n            } else {\n                if (protobufParameterCount > 0) {\n                    throw new IllegalStateException(\"method params error method=\" + methodName);\n                }\n            }\n        } else {\n            if (streamParameterCount > 0) {\n                throw new IllegalStateException(\n                        \"method params error: unary method should not contain any StreamObserver.\" + \" method=\"\n                                + methodName);\n            }\n            if (protobufParameterCount > 0 && returnClassProtobuf) {\n                return false;\n            }\n            // handler reactor or rxjava only consider gen by proto\n            if (isMono(returnClass) || isRx(returnClass)) {\n                return false;\n            }\n            if (protobufParameterCount <= 0 && !returnClassProtobuf) {\n                return true;\n            }\n            // handle grpc stub only consider gen by proto\n            if (GRPC_ASYNC_RETURN_CLASS.equalsIgnoreCase(returnClass.getName()) && protobufParameterCount == 1) {\n                return false;\n            }\n            // handle dubbo generated method\n            if (TRI_ASYNC_RETURN_CLASS.equalsIgnoreCase(returnClass.getName())) {\n                Class<?> actualReturnClass = (Class<?>)\n                        ((ParameterizedType) methodDescriptor.getMethod().getGenericReturnType())\n                                .getActualTypeArguments()[0];\n                boolean actualReturnClassProtobuf = isProtobufClass(actualReturnClass);\n                if (actualReturnClassProtobuf && protobufParameterCount == 1) {\n                    return false;\n                }\n                if (!actualReturnClassProtobuf && protobufParameterCount == 0) {\n                    return true;\n                }\n            }\n            // todo remove this in future\n            boolean ignore = checkNeedIgnore(returnClass);\n            if (ignore) {\n                return protobufParameterCount != 1;\n            }\n            throw new IllegalStateException(\"method params error method=\" + methodName);\n        }\n        // java param should be wrapped\n        return javaParameterCount > 0;\n    }\n\n    /**\n     * fixme will produce error on grpc. but is harmless so ignore now\n     */\n    static boolean checkNeedIgnore(Class<?> returnClass) {\n        return Iterator.class.isAssignableFrom(returnClass);\n    }\n\n    static boolean isMono(Class<?> clz) {\n        return REACTOR_RETURN_CLASS.equalsIgnoreCase(clz.getName());\n    }\n\n    static boolean isRx(Class<?> clz) {\n        return RX_RETURN_CLASS.equalsIgnoreCase(clz.getName());\n    }\n\n    private static String convertHessianFromWrapper(String serializeType) {\n        if (TripleConstant.HESSIAN4.equals(serializeType)) {\n            return TripleConstant.HESSIAN2;\n        }\n        return serializeType;\n    }\n\n    static Class<?> obtainActualTypeInStreamObserver(Type typeInStreamObserver) {\n        return (Class<?>)\n                (typeInStreamObserver instanceof ParameterizedType\n                        ? ((ParameterizedType) typeInStreamObserver).getRawType()\n                        : typeInStreamObserver);\n    }\n\n    @Override\n    public Pack getRequestPack() {\n        return requestPack;\n    }\n\n    @Override\n    public Pack getResponsePack() {\n        return responsePack;\n    }\n\n    @Override\n    public UnPack getResponseUnpack() {\n        return responseUnpack;\n    }\n\n    @Override\n    public UnPack getRequestUnpack() {\n        return requestUnpack;\n    }\n\n    private static class WrapResponsePack implements Pack {\n\n        private final MultipleSerialization multipleSerialization;\n        private final URL url;\n\n        private final Class<?> actualResponseType;\n        // wrapper request set serialize type\n        String requestSerialize;\n\n        private WrapResponsePack(\n                MultipleSerialization multipleSerialization,\n                URL url,\n                String defaultSerialize,\n                Class<?> actualResponseType) {\n            this.multipleSerialization = multipleSerialization;\n            this.url = url;\n            this.actualResponseType = actualResponseType;\n            this.requestSerialize = defaultSerialize;\n        }\n\n        @Override\n        public byte[] pack(Object obj) throws IOException {\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            multipleSerialization.serialize(url, requestSerialize, actualResponseType, obj, bos);\n            return TripleCustomerProtocolWapper.TripleResponseWrapper.Builder.newBuilder()\n                    .setSerializeType(requestSerialize)\n                    .setType(actualResponseType.getName())\n                    .setData(bos.toByteArray())\n                    .build()\n                    .toByteArray();\n        }\n    }\n\n    private static class WrapResponseUnpack implements WrapperUnPack {\n\n        private final MultipleSerialization serialization;\n        private final URL url;\n        private final Class<?> returnClass;\n\n        private final Collection<String> allSerialize;\n\n        private WrapResponseUnpack(\n                MultipleSerialization serialization, URL url, Collection<String> allSerialize, Class<?> returnClass) {\n            this.serialization = serialization;\n            this.url = url;\n            this.returnClass = returnClass;\n            this.allSerialize = allSerialize;\n        }\n\n        @Override\n        public Object unpack(byte[] data) throws IOException, ClassNotFoundException {\n            return unpack(data, false);\n        }\n\n        public Object unpack(byte[] data, boolean isReturnTriException) throws IOException, ClassNotFoundException {\n            TripleCustomerProtocolWapper.TripleResponseWrapper wrapper =\n                    TripleCustomerProtocolWapper.TripleResponseWrapper.parseFrom(data);\n            final String serializeType = convertHessianFromWrapper(wrapper.getSerializeType());\n\n            CodecSupport.checkSerialization(serializeType, allSerialize);\n\n            ByteArrayInputStream bais = new ByteArrayInputStream(wrapper.getData());\n            if (isReturnTriException) {\n                return serialization.deserialize(url, serializeType, Exception.class, bais);\n            }\n            return serialization.deserialize(url, serializeType, returnClass, bais);\n        }\n    }\n\n    private static class WrapRequestPack implements Pack {\n\n        private final String serialize;\n        private final MultipleSerialization multipleSerialization;\n        private final String[] argumentsType;\n        private final Class<?>[] actualRequestTypes;\n        private final URL url;\n        private final boolean singleArgument;\n\n        private WrapRequestPack(\n                MultipleSerialization multipleSerialization,\n                URL url,\n                String serialize,\n                Class<?>[] actualRequestTypes,\n                boolean singleArgument) {\n            this.url = url;\n            this.serialize = convertHessianToWrapper(serialize);\n            this.multipleSerialization = multipleSerialization;\n            this.actualRequestTypes = actualRequestTypes;\n            this.argumentsType =\n                    Stream.of(actualRequestTypes).map(Class::getName).toArray(String[]::new);\n            this.singleArgument = singleArgument;\n        }\n\n        @Override\n        public byte[] pack(Object obj) throws IOException {\n            Object[] arguments;\n            if (singleArgument) {\n                arguments = new Object[] {obj};\n            } else {\n                arguments = (Object[]) obj;\n            }\n            final TripleCustomerProtocolWapper.TripleRequestWrapper.Builder builder =\n                    TripleCustomerProtocolWapper.TripleRequestWrapper.Builder.newBuilder();\n            builder.setSerializeType(serialize);\n            for (String type : argumentsType) {\n                builder.addArgTypes(type);\n            }\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n            for (int i = 0; i < arguments.length; i++) {\n                Object argument = arguments[i];\n                multipleSerialization.serialize(url, serialize, actualRequestTypes[i], argument, bos);\n                builder.addArgs(bos.toByteArray());\n                bos.reset();\n            }\n            return builder.build().toByteArray();\n        }\n\n        /**\n         * Convert hessian version from Dubbo's SPI version(hessian2) to wrapper API version\n         * (hessian4)\n         *\n         * @param serializeType literal type\n         * @return hessian4 if the param is hessian2, otherwise return the param\n         */\n        private String convertHessianToWrapper(String serializeType) {\n            if (TripleConstant.HESSIAN2.equals(serializeType)) {\n                return TripleConstant.HESSIAN4;\n            }\n            return serializeType;\n        }\n    }\n\n    private class WrapRequestUnpack implements WrapperUnPack {\n\n        private final MultipleSerialization serialization;\n        private final URL url;\n\n        private final Class<?>[] actualRequestTypes;\n\n        private final Collection<String> allSerialize;\n\n        private WrapRequestUnpack(\n                MultipleSerialization serialization,\n                URL url,\n                Collection<String> allSerialize,\n                Class<?>[] actualRequestTypes) {\n            this.serialization = serialization;\n            this.url = url;\n            this.actualRequestTypes = actualRequestTypes;\n            this.allSerialize = allSerialize;\n        }\n\n        public Object unpack(byte[] data, boolean isReturnTriException) throws IOException, ClassNotFoundException {\n            TripleCustomerProtocolWapper.TripleRequestWrapper wrapper =\n                    TripleCustomerProtocolWapper.TripleRequestWrapper.parseFrom(data);\n\n            String wrapperSerializeType = convertHessianFromWrapper(wrapper.getSerializeType());\n            CodecSupport.checkSerialization(wrapperSerializeType, allSerialize);\n\n            Object[] ret = new Object[wrapper.getArgs().size()];\n            ((WrapResponsePack) responsePack).requestSerialize = wrapper.getSerializeType();\n            for (int i = 0; i < wrapper.getArgs().size(); i++) {\n                ByteArrayInputStream bais =\n                        new ByteArrayInputStream(wrapper.getArgs().get(i));\n                ret[i] = serialization.deserialize(url, wrapper.getSerializeType(), actualRequestTypes[i], bais);\n            }\n            return ret;\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 268,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/ReflectionPackableMethod.java",
        "line": 53,
        "sink": "com.google.protobuf.MessageLite.toByteArray",
        "source": "-",
        "sourceLine": 53,
        "qualifier": "Call to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Http2StreamFrame](1).\nCall to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Object](2).",
        "line_number": 53,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 269
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 269
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 269
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 269
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/SingleProtobufUtils.java#L102",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri;\n\nimport org.apache.dubbo.common.utils.ConcurrentHashMapUtils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport com.google.protobuf.BoolValue;\nimport com.google.protobuf.BytesValue;\nimport com.google.protobuf.DoubleValue;\nimport com.google.protobuf.Empty;\nimport com.google.protobuf.EnumValue;\nimport com.google.protobuf.ExtensionRegistryLite;\nimport com.google.protobuf.FloatValue;\nimport com.google.protobuf.Int32Value;\nimport com.google.protobuf.Int64Value;\nimport com.google.protobuf.InvalidProtocolBufferException;\nimport com.google.protobuf.ListValue;\nimport com.google.protobuf.Message;\nimport com.google.protobuf.MessageLite;\nimport com.google.protobuf.Parser;\nimport com.google.protobuf.StringValue;\n\npublic class SingleProtobufUtils {\n    private static final ConcurrentHashMap<Class<?>, Message> INST_CACHE = new ConcurrentHashMap<>();\n    private static final ExtensionRegistryLite GLOBAL_REGISTRY = ExtensionRegistryLite.getEmptyRegistry();\n    private static final ConcurrentMap<Class<?>, SingleMessageMarshaller<?>> MARSHALLER_CACHE =\n            new ConcurrentHashMap<>();\n\n    static {\n        // Built-in types need to be registered in advance\n        marshaller(Empty.getDefaultInstance());\n        marshaller(BoolValue.getDefaultInstance());\n        marshaller(Int32Value.getDefaultInstance());\n        marshaller(Int64Value.getDefaultInstance());\n        marshaller(FloatValue.getDefaultInstance());\n        marshaller(DoubleValue.getDefaultInstance());\n        marshaller(BytesValue.getDefaultInstance());\n        marshaller(StringValue.getDefaultInstance());\n        marshaller(EnumValue.getDefaultInstance());\n        marshaller(ListValue.getDefaultInstance());\n    }\n\n    static boolean isSupported(Class<?> clazz) {\n        if (clazz == null) {\n            return false;\n        }\n        return MessageLite.class.isAssignableFrom(clazz);\n    }\n\n    public static <T extends MessageLite> void marshaller(T defaultInstance) {\n        MARSHALLER_CACHE.put(defaultInstance.getClass(), new SingleMessageMarshaller<>(defaultInstance));\n    }\n\n    @SuppressWarnings(\"all\")\n    public static Message defaultInst(Class<?> clz) {\n        Message defaultInst = INST_CACHE.get(clz);\n        if (defaultInst != null) {\n            return defaultInst;\n        }\n        try {\n            defaultInst = (Message) clz.getMethod(\"getDefaultInstance\").invoke(null);\n        } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {\n            throw new RuntimeException(\"Create default protobuf instance failed \", e);\n        }\n        INST_CACHE.put(clz, defaultInst);\n        return defaultInst;\n    }\n\n    @SuppressWarnings(\"all\")\n    public static <T> Parser<T> getParser(Class<T> clz) {\n        Message defaultInst = defaultInst(clz);\n        return (Parser<T>) defaultInst.getParserForType();\n    }\n\n    public static <T> T deserialize(InputStream in, Class<T> clz) throws IOException {\n        if (!isSupported(clz)) {\n            throw new IllegalArgumentException(\"This serialization only support google protobuf messages, but the \"\n                    + \"actual input type is :\" + clz.getName());\n        }\n        try {\n            return (T) getMarshaller(clz).parse(in);\n        } catch (InvalidProtocolBufferException e) {\n            throw new IOException(e);\n        }\n    }\n\n    public static void serialize(Object obj, OutputStream os) throws IOException {\n        final MessageLite msg = (MessageLite) obj;\n        msg.writeTo(os);\n    }\n\n    private static SingleMessageMarshaller<?> getMarshaller(Class<?> clz) {\n        return ConcurrentHashMapUtils.computeIfAbsent(MARSHALLER_CACHE, clz, k -> new SingleMessageMarshaller(k));\n    }\n\n    public static final class SingleMessageMarshaller<T extends MessageLite> {\n        private final Parser<T> parser;\n        private final T defaultInstance;\n\n        SingleMessageMarshaller(Class<T> clz) {\n            this.defaultInstance = (T) defaultInst(clz);\n            this.parser = (Parser<T>) defaultInstance.getParserForType();\n        }\n\n        SingleMessageMarshaller(T defaultInstance) {\n            this.defaultInstance = defaultInstance;\n            this.parser = (Parser<T>) defaultInstance.getParserForType();\n        }\n\n        public T parse(InputStream stream) throws InvalidProtocolBufferException {\n            return parser.parseFrom(stream, GLOBAL_REGISTRY);\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 270,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/SingleProtobufUtils.java",
        "line": 102,
        "sink": "org.apache.dubbo.rpc.protocol.tri.SingleProtobufUtils$SingleMessageMarshaller<?>.parse",
        "source": "-",
        "sourceLine": 102,
        "qualifier": "Call to org.apache.dubbo.rpc.protocol.tri.SingleProtobufUtils$SingleMessageMarshaller<?>.parse with untrusted data from [msg : Http2StreamFrame](1).\nCall to org.apache.dubbo.rpc.protocol.tri.SingleProtobufUtils$SingleMessageMarshaller<?>.parse with untrusted data from [msg : Object](2).",
        "line_number": 102,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 271
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 271
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 271
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 271
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriplePathResolver.java#L41",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri;\n\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.PathResolver;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class TriplePathResolver implements PathResolver {\n\n    private final ConcurrentHashMap<String, Invoker<?>> path2Invoker = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<String, Object> nativeStub = new ConcurrentHashMap<>();\n\n    @Override\n    public Invoker<?> add(String path, Invoker<?> invoker) {\n        return path2Invoker.put(path, invoker);\n    }\n\n    @Override\n    public Invoker<?> addIfAbsent(String path, Invoker<?> invoker) {\n        return path2Invoker.putIfAbsent(path, invoker);\n    }\n\n    @Override\n    public Invoker<?> resolve(String path) {\n        return path2Invoker.get(path);\n    }\n\n    @Override\n    public boolean hasNativeStub(String path) {\n        return nativeStub.containsKey(path);\n    }\n\n    @Override\n    public void addNativeStub(String path) {\n        nativeStub.put(path, 0);\n    }\n\n    @Override\n    public void remove(String path) {\n        path2Invoker.remove(path);\n    }\n\n    @Override\n    public void destroy() {\n        path2Invoker.clear();\n    }\n}\n",
        "methodName": null,
        "exampleID": 272,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriplePathResolver.java",
        "line": 41,
        "sink": "java.util.concurrent.ConcurrentHashMap<String,Invoker<?>>.get",
        "source": "-",
        "sourceLine": 41,
        "qualifier": "Call to java.util.concurrent.ConcurrentHashMap<String,Invoker<?>>.get with untrusted data from [msg : Http2StreamFrame](1).\nCall to java.util.concurrent.ConcurrentHashMap<String,Invoker<?>>.get with untrusted data from [msg : Object](2).",
        "line_number": 41,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 273
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 273
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 273
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 273
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriplePathResolver.java#L46",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri;\n\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.PathResolver;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class TriplePathResolver implements PathResolver {\n\n    private final ConcurrentHashMap<String, Invoker<?>> path2Invoker = new ConcurrentHashMap<>();\n    private final ConcurrentHashMap<String, Object> nativeStub = new ConcurrentHashMap<>();\n\n    @Override\n    public Invoker<?> add(String path, Invoker<?> invoker) {\n        return path2Invoker.put(path, invoker);\n    }\n\n    @Override\n    public Invoker<?> addIfAbsent(String path, Invoker<?> invoker) {\n        return path2Invoker.putIfAbsent(path, invoker);\n    }\n\n    @Override\n    public Invoker<?> resolve(String path) {\n        return path2Invoker.get(path);\n    }\n\n    @Override\n    public boolean hasNativeStub(String path) {\n        return nativeStub.containsKey(path);\n    }\n\n    @Override\n    public void addNativeStub(String path) {\n        nativeStub.put(path, 0);\n    }\n\n    @Override\n    public void remove(String path) {\n        path2Invoker.remove(path);\n    }\n\n    @Override\n    public void destroy() {\n        path2Invoker.clear();\n    }\n}\n",
        "methodName": null,
        "exampleID": 274,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/TriplePathResolver.java",
        "line": 46,
        "sink": "java.util.concurrent.ConcurrentHashMap<String,Object>.containsKey",
        "source": "-",
        "sourceLine": 46,
        "qualifier": "Call to java.util.concurrent.ConcurrentHashMap<String,Object>.containsKey with untrusted data from [msg : Http2StreamFrame](1).\nCall to java.util.concurrent.ConcurrentHashMap<String,Object>.containsKey with untrusted data from [msg : Object](2).",
        "line_number": 46,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 275
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 275
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionAbstractServerCall.java#L109",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.call;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.config.ConfigurationUtils;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.utils.CollectionUtils;\nimport org.apache.dubbo.rpc.HeaderFilter;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.RpcInvocation;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.MethodDescriptor.RpcType;\nimport org.apache.dubbo.rpc.model.PackableMethod;\nimport org.apache.dubbo.rpc.model.PackableMethodFactory;\nimport org.apache.dubbo.rpc.model.ProviderModel;\nimport org.apache.dubbo.rpc.model.ServiceDescriptor;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.TripleCustomerProtocolWapper;\nimport org.apache.dubbo.rpc.protocol.tri.stream.ServerStream;\nimport org.apache.dubbo.rpc.service.ServiceDescriptorInternalCache;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.Executor;\n\nimport io.netty.handler.codec.http.HttpHeaderNames;\n\nimport static org.apache.dubbo.common.constants.CommonConstants.DEFAULT_KEY;\nimport static org.apache.dubbo.common.constants.CommonConstants.DUBBO_PACKABLE_METHOD_FACTORY;\n\npublic class ReflectionAbstractServerCall extends AbstractServerCall {\n\n    private static final String PACKABLE_METHOD_CACHE = \"PACKABLE_METHOD_CACHE\";\n    private final List<HeaderFilter> headerFilters;\n    private List<MethodDescriptor> methodDescriptors;\n\n    public ReflectionAbstractServerCall(\n            Invoker<?> invoker,\n            ServerStream serverStream,\n            FrameworkModel frameworkModel,\n            String acceptEncoding,\n            String serviceName,\n            String methodName,\n            List<HeaderFilter> headerFilters,\n            Executor executor) {\n        super(\n                invoker,\n                serverStream,\n                frameworkModel,\n                getServiceDescriptor(invoker.getUrl()),\n                acceptEncoding,\n                serviceName,\n                methodName,\n                executor);\n        this.headerFilters = headerFilters;\n    }\n\n    private static ServiceDescriptor getServiceDescriptor(URL url) {\n        ProviderModel providerModel = (ProviderModel) url.getServiceModel();\n        if (providerModel == null || providerModel.getServiceModel() == null) {\n            return null;\n        }\n        return providerModel.getServiceModel();\n    }\n\n    private boolean isEcho(String methodName) {\n        return CommonConstants.$ECHO.equals(methodName);\n    }\n\n    private boolean isGeneric(String methodName) {\n        return CommonConstants.$INVOKE.equals(methodName) || CommonConstants.$INVOKE_ASYNC.equals(methodName);\n    }\n\n    @Override\n    public void startCall() {\n        if (isGeneric(methodName)) {\n            // There should be one and only one\n            methodDescriptor = ServiceDescriptorInternalCache.genericService()\n                    .getMethods(methodName)\n                    .get(0);\n        } else if (isEcho(methodName)) {\n            // There should be one and only one\n            methodDescriptor = ServiceDescriptorInternalCache.echoService()\n                    .getMethods(methodName)\n                    .get(0);\n        } else {\n            methodDescriptors = serviceDescriptor.getMethods(methodName);\n            // try lower-case method\n            if (CollectionUtils.isEmpty(methodDescriptors)) {\n                final String lowerMethod = Character.toLowerCase(methodName.charAt(0)) + methodName.substring(1);\n                methodDescriptors = serviceDescriptor.getMethods(lowerMethod);\n            }\n            if (CollectionUtils.isEmpty(methodDescriptors)) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\n                        \"Method : \" + methodName + \" not found of service:\" + serviceName));\n                return;\n            }\n            // In most cases there is only one method\n            if (methodDescriptors.size() == 1) {\n                methodDescriptor = methodDescriptors.get(0);\n            }\n            // generated unary method ,use unary type\n            // Response foo(Request)\n            // void foo(Request,StreamObserver<Response>)\n            if (methodDescriptors.size() == 2) {\n                if (methodDescriptors.get(1).getRpcType() == RpcType.SERVER_STREAM) {\n                    methodDescriptor = methodDescriptors.get(0);\n                } else if (methodDescriptors.get(0).getRpcType() == RpcType.SERVER_STREAM) {\n                    methodDescriptor = methodDescriptors.get(1);\n                }\n            }\n        }\n        if (methodDescriptor != null) {\n            loadPackableMethod(invoker.getUrl());\n        }\n        trySetListener();\n        if (listener == null) {\n            // wrap request , need one message\n            request(1);\n        }\n    }\n\n    private void trySetListener() {\n        if (listener != null) {\n            return;\n        }\n        if (methodDescriptor == null) {\n            return;\n        }\n        if (isClosed()) {\n            return;\n        }\n        RpcInvocation invocation = buildInvocation(methodDescriptor);\n        if (isClosed()) {\n            return;\n        }\n        headerFilters.forEach(f -> f.invoke(invoker, invocation));\n        if (isClosed()) {\n            return;\n        }\n        listener = ReflectionAbstractServerCall.this.startInternalCall(invocation, methodDescriptor, invoker);\n    }\n\n    @Override\n    protected Object parseSingleMessage(byte[] data) throws Exception {\n        trySetMethodDescriptor(data);\n        trySetListener();\n        if (isClosed()) {\n            return null;\n        }\n        ClassLoadUtil.switchContextLoader(invoker.getUrl().getServiceModel().getClassLoader());\n        return packableMethod.getRequestUnpack().unpack(data);\n    }\n\n    private void trySetMethodDescriptor(byte[] data) {\n        if (methodDescriptor != null) {\n            return;\n        }\n        final TripleCustomerProtocolWapper.TripleRequestWrapper request;\n        request = TripleCustomerProtocolWapper.TripleRequestWrapper.parseFrom(data);\n\n        final String[] paramTypes =\n                request.getArgTypes().toArray(new String[request.getArgs().size()]);\n        // wrapper mode the method can overload so maybe list\n        for (MethodDescriptor descriptor : methodDescriptors) {\n            // params type is array\n            if (Arrays.equals(descriptor.getCompatibleParamSignatures(), paramTypes)) {\n                methodDescriptor = descriptor;\n                break;\n            }\n        }\n        if (methodDescriptor == null) {\n            ReflectionAbstractServerCall.this.close(\n                    TriRpcStatus.UNIMPLEMENTED.withDescription(\n                            \"Method :\" + methodName + \"[\" + Arrays.toString(paramTypes) + \"] \" + \"not found of service:\"\n                                    + serviceDescriptor.getInterfaceName()),\n                    null);\n            return;\n        }\n        loadPackableMethod(invoker.getUrl());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private void loadPackableMethod(URL url) {\n        Map<MethodDescriptor, PackableMethod> cacheMap = (Map<MethodDescriptor, PackableMethod>) url.getServiceModel()\n                .getServiceMetadata()\n                .getAttributeMap()\n                .computeIfAbsent(PACKABLE_METHOD_CACHE, (k) -> new ConcurrentHashMap<>());\n        packableMethod = cacheMap.computeIfAbsent(methodDescriptor, (md) -> frameworkModel\n                .getExtensionLoader(PackableMethodFactory.class)\n                .getExtension(ConfigurationUtils.getGlobalConfiguration(url.getApplicationModel())\n                        .getString(DUBBO_PACKABLE_METHOD_FACTORY, DEFAULT_KEY))\n                .create(methodDescriptor, url, (String) requestMetadata.get(HttpHeaderNames.CONTENT_TYPE.toString())));\n    }\n}\n",
        "methodName": null,
        "exampleID": 276,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/ReflectionAbstractServerCall.java",
        "line": 109,
        "sink": "java.lang.Character.toLowerCase",
        "source": "-",
        "sourceLine": 109,
        "qualifier": "Call to java.lang.Character.toLowerCase with untrusted data from [msg : Http2StreamFrame](1).\nCall to java.lang.Character.toLowerCase with untrusted data from [msg : Object](2).",
        "line_number": 109,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 277
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 277
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 277
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 277
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java#L368",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.call;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.CancellationContext;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.RpcContext;\nimport org.apache.dubbo.rpc.RpcInvocation;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.PackableMethod;\nimport org.apache.dubbo.rpc.model.ServiceDescriptor;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Compressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;\nimport org.apache.dubbo.rpc.protocol.tri.stream.ServerStream;\nimport org.apache.dubbo.rpc.protocol.tri.stream.StreamUtils;\n\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.util.concurrent.Future;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_CREATE_STREAM_TRIPLE;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_PARSE;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_SERIALIZE_TRIPLE;\n\npublic abstract class AbstractServerCall implements ServerCall, ServerStream.Listener {\n\n    public static final String REMOTE_ADDRESS_KEY = \"tri.remote.address\";\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(AbstractServerCall.class);\n\n    public final Invoker<?> invoker;\n    public final FrameworkModel frameworkModel;\n    public final ServerStream stream;\n    public final Executor executor;\n    public final String methodName;\n    public final String serviceName;\n    public final ServiceDescriptor serviceDescriptor;\n    private final String acceptEncoding;\n    public boolean autoRequestN = true;\n    public Long timeout;\n    ServerCall.Listener listener;\n    private Compressor compressor;\n    private boolean headerSent;\n    private boolean closed;\n    CancellationContext cancellationContext;\n    protected MethodDescriptor methodDescriptor;\n    protected PackableMethod packableMethod;\n    protected Map<String, Object> requestMetadata;\n\n    private Integer exceptionCode = CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS;\n\n    public Integer getExceptionCode() {\n        return exceptionCode;\n    }\n\n    public void setExceptionCode(Integer exceptionCode) {\n        this.exceptionCode = exceptionCode;\n    }\n\n    private boolean isNeedReturnException = false;\n\n    public boolean isNeedReturnException() {\n        return isNeedReturnException;\n    }\n\n    public void setNeedReturnException(boolean needReturnException) {\n        isNeedReturnException = needReturnException;\n    }\n\n    AbstractServerCall(\n            Invoker<?> invoker,\n            ServerStream stream,\n            FrameworkModel frameworkModel,\n            ServiceDescriptor serviceDescriptor,\n            String acceptEncoding,\n            String serviceName,\n            String methodName,\n            Executor executor) {\n        Objects.requireNonNull(serviceDescriptor, \"No service descriptor found for \" + invoker.getUrl());\n        this.invoker = invoker;\n        // is already serialized in the stream, so we don't need to serialize it again.\n        this.executor = executor;\n        this.frameworkModel = frameworkModel;\n        this.serviceDescriptor = serviceDescriptor;\n        this.serviceName = serviceName;\n        this.methodName = methodName;\n        this.stream = stream;\n        this.acceptEncoding = acceptEncoding;\n    }\n\n    // stream listener start\n    @Override\n    public void onHeader(Map<String, Object> requestMetadata) {\n        this.requestMetadata = requestMetadata;\n        if (serviceDescriptor == null) {\n            responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n            return;\n        }\n        startCall();\n    }\n\n    protected void startCall() {\n        RpcInvocation invocation = buildInvocation(methodDescriptor);\n        listener = startInternalCall(invocation, methodDescriptor, invoker);\n    }\n\n    @Override\n    public final void request(int numMessages) {\n        stream.request(numMessages);\n    }\n\n    @Override\n    public final void sendMessage(Object message) {\n        if (closed) {\n            throw new IllegalStateException(\"Stream has already canceled\");\n        }\n        // is already in executor\n        doSendMessage(message);\n    }\n\n    private void doSendMessage(Object message) {\n        if (closed) {\n            return;\n        }\n        if (!headerSent) {\n            sendHeader();\n        }\n        final byte[] data;\n        try {\n            data = packableMethod.packResponse(message);\n        } catch (Exception e) {\n            close(\n                    TriRpcStatus.INTERNAL\n                            .withDescription(\"Serialize response failed\")\n                            .withCause(e),\n                    null);\n            LOGGER.error(\n                    PROTOCOL_FAILED_SERIALIZE_TRIPLE,\n                    \"\",\n                    \"\",\n                    String.format(\"Serialize triple response failed, service=%s method=%s\", serviceName, methodName),\n                    e);\n            return;\n        }\n        if (data == null) {\n            close(TriRpcStatus.INTERNAL.withDescription(\"Missing response\"), null);\n            return;\n        }\n        Future<?> future;\n        if (compressor != null) {\n            int compressedFlag = Identity.MESSAGE_ENCODING.equals(compressor.getMessageEncoding()) ? 0 : 1;\n            final byte[] compressed = compressor.compress(data);\n            future = stream.sendMessage(compressed, compressedFlag);\n        } else {\n            future = stream.sendMessage(data, 0);\n        }\n        future.addListener(f -> {\n            if (!f.isSuccess()) {\n                cancelDual(TriRpcStatus.CANCELLED\n                        .withDescription(\"Send message failed\")\n                        .withCause(f.cause()));\n            }\n        });\n    }\n\n    @Override\n    public final void onComplete() {\n        if (listener == null) {\n            // It will enter here when there is an error in the header\n            return;\n        }\n        // Both 'onError' and 'onComplete' are termination operators.\n        // The stream will be closed when 'onError' was called, and 'onComplete' is not allowed to be called again.\n        if (isClosed()) {\n            return;\n        }\n        listener.onComplete();\n    }\n\n    @Override\n    public final void onMessage(byte[] message, boolean isReturnTriException) {\n        ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n        try {\n            Object instance = parseSingleMessage(message);\n            listener.onMessage(instance, message.length);\n        } catch (Exception e) {\n            final TriRpcStatus status =\n                    TriRpcStatus.UNKNOWN.withDescription(\"Server error\").withCause(e);\n            close(status, null);\n            LOGGER.error(\n                    PROTOCOL_FAILED_REQUEST,\n                    \"\",\n                    \"\",\n                    \"Process request failed. service=\" + serviceName + \" method=\" + methodName,\n                    e);\n        } finally {\n            ClassLoadUtil.switchContextLoader(tccl);\n        }\n    }\n\n    protected abstract Object parseSingleMessage(byte[] data) throws Exception;\n\n    @Override\n    public final void onCancelByRemote(TriRpcStatus status) {\n        closed = true;\n        if (listener == null) {\n            return;\n        }\n        cancellationContext.cancel(status.cause);\n        listener.onCancel(status);\n    }\n    // stream listener end\n\n    public final boolean isClosed() {\n        return closed;\n    }\n\n    /**\n     * Build the RpcInvocation with metadata and execute headerFilter\n     *\n     * @return RpcInvocation\n     */\n    protected RpcInvocation buildInvocation(MethodDescriptor methodDescriptor) {\n        final URL url = invoker.getUrl();\n        RpcInvocation inv = new RpcInvocation(\n                url.getServiceModel(),\n                methodDescriptor.getMethodName(),\n                serviceDescriptor.getInterfaceName(),\n                url.getProtocolServiceKey(),\n                methodDescriptor.getParameterClasses(),\n                new Object[0]);\n        inv.setTargetServiceUniqueName(url.getServiceKey());\n        inv.setReturnTypes(methodDescriptor.getReturnTypes());\n        inv.setObjectAttachments(StreamUtils.toAttachments(requestMetadata));\n        inv.put(REMOTE_ADDRESS_KEY, stream.remoteAddress());\n        // handle timeout\n        String timeout = (String) requestMetadata.get(TripleHeaderEnum.TIMEOUT.getHeader());\n        try {\n            if (Objects.nonNull(timeout)) {\n                this.timeout = parseTimeoutToMills(timeout);\n            }\n        } catch (Throwable t) {\n            LOGGER.warn(\n                    PROTOCOL_FAILED_PARSE,\n                    \"\",\n                    \"\",\n                    String.format(\n                            \"Failed to parse request timeout set from:%s, service=%s \" + \"method=%s\",\n                            timeout, serviceDescriptor.getInterfaceName(), methodName));\n        }\n        if (null != requestMetadata.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader())) {\n            inv.put(\n                    TripleHeaderEnum.CONSUMER_APP_NAME_KEY,\n                    requestMetadata.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader()));\n        }\n        return inv;\n    }\n\n    private void sendHeader() {\n        if (closed) {\n            return;\n        }\n        if (headerSent) {\n            throw new IllegalStateException(\"Header has already sent\");\n        }\n        headerSent = true;\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        headers.status(HttpResponseStatus.OK.codeAsText());\n        headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        if (acceptEncoding != null) {\n            headers.set(HttpHeaderNames.ACCEPT_ENCODING, acceptEncoding);\n        }\n        if (compressor != null) {\n            headers.set(TripleHeaderEnum.GRPC_ENCODING.getHeader(), compressor.getMessageEncoding());\n        }\n        if (!exceptionCode.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS)) {\n            headers.set(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader(), String.valueOf(exceptionCode));\n        }\n        // send header failed will reset stream and close request observer cause no more data will be sent\n        stream.sendHeader(headers).addListener(f -> {\n            if (!f.isSuccess()) {\n                cancelDual(TriRpcStatus.INTERNAL.withCause(f.cause()));\n            }\n        });\n    }\n\n    private void cancelDual(TriRpcStatus status) {\n        closed = true;\n        listener.onCancel(status);\n        cancellationContext.cancel(status.asException());\n    }\n\n    public void cancelByLocal(Throwable throwable) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        cancellationContext.cancel(throwable);\n        stream.cancelByLocal(TriRpcStatus.CANCELLED.withCause(throwable));\n    }\n\n    public void setCompression(String compression) {\n        if (headerSent) {\n            throw new IllegalStateException(\"Can not set compression after header sent\");\n        }\n        this.compressor = Compressor.getCompressor(frameworkModel, compression);\n    }\n\n    public void disableAutoRequestN() {\n        autoRequestN = false;\n    }\n\n    public boolean isAutoRequestN() {\n        return autoRequestN;\n    }\n\n    public void close(TriRpcStatus status, Map<String, Object> attachments) {\n        doClose(status, attachments);\n    }\n\n    private void doClose(TriRpcStatus status, Map<String, Object> attachments) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        stream.complete(status, attachments, isNeedReturnException, exceptionCode);\n    }\n\n    protected Long parseTimeoutToMills(String timeoutVal) {\n        if (StringUtils.isEmpty(timeoutVal) || StringUtils.isContains(timeoutVal, \"null\")) {\n            return null;\n        }\n        long value = Long.parseLong(timeoutVal.substring(0, timeoutVal.length() - 1));\n        char unit = timeoutVal.charAt(timeoutVal.length() - 1);\n        switch (unit) {\n            case 'n':\n                return TimeUnit.NANOSECONDS.toMillis(value);\n            case 'u':\n                return TimeUnit.MICROSECONDS.toMillis(value);\n            case 'm':\n                return value;\n            case 'S':\n                return TimeUnit.SECONDS.toMillis(value);\n            case 'M':\n                return TimeUnit.MINUTES.toMillis(value);\n            case 'H':\n                return TimeUnit.HOURS.toMillis(value);\n            default:\n                // invalid timeout config\n                return null;\n        }\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error.\n     *\n     * @param status response status\n     */\n    protected void responseErr(TriRpcStatus status) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        stream.complete(status, null, false, CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS);\n        LOGGER.error(\n                PROTOCOL_FAILED_REQUEST,\n                \"\",\n                \"\",\n                \"Triple request error: service=\" + serviceName + \" method\" + methodName,\n                status.asException());\n    }\n\n    protected ServerCall.Listener startInternalCall(\n            RpcInvocation invocation, MethodDescriptor methodDescriptor, Invoker<?> invoker) {\n        this.cancellationContext = RpcContext.getCancellationContext();\n        ServerCallToObserverAdapter<Object> responseObserver =\n                new ServerCallToObserverAdapter<>(this, cancellationContext);\n        try {\n            ServerCall.Listener listener;\n            switch (methodDescriptor.getRpcType()) {\n                case UNARY:\n                    listener = new UnaryServerCallListener(\n                            invocation, invoker, responseObserver, packableMethod.needWrapper());\n                    request(2);\n                    break;\n                case SERVER_STREAM:\n                    listener = new ServerStreamServerCallListener(invocation, invoker, responseObserver);\n                    request(2);\n                    break;\n                case BI_STREAM:\n                case CLIENT_STREAM:\n                    listener = new BiStreamServerCallListener(invocation, invoker, responseObserver);\n                    request(1);\n                    break;\n                default:\n                    throw new IllegalStateException(\"Can not reach here\");\n            }\n            return listener;\n        } catch (Exception e) {\n            LOGGER.error(PROTOCOL_FAILED_CREATE_STREAM_TRIPLE, \"\", \"\", \"Create triple stream failed\", e);\n            responseErr(TriRpcStatus.INTERNAL\n                    .withDescription(\"Create stream failed\")\n                    .withCause(e));\n        }\n        return null;\n    }\n}\n",
        "methodName": null,
        "exampleID": 278,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java",
        "line": 368,
        "sink": "java.util.concurrent.TimeUnit.toMillis",
        "source": "-",
        "sourceLine": 368,
        "qualifier": "Call to java.util.concurrent.TimeUnit.toMillis with untrusted data from [msg : Http2StreamFrame](1).\nCall to java.util.concurrent.TimeUnit.toMillis with untrusted data from [msg : Object](2).",
        "line_number": 368,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 279
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 279
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 279
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 279
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java#L370",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.call;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.CancellationContext;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.RpcContext;\nimport org.apache.dubbo.rpc.RpcInvocation;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.PackableMethod;\nimport org.apache.dubbo.rpc.model.ServiceDescriptor;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Compressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;\nimport org.apache.dubbo.rpc.protocol.tri.stream.ServerStream;\nimport org.apache.dubbo.rpc.protocol.tri.stream.StreamUtils;\n\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.util.concurrent.Future;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_CREATE_STREAM_TRIPLE;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_PARSE;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_SERIALIZE_TRIPLE;\n\npublic abstract class AbstractServerCall implements ServerCall, ServerStream.Listener {\n\n    public static final String REMOTE_ADDRESS_KEY = \"tri.remote.address\";\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(AbstractServerCall.class);\n\n    public final Invoker<?> invoker;\n    public final FrameworkModel frameworkModel;\n    public final ServerStream stream;\n    public final Executor executor;\n    public final String methodName;\n    public final String serviceName;\n    public final ServiceDescriptor serviceDescriptor;\n    private final String acceptEncoding;\n    public boolean autoRequestN = true;\n    public Long timeout;\n    ServerCall.Listener listener;\n    private Compressor compressor;\n    private boolean headerSent;\n    private boolean closed;\n    CancellationContext cancellationContext;\n    protected MethodDescriptor methodDescriptor;\n    protected PackableMethod packableMethod;\n    protected Map<String, Object> requestMetadata;\n\n    private Integer exceptionCode = CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS;\n\n    public Integer getExceptionCode() {\n        return exceptionCode;\n    }\n\n    public void setExceptionCode(Integer exceptionCode) {\n        this.exceptionCode = exceptionCode;\n    }\n\n    private boolean isNeedReturnException = false;\n\n    public boolean isNeedReturnException() {\n        return isNeedReturnException;\n    }\n\n    public void setNeedReturnException(boolean needReturnException) {\n        isNeedReturnException = needReturnException;\n    }\n\n    AbstractServerCall(\n            Invoker<?> invoker,\n            ServerStream stream,\n            FrameworkModel frameworkModel,\n            ServiceDescriptor serviceDescriptor,\n            String acceptEncoding,\n            String serviceName,\n            String methodName,\n            Executor executor) {\n        Objects.requireNonNull(serviceDescriptor, \"No service descriptor found for \" + invoker.getUrl());\n        this.invoker = invoker;\n        // is already serialized in the stream, so we don't need to serialize it again.\n        this.executor = executor;\n        this.frameworkModel = frameworkModel;\n        this.serviceDescriptor = serviceDescriptor;\n        this.serviceName = serviceName;\n        this.methodName = methodName;\n        this.stream = stream;\n        this.acceptEncoding = acceptEncoding;\n    }\n\n    // stream listener start\n    @Override\n    public void onHeader(Map<String, Object> requestMetadata) {\n        this.requestMetadata = requestMetadata;\n        if (serviceDescriptor == null) {\n            responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n            return;\n        }\n        startCall();\n    }\n\n    protected void startCall() {\n        RpcInvocation invocation = buildInvocation(methodDescriptor);\n        listener = startInternalCall(invocation, methodDescriptor, invoker);\n    }\n\n    @Override\n    public final void request(int numMessages) {\n        stream.request(numMessages);\n    }\n\n    @Override\n    public final void sendMessage(Object message) {\n        if (closed) {\n            throw new IllegalStateException(\"Stream has already canceled\");\n        }\n        // is already in executor\n        doSendMessage(message);\n    }\n\n    private void doSendMessage(Object message) {\n        if (closed) {\n            return;\n        }\n        if (!headerSent) {\n            sendHeader();\n        }\n        final byte[] data;\n        try {\n            data = packableMethod.packResponse(message);\n        } catch (Exception e) {\n            close(\n                    TriRpcStatus.INTERNAL\n                            .withDescription(\"Serialize response failed\")\n                            .withCause(e),\n                    null);\n            LOGGER.error(\n                    PROTOCOL_FAILED_SERIALIZE_TRIPLE,\n                    \"\",\n                    \"\",\n                    String.format(\"Serialize triple response failed, service=%s method=%s\", serviceName, methodName),\n                    e);\n            return;\n        }\n        if (data == null) {\n            close(TriRpcStatus.INTERNAL.withDescription(\"Missing response\"), null);\n            return;\n        }\n        Future<?> future;\n        if (compressor != null) {\n            int compressedFlag = Identity.MESSAGE_ENCODING.equals(compressor.getMessageEncoding()) ? 0 : 1;\n            final byte[] compressed = compressor.compress(data);\n            future = stream.sendMessage(compressed, compressedFlag);\n        } else {\n            future = stream.sendMessage(data, 0);\n        }\n        future.addListener(f -> {\n            if (!f.isSuccess()) {\n                cancelDual(TriRpcStatus.CANCELLED\n                        .withDescription(\"Send message failed\")\n                        .withCause(f.cause()));\n            }\n        });\n    }\n\n    @Override\n    public final void onComplete() {\n        if (listener == null) {\n            // It will enter here when there is an error in the header\n            return;\n        }\n        // Both 'onError' and 'onComplete' are termination operators.\n        // The stream will be closed when 'onError' was called, and 'onComplete' is not allowed to be called again.\n        if (isClosed()) {\n            return;\n        }\n        listener.onComplete();\n    }\n\n    @Override\n    public final void onMessage(byte[] message, boolean isReturnTriException) {\n        ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n        try {\n            Object instance = parseSingleMessage(message);\n            listener.onMessage(instance, message.length);\n        } catch (Exception e) {\n            final TriRpcStatus status =\n                    TriRpcStatus.UNKNOWN.withDescription(\"Server error\").withCause(e);\n            close(status, null);\n            LOGGER.error(\n                    PROTOCOL_FAILED_REQUEST,\n                    \"\",\n                    \"\",\n                    \"Process request failed. service=\" + serviceName + \" method=\" + methodName,\n                    e);\n        } finally {\n            ClassLoadUtil.switchContextLoader(tccl);\n        }\n    }\n\n    protected abstract Object parseSingleMessage(byte[] data) throws Exception;\n\n    @Override\n    public final void onCancelByRemote(TriRpcStatus status) {\n        closed = true;\n        if (listener == null) {\n            return;\n        }\n        cancellationContext.cancel(status.cause);\n        listener.onCancel(status);\n    }\n    // stream listener end\n\n    public final boolean isClosed() {\n        return closed;\n    }\n\n    /**\n     * Build the RpcInvocation with metadata and execute headerFilter\n     *\n     * @return RpcInvocation\n     */\n    protected RpcInvocation buildInvocation(MethodDescriptor methodDescriptor) {\n        final URL url = invoker.getUrl();\n        RpcInvocation inv = new RpcInvocation(\n                url.getServiceModel(),\n                methodDescriptor.getMethodName(),\n                serviceDescriptor.getInterfaceName(),\n                url.getProtocolServiceKey(),\n                methodDescriptor.getParameterClasses(),\n                new Object[0]);\n        inv.setTargetServiceUniqueName(url.getServiceKey());\n        inv.setReturnTypes(methodDescriptor.getReturnTypes());\n        inv.setObjectAttachments(StreamUtils.toAttachments(requestMetadata));\n        inv.put(REMOTE_ADDRESS_KEY, stream.remoteAddress());\n        // handle timeout\n        String timeout = (String) requestMetadata.get(TripleHeaderEnum.TIMEOUT.getHeader());\n        try {\n            if (Objects.nonNull(timeout)) {\n                this.timeout = parseTimeoutToMills(timeout);\n            }\n        } catch (Throwable t) {\n            LOGGER.warn(\n                    PROTOCOL_FAILED_PARSE,\n                    \"\",\n                    \"\",\n                    String.format(\n                            \"Failed to parse request timeout set from:%s, service=%s \" + \"method=%s\",\n                            timeout, serviceDescriptor.getInterfaceName(), methodName));\n        }\n        if (null != requestMetadata.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader())) {\n            inv.put(\n                    TripleHeaderEnum.CONSUMER_APP_NAME_KEY,\n                    requestMetadata.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader()));\n        }\n        return inv;\n    }\n\n    private void sendHeader() {\n        if (closed) {\n            return;\n        }\n        if (headerSent) {\n            throw new IllegalStateException(\"Header has already sent\");\n        }\n        headerSent = true;\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        headers.status(HttpResponseStatus.OK.codeAsText());\n        headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        if (acceptEncoding != null) {\n            headers.set(HttpHeaderNames.ACCEPT_ENCODING, acceptEncoding);\n        }\n        if (compressor != null) {\n            headers.set(TripleHeaderEnum.GRPC_ENCODING.getHeader(), compressor.getMessageEncoding());\n        }\n        if (!exceptionCode.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS)) {\n            headers.set(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader(), String.valueOf(exceptionCode));\n        }\n        // send header failed will reset stream and close request observer cause no more data will be sent\n        stream.sendHeader(headers).addListener(f -> {\n            if (!f.isSuccess()) {\n                cancelDual(TriRpcStatus.INTERNAL.withCause(f.cause()));\n            }\n        });\n    }\n\n    private void cancelDual(TriRpcStatus status) {\n        closed = true;\n        listener.onCancel(status);\n        cancellationContext.cancel(status.asException());\n    }\n\n    public void cancelByLocal(Throwable throwable) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        cancellationContext.cancel(throwable);\n        stream.cancelByLocal(TriRpcStatus.CANCELLED.withCause(throwable));\n    }\n\n    public void setCompression(String compression) {\n        if (headerSent) {\n            throw new IllegalStateException(\"Can not set compression after header sent\");\n        }\n        this.compressor = Compressor.getCompressor(frameworkModel, compression);\n    }\n\n    public void disableAutoRequestN() {\n        autoRequestN = false;\n    }\n\n    public boolean isAutoRequestN() {\n        return autoRequestN;\n    }\n\n    public void close(TriRpcStatus status, Map<String, Object> attachments) {\n        doClose(status, attachments);\n    }\n\n    private void doClose(TriRpcStatus status, Map<String, Object> attachments) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        stream.complete(status, attachments, isNeedReturnException, exceptionCode);\n    }\n\n    protected Long parseTimeoutToMills(String timeoutVal) {\n        if (StringUtils.isEmpty(timeoutVal) || StringUtils.isContains(timeoutVal, \"null\")) {\n            return null;\n        }\n        long value = Long.parseLong(timeoutVal.substring(0, timeoutVal.length() - 1));\n        char unit = timeoutVal.charAt(timeoutVal.length() - 1);\n        switch (unit) {\n            case 'n':\n                return TimeUnit.NANOSECONDS.toMillis(value);\n            case 'u':\n                return TimeUnit.MICROSECONDS.toMillis(value);\n            case 'm':\n                return value;\n            case 'S':\n                return TimeUnit.SECONDS.toMillis(value);\n            case 'M':\n                return TimeUnit.MINUTES.toMillis(value);\n            case 'H':\n                return TimeUnit.HOURS.toMillis(value);\n            default:\n                // invalid timeout config\n                return null;\n        }\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error.\n     *\n     * @param status response status\n     */\n    protected void responseErr(TriRpcStatus status) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        stream.complete(status, null, false, CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS);\n        LOGGER.error(\n                PROTOCOL_FAILED_REQUEST,\n                \"\",\n                \"\",\n                \"Triple request error: service=\" + serviceName + \" method\" + methodName,\n                status.asException());\n    }\n\n    protected ServerCall.Listener startInternalCall(\n            RpcInvocation invocation, MethodDescriptor methodDescriptor, Invoker<?> invoker) {\n        this.cancellationContext = RpcContext.getCancellationContext();\n        ServerCallToObserverAdapter<Object> responseObserver =\n                new ServerCallToObserverAdapter<>(this, cancellationContext);\n        try {\n            ServerCall.Listener listener;\n            switch (methodDescriptor.getRpcType()) {\n                case UNARY:\n                    listener = new UnaryServerCallListener(\n                            invocation, invoker, responseObserver, packableMethod.needWrapper());\n                    request(2);\n                    break;\n                case SERVER_STREAM:\n                    listener = new ServerStreamServerCallListener(invocation, invoker, responseObserver);\n                    request(2);\n                    break;\n                case BI_STREAM:\n                case CLIENT_STREAM:\n                    listener = new BiStreamServerCallListener(invocation, invoker, responseObserver);\n                    request(1);\n                    break;\n                default:\n                    throw new IllegalStateException(\"Can not reach here\");\n            }\n            return listener;\n        } catch (Exception e) {\n            LOGGER.error(PROTOCOL_FAILED_CREATE_STREAM_TRIPLE, \"\", \"\", \"Create triple stream failed\", e);\n            responseErr(TriRpcStatus.INTERNAL\n                    .withDescription(\"Create stream failed\")\n                    .withCause(e));\n        }\n        return null;\n    }\n}\n",
        "methodName": null,
        "exampleID": 280,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java",
        "line": 370,
        "sink": "java.util.concurrent.TimeUnit.toMillis",
        "source": "-",
        "sourceLine": 370,
        "qualifier": "Call to java.util.concurrent.TimeUnit.toMillis with untrusted data from [msg : Http2StreamFrame](1).\nCall to java.util.concurrent.TimeUnit.toMillis with untrusted data from [msg : Object](2).",
        "line_number": 370,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 281
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 281
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 281
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 281
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java#L374",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.call;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.CancellationContext;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.RpcContext;\nimport org.apache.dubbo.rpc.RpcInvocation;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.PackableMethod;\nimport org.apache.dubbo.rpc.model.ServiceDescriptor;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Compressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;\nimport org.apache.dubbo.rpc.protocol.tri.stream.ServerStream;\nimport org.apache.dubbo.rpc.protocol.tri.stream.StreamUtils;\n\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.util.concurrent.Future;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_CREATE_STREAM_TRIPLE;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_PARSE;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_SERIALIZE_TRIPLE;\n\npublic abstract class AbstractServerCall implements ServerCall, ServerStream.Listener {\n\n    public static final String REMOTE_ADDRESS_KEY = \"tri.remote.address\";\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(AbstractServerCall.class);\n\n    public final Invoker<?> invoker;\n    public final FrameworkModel frameworkModel;\n    public final ServerStream stream;\n    public final Executor executor;\n    public final String methodName;\n    public final String serviceName;\n    public final ServiceDescriptor serviceDescriptor;\n    private final String acceptEncoding;\n    public boolean autoRequestN = true;\n    public Long timeout;\n    ServerCall.Listener listener;\n    private Compressor compressor;\n    private boolean headerSent;\n    private boolean closed;\n    CancellationContext cancellationContext;\n    protected MethodDescriptor methodDescriptor;\n    protected PackableMethod packableMethod;\n    protected Map<String, Object> requestMetadata;\n\n    private Integer exceptionCode = CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS;\n\n    public Integer getExceptionCode() {\n        return exceptionCode;\n    }\n\n    public void setExceptionCode(Integer exceptionCode) {\n        this.exceptionCode = exceptionCode;\n    }\n\n    private boolean isNeedReturnException = false;\n\n    public boolean isNeedReturnException() {\n        return isNeedReturnException;\n    }\n\n    public void setNeedReturnException(boolean needReturnException) {\n        isNeedReturnException = needReturnException;\n    }\n\n    AbstractServerCall(\n            Invoker<?> invoker,\n            ServerStream stream,\n            FrameworkModel frameworkModel,\n            ServiceDescriptor serviceDescriptor,\n            String acceptEncoding,\n            String serviceName,\n            String methodName,\n            Executor executor) {\n        Objects.requireNonNull(serviceDescriptor, \"No service descriptor found for \" + invoker.getUrl());\n        this.invoker = invoker;\n        // is already serialized in the stream, so we don't need to serialize it again.\n        this.executor = executor;\n        this.frameworkModel = frameworkModel;\n        this.serviceDescriptor = serviceDescriptor;\n        this.serviceName = serviceName;\n        this.methodName = methodName;\n        this.stream = stream;\n        this.acceptEncoding = acceptEncoding;\n    }\n\n    // stream listener start\n    @Override\n    public void onHeader(Map<String, Object> requestMetadata) {\n        this.requestMetadata = requestMetadata;\n        if (serviceDescriptor == null) {\n            responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n            return;\n        }\n        startCall();\n    }\n\n    protected void startCall() {\n        RpcInvocation invocation = buildInvocation(methodDescriptor);\n        listener = startInternalCall(invocation, methodDescriptor, invoker);\n    }\n\n    @Override\n    public final void request(int numMessages) {\n        stream.request(numMessages);\n    }\n\n    @Override\n    public final void sendMessage(Object message) {\n        if (closed) {\n            throw new IllegalStateException(\"Stream has already canceled\");\n        }\n        // is already in executor\n        doSendMessage(message);\n    }\n\n    private void doSendMessage(Object message) {\n        if (closed) {\n            return;\n        }\n        if (!headerSent) {\n            sendHeader();\n        }\n        final byte[] data;\n        try {\n            data = packableMethod.packResponse(message);\n        } catch (Exception e) {\n            close(\n                    TriRpcStatus.INTERNAL\n                            .withDescription(\"Serialize response failed\")\n                            .withCause(e),\n                    null);\n            LOGGER.error(\n                    PROTOCOL_FAILED_SERIALIZE_TRIPLE,\n                    \"\",\n                    \"\",\n                    String.format(\"Serialize triple response failed, service=%s method=%s\", serviceName, methodName),\n                    e);\n            return;\n        }\n        if (data == null) {\n            close(TriRpcStatus.INTERNAL.withDescription(\"Missing response\"), null);\n            return;\n        }\n        Future<?> future;\n        if (compressor != null) {\n            int compressedFlag = Identity.MESSAGE_ENCODING.equals(compressor.getMessageEncoding()) ? 0 : 1;\n            final byte[] compressed = compressor.compress(data);\n            future = stream.sendMessage(compressed, compressedFlag);\n        } else {\n            future = stream.sendMessage(data, 0);\n        }\n        future.addListener(f -> {\n            if (!f.isSuccess()) {\n                cancelDual(TriRpcStatus.CANCELLED\n                        .withDescription(\"Send message failed\")\n                        .withCause(f.cause()));\n            }\n        });\n    }\n\n    @Override\n    public final void onComplete() {\n        if (listener == null) {\n            // It will enter here when there is an error in the header\n            return;\n        }\n        // Both 'onError' and 'onComplete' are termination operators.\n        // The stream will be closed when 'onError' was called, and 'onComplete' is not allowed to be called again.\n        if (isClosed()) {\n            return;\n        }\n        listener.onComplete();\n    }\n\n    @Override\n    public final void onMessage(byte[] message, boolean isReturnTriException) {\n        ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n        try {\n            Object instance = parseSingleMessage(message);\n            listener.onMessage(instance, message.length);\n        } catch (Exception e) {\n            final TriRpcStatus status =\n                    TriRpcStatus.UNKNOWN.withDescription(\"Server error\").withCause(e);\n            close(status, null);\n            LOGGER.error(\n                    PROTOCOL_FAILED_REQUEST,\n                    \"\",\n                    \"\",\n                    \"Process request failed. service=\" + serviceName + \" method=\" + methodName,\n                    e);\n        } finally {\n            ClassLoadUtil.switchContextLoader(tccl);\n        }\n    }\n\n    protected abstract Object parseSingleMessage(byte[] data) throws Exception;\n\n    @Override\n    public final void onCancelByRemote(TriRpcStatus status) {\n        closed = true;\n        if (listener == null) {\n            return;\n        }\n        cancellationContext.cancel(status.cause);\n        listener.onCancel(status);\n    }\n    // stream listener end\n\n    public final boolean isClosed() {\n        return closed;\n    }\n\n    /**\n     * Build the RpcInvocation with metadata and execute headerFilter\n     *\n     * @return RpcInvocation\n     */\n    protected RpcInvocation buildInvocation(MethodDescriptor methodDescriptor) {\n        final URL url = invoker.getUrl();\n        RpcInvocation inv = new RpcInvocation(\n                url.getServiceModel(),\n                methodDescriptor.getMethodName(),\n                serviceDescriptor.getInterfaceName(),\n                url.getProtocolServiceKey(),\n                methodDescriptor.getParameterClasses(),\n                new Object[0]);\n        inv.setTargetServiceUniqueName(url.getServiceKey());\n        inv.setReturnTypes(methodDescriptor.getReturnTypes());\n        inv.setObjectAttachments(StreamUtils.toAttachments(requestMetadata));\n        inv.put(REMOTE_ADDRESS_KEY, stream.remoteAddress());\n        // handle timeout\n        String timeout = (String) requestMetadata.get(TripleHeaderEnum.TIMEOUT.getHeader());\n        try {\n            if (Objects.nonNull(timeout)) {\n                this.timeout = parseTimeoutToMills(timeout);\n            }\n        } catch (Throwable t) {\n            LOGGER.warn(\n                    PROTOCOL_FAILED_PARSE,\n                    \"\",\n                    \"\",\n                    String.format(\n                            \"Failed to parse request timeout set from:%s, service=%s \" + \"method=%s\",\n                            timeout, serviceDescriptor.getInterfaceName(), methodName));\n        }\n        if (null != requestMetadata.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader())) {\n            inv.put(\n                    TripleHeaderEnum.CONSUMER_APP_NAME_KEY,\n                    requestMetadata.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader()));\n        }\n        return inv;\n    }\n\n    private void sendHeader() {\n        if (closed) {\n            return;\n        }\n        if (headerSent) {\n            throw new IllegalStateException(\"Header has already sent\");\n        }\n        headerSent = true;\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        headers.status(HttpResponseStatus.OK.codeAsText());\n        headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        if (acceptEncoding != null) {\n            headers.set(HttpHeaderNames.ACCEPT_ENCODING, acceptEncoding);\n        }\n        if (compressor != null) {\n            headers.set(TripleHeaderEnum.GRPC_ENCODING.getHeader(), compressor.getMessageEncoding());\n        }\n        if (!exceptionCode.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS)) {\n            headers.set(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader(), String.valueOf(exceptionCode));\n        }\n        // send header failed will reset stream and close request observer cause no more data will be sent\n        stream.sendHeader(headers).addListener(f -> {\n            if (!f.isSuccess()) {\n                cancelDual(TriRpcStatus.INTERNAL.withCause(f.cause()));\n            }\n        });\n    }\n\n    private void cancelDual(TriRpcStatus status) {\n        closed = true;\n        listener.onCancel(status);\n        cancellationContext.cancel(status.asException());\n    }\n\n    public void cancelByLocal(Throwable throwable) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        cancellationContext.cancel(throwable);\n        stream.cancelByLocal(TriRpcStatus.CANCELLED.withCause(throwable));\n    }\n\n    public void setCompression(String compression) {\n        if (headerSent) {\n            throw new IllegalStateException(\"Can not set compression after header sent\");\n        }\n        this.compressor = Compressor.getCompressor(frameworkModel, compression);\n    }\n\n    public void disableAutoRequestN() {\n        autoRequestN = false;\n    }\n\n    public boolean isAutoRequestN() {\n        return autoRequestN;\n    }\n\n    public void close(TriRpcStatus status, Map<String, Object> attachments) {\n        doClose(status, attachments);\n    }\n\n    private void doClose(TriRpcStatus status, Map<String, Object> attachments) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        stream.complete(status, attachments, isNeedReturnException, exceptionCode);\n    }\n\n    protected Long parseTimeoutToMills(String timeoutVal) {\n        if (StringUtils.isEmpty(timeoutVal) || StringUtils.isContains(timeoutVal, \"null\")) {\n            return null;\n        }\n        long value = Long.parseLong(timeoutVal.substring(0, timeoutVal.length() - 1));\n        char unit = timeoutVal.charAt(timeoutVal.length() - 1);\n        switch (unit) {\n            case 'n':\n                return TimeUnit.NANOSECONDS.toMillis(value);\n            case 'u':\n                return TimeUnit.MICROSECONDS.toMillis(value);\n            case 'm':\n                return value;\n            case 'S':\n                return TimeUnit.SECONDS.toMillis(value);\n            case 'M':\n                return TimeUnit.MINUTES.toMillis(value);\n            case 'H':\n                return TimeUnit.HOURS.toMillis(value);\n            default:\n                // invalid timeout config\n                return null;\n        }\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error.\n     *\n     * @param status response status\n     */\n    protected void responseErr(TriRpcStatus status) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        stream.complete(status, null, false, CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS);\n        LOGGER.error(\n                PROTOCOL_FAILED_REQUEST,\n                \"\",\n                \"\",\n                \"Triple request error: service=\" + serviceName + \" method\" + methodName,\n                status.asException());\n    }\n\n    protected ServerCall.Listener startInternalCall(\n            RpcInvocation invocation, MethodDescriptor methodDescriptor, Invoker<?> invoker) {\n        this.cancellationContext = RpcContext.getCancellationContext();\n        ServerCallToObserverAdapter<Object> responseObserver =\n                new ServerCallToObserverAdapter<>(this, cancellationContext);\n        try {\n            ServerCall.Listener listener;\n            switch (methodDescriptor.getRpcType()) {\n                case UNARY:\n                    listener = new UnaryServerCallListener(\n                            invocation, invoker, responseObserver, packableMethod.needWrapper());\n                    request(2);\n                    break;\n                case SERVER_STREAM:\n                    listener = new ServerStreamServerCallListener(invocation, invoker, responseObserver);\n                    request(2);\n                    break;\n                case BI_STREAM:\n                case CLIENT_STREAM:\n                    listener = new BiStreamServerCallListener(invocation, invoker, responseObserver);\n                    request(1);\n                    break;\n                default:\n                    throw new IllegalStateException(\"Can not reach here\");\n            }\n            return listener;\n        } catch (Exception e) {\n            LOGGER.error(PROTOCOL_FAILED_CREATE_STREAM_TRIPLE, \"\", \"\", \"Create triple stream failed\", e);\n            responseErr(TriRpcStatus.INTERNAL\n                    .withDescription(\"Create stream failed\")\n                    .withCause(e));\n        }\n        return null;\n    }\n}\n",
        "methodName": null,
        "exampleID": 282,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java",
        "line": 374,
        "sink": "java.util.concurrent.TimeUnit.toMillis",
        "source": "-",
        "sourceLine": 374,
        "qualifier": "Call to java.util.concurrent.TimeUnit.toMillis with untrusted data from [msg : Http2StreamFrame](1).\nCall to java.util.concurrent.TimeUnit.toMillis with untrusted data from [msg : Object](2).",
        "line_number": 374,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 283
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 283
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 283
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 283
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java#L376",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.call;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.CancellationContext;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.RpcContext;\nimport org.apache.dubbo.rpc.RpcInvocation;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.PackableMethod;\nimport org.apache.dubbo.rpc.model.ServiceDescriptor;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Compressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;\nimport org.apache.dubbo.rpc.protocol.tri.stream.ServerStream;\nimport org.apache.dubbo.rpc.protocol.tri.stream.StreamUtils;\n\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.util.concurrent.Future;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_CREATE_STREAM_TRIPLE;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_PARSE;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_SERIALIZE_TRIPLE;\n\npublic abstract class AbstractServerCall implements ServerCall, ServerStream.Listener {\n\n    public static final String REMOTE_ADDRESS_KEY = \"tri.remote.address\";\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(AbstractServerCall.class);\n\n    public final Invoker<?> invoker;\n    public final FrameworkModel frameworkModel;\n    public final ServerStream stream;\n    public final Executor executor;\n    public final String methodName;\n    public final String serviceName;\n    public final ServiceDescriptor serviceDescriptor;\n    private final String acceptEncoding;\n    public boolean autoRequestN = true;\n    public Long timeout;\n    ServerCall.Listener listener;\n    private Compressor compressor;\n    private boolean headerSent;\n    private boolean closed;\n    CancellationContext cancellationContext;\n    protected MethodDescriptor methodDescriptor;\n    protected PackableMethod packableMethod;\n    protected Map<String, Object> requestMetadata;\n\n    private Integer exceptionCode = CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS;\n\n    public Integer getExceptionCode() {\n        return exceptionCode;\n    }\n\n    public void setExceptionCode(Integer exceptionCode) {\n        this.exceptionCode = exceptionCode;\n    }\n\n    private boolean isNeedReturnException = false;\n\n    public boolean isNeedReturnException() {\n        return isNeedReturnException;\n    }\n\n    public void setNeedReturnException(boolean needReturnException) {\n        isNeedReturnException = needReturnException;\n    }\n\n    AbstractServerCall(\n            Invoker<?> invoker,\n            ServerStream stream,\n            FrameworkModel frameworkModel,\n            ServiceDescriptor serviceDescriptor,\n            String acceptEncoding,\n            String serviceName,\n            String methodName,\n            Executor executor) {\n        Objects.requireNonNull(serviceDescriptor, \"No service descriptor found for \" + invoker.getUrl());\n        this.invoker = invoker;\n        // is already serialized in the stream, so we don't need to serialize it again.\n        this.executor = executor;\n        this.frameworkModel = frameworkModel;\n        this.serviceDescriptor = serviceDescriptor;\n        this.serviceName = serviceName;\n        this.methodName = methodName;\n        this.stream = stream;\n        this.acceptEncoding = acceptEncoding;\n    }\n\n    // stream listener start\n    @Override\n    public void onHeader(Map<String, Object> requestMetadata) {\n        this.requestMetadata = requestMetadata;\n        if (serviceDescriptor == null) {\n            responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n            return;\n        }\n        startCall();\n    }\n\n    protected void startCall() {\n        RpcInvocation invocation = buildInvocation(methodDescriptor);\n        listener = startInternalCall(invocation, methodDescriptor, invoker);\n    }\n\n    @Override\n    public final void request(int numMessages) {\n        stream.request(numMessages);\n    }\n\n    @Override\n    public final void sendMessage(Object message) {\n        if (closed) {\n            throw new IllegalStateException(\"Stream has already canceled\");\n        }\n        // is already in executor\n        doSendMessage(message);\n    }\n\n    private void doSendMessage(Object message) {\n        if (closed) {\n            return;\n        }\n        if (!headerSent) {\n            sendHeader();\n        }\n        final byte[] data;\n        try {\n            data = packableMethod.packResponse(message);\n        } catch (Exception e) {\n            close(\n                    TriRpcStatus.INTERNAL\n                            .withDescription(\"Serialize response failed\")\n                            .withCause(e),\n                    null);\n            LOGGER.error(\n                    PROTOCOL_FAILED_SERIALIZE_TRIPLE,\n                    \"\",\n                    \"\",\n                    String.format(\"Serialize triple response failed, service=%s method=%s\", serviceName, methodName),\n                    e);\n            return;\n        }\n        if (data == null) {\n            close(TriRpcStatus.INTERNAL.withDescription(\"Missing response\"), null);\n            return;\n        }\n        Future<?> future;\n        if (compressor != null) {\n            int compressedFlag = Identity.MESSAGE_ENCODING.equals(compressor.getMessageEncoding()) ? 0 : 1;\n            final byte[] compressed = compressor.compress(data);\n            future = stream.sendMessage(compressed, compressedFlag);\n        } else {\n            future = stream.sendMessage(data, 0);\n        }\n        future.addListener(f -> {\n            if (!f.isSuccess()) {\n                cancelDual(TriRpcStatus.CANCELLED\n                        .withDescription(\"Send message failed\")\n                        .withCause(f.cause()));\n            }\n        });\n    }\n\n    @Override\n    public final void onComplete() {\n        if (listener == null) {\n            // It will enter here when there is an error in the header\n            return;\n        }\n        // Both 'onError' and 'onComplete' are termination operators.\n        // The stream will be closed when 'onError' was called, and 'onComplete' is not allowed to be called again.\n        if (isClosed()) {\n            return;\n        }\n        listener.onComplete();\n    }\n\n    @Override\n    public final void onMessage(byte[] message, boolean isReturnTriException) {\n        ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n        try {\n            Object instance = parseSingleMessage(message);\n            listener.onMessage(instance, message.length);\n        } catch (Exception e) {\n            final TriRpcStatus status =\n                    TriRpcStatus.UNKNOWN.withDescription(\"Server error\").withCause(e);\n            close(status, null);\n            LOGGER.error(\n                    PROTOCOL_FAILED_REQUEST,\n                    \"\",\n                    \"\",\n                    \"Process request failed. service=\" + serviceName + \" method=\" + methodName,\n                    e);\n        } finally {\n            ClassLoadUtil.switchContextLoader(tccl);\n        }\n    }\n\n    protected abstract Object parseSingleMessage(byte[] data) throws Exception;\n\n    @Override\n    public final void onCancelByRemote(TriRpcStatus status) {\n        closed = true;\n        if (listener == null) {\n            return;\n        }\n        cancellationContext.cancel(status.cause);\n        listener.onCancel(status);\n    }\n    // stream listener end\n\n    public final boolean isClosed() {\n        return closed;\n    }\n\n    /**\n     * Build the RpcInvocation with metadata and execute headerFilter\n     *\n     * @return RpcInvocation\n     */\n    protected RpcInvocation buildInvocation(MethodDescriptor methodDescriptor) {\n        final URL url = invoker.getUrl();\n        RpcInvocation inv = new RpcInvocation(\n                url.getServiceModel(),\n                methodDescriptor.getMethodName(),\n                serviceDescriptor.getInterfaceName(),\n                url.getProtocolServiceKey(),\n                methodDescriptor.getParameterClasses(),\n                new Object[0]);\n        inv.setTargetServiceUniqueName(url.getServiceKey());\n        inv.setReturnTypes(methodDescriptor.getReturnTypes());\n        inv.setObjectAttachments(StreamUtils.toAttachments(requestMetadata));\n        inv.put(REMOTE_ADDRESS_KEY, stream.remoteAddress());\n        // handle timeout\n        String timeout = (String) requestMetadata.get(TripleHeaderEnum.TIMEOUT.getHeader());\n        try {\n            if (Objects.nonNull(timeout)) {\n                this.timeout = parseTimeoutToMills(timeout);\n            }\n        } catch (Throwable t) {\n            LOGGER.warn(\n                    PROTOCOL_FAILED_PARSE,\n                    \"\",\n                    \"\",\n                    String.format(\n                            \"Failed to parse request timeout set from:%s, service=%s \" + \"method=%s\",\n                            timeout, serviceDescriptor.getInterfaceName(), methodName));\n        }\n        if (null != requestMetadata.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader())) {\n            inv.put(\n                    TripleHeaderEnum.CONSUMER_APP_NAME_KEY,\n                    requestMetadata.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader()));\n        }\n        return inv;\n    }\n\n    private void sendHeader() {\n        if (closed) {\n            return;\n        }\n        if (headerSent) {\n            throw new IllegalStateException(\"Header has already sent\");\n        }\n        headerSent = true;\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        headers.status(HttpResponseStatus.OK.codeAsText());\n        headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        if (acceptEncoding != null) {\n            headers.set(HttpHeaderNames.ACCEPT_ENCODING, acceptEncoding);\n        }\n        if (compressor != null) {\n            headers.set(TripleHeaderEnum.GRPC_ENCODING.getHeader(), compressor.getMessageEncoding());\n        }\n        if (!exceptionCode.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS)) {\n            headers.set(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader(), String.valueOf(exceptionCode));\n        }\n        // send header failed will reset stream and close request observer cause no more data will be sent\n        stream.sendHeader(headers).addListener(f -> {\n            if (!f.isSuccess()) {\n                cancelDual(TriRpcStatus.INTERNAL.withCause(f.cause()));\n            }\n        });\n    }\n\n    private void cancelDual(TriRpcStatus status) {\n        closed = true;\n        listener.onCancel(status);\n        cancellationContext.cancel(status.asException());\n    }\n\n    public void cancelByLocal(Throwable throwable) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        cancellationContext.cancel(throwable);\n        stream.cancelByLocal(TriRpcStatus.CANCELLED.withCause(throwable));\n    }\n\n    public void setCompression(String compression) {\n        if (headerSent) {\n            throw new IllegalStateException(\"Can not set compression after header sent\");\n        }\n        this.compressor = Compressor.getCompressor(frameworkModel, compression);\n    }\n\n    public void disableAutoRequestN() {\n        autoRequestN = false;\n    }\n\n    public boolean isAutoRequestN() {\n        return autoRequestN;\n    }\n\n    public void close(TriRpcStatus status, Map<String, Object> attachments) {\n        doClose(status, attachments);\n    }\n\n    private void doClose(TriRpcStatus status, Map<String, Object> attachments) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        stream.complete(status, attachments, isNeedReturnException, exceptionCode);\n    }\n\n    protected Long parseTimeoutToMills(String timeoutVal) {\n        if (StringUtils.isEmpty(timeoutVal) || StringUtils.isContains(timeoutVal, \"null\")) {\n            return null;\n        }\n        long value = Long.parseLong(timeoutVal.substring(0, timeoutVal.length() - 1));\n        char unit = timeoutVal.charAt(timeoutVal.length() - 1);\n        switch (unit) {\n            case 'n':\n                return TimeUnit.NANOSECONDS.toMillis(value);\n            case 'u':\n                return TimeUnit.MICROSECONDS.toMillis(value);\n            case 'm':\n                return value;\n            case 'S':\n                return TimeUnit.SECONDS.toMillis(value);\n            case 'M':\n                return TimeUnit.MINUTES.toMillis(value);\n            case 'H':\n                return TimeUnit.HOURS.toMillis(value);\n            default:\n                // invalid timeout config\n                return null;\n        }\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error.\n     *\n     * @param status response status\n     */\n    protected void responseErr(TriRpcStatus status) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        stream.complete(status, null, false, CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS);\n        LOGGER.error(\n                PROTOCOL_FAILED_REQUEST,\n                \"\",\n                \"\",\n                \"Triple request error: service=\" + serviceName + \" method\" + methodName,\n                status.asException());\n    }\n\n    protected ServerCall.Listener startInternalCall(\n            RpcInvocation invocation, MethodDescriptor methodDescriptor, Invoker<?> invoker) {\n        this.cancellationContext = RpcContext.getCancellationContext();\n        ServerCallToObserverAdapter<Object> responseObserver =\n                new ServerCallToObserverAdapter<>(this, cancellationContext);\n        try {\n            ServerCall.Listener listener;\n            switch (methodDescriptor.getRpcType()) {\n                case UNARY:\n                    listener = new UnaryServerCallListener(\n                            invocation, invoker, responseObserver, packableMethod.needWrapper());\n                    request(2);\n                    break;\n                case SERVER_STREAM:\n                    listener = new ServerStreamServerCallListener(invocation, invoker, responseObserver);\n                    request(2);\n                    break;\n                case BI_STREAM:\n                case CLIENT_STREAM:\n                    listener = new BiStreamServerCallListener(invocation, invoker, responseObserver);\n                    request(1);\n                    break;\n                default:\n                    throw new IllegalStateException(\"Can not reach here\");\n            }\n            return listener;\n        } catch (Exception e) {\n            LOGGER.error(PROTOCOL_FAILED_CREATE_STREAM_TRIPLE, \"\", \"\", \"Create triple stream failed\", e);\n            responseErr(TriRpcStatus.INTERNAL\n                    .withDescription(\"Create stream failed\")\n                    .withCause(e));\n        }\n        return null;\n    }\n}\n",
        "methodName": null,
        "exampleID": 284,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java",
        "line": 376,
        "sink": "java.util.concurrent.TimeUnit.toMillis",
        "source": "-",
        "sourceLine": 376,
        "qualifier": "Call to java.util.concurrent.TimeUnit.toMillis with untrusted data from [msg : Http2StreamFrame](1).\nCall to java.util.concurrent.TimeUnit.toMillis with untrusted data from [msg : Object](2).",
        "line_number": 376,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 285
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 285
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 285
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 285
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java#L378",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.call;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.CancellationContext;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.RpcContext;\nimport org.apache.dubbo.rpc.RpcInvocation;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.model.MethodDescriptor;\nimport org.apache.dubbo.rpc.model.PackableMethod;\nimport org.apache.dubbo.rpc.model.ServiceDescriptor;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Compressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter;\nimport org.apache.dubbo.rpc.protocol.tri.stream.ServerStream;\nimport org.apache.dubbo.rpc.protocol.tri.stream.StreamUtils;\n\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.util.concurrent.Future;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_CREATE_STREAM_TRIPLE;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_PARSE;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_SERIALIZE_TRIPLE;\n\npublic abstract class AbstractServerCall implements ServerCall, ServerStream.Listener {\n\n    public static final String REMOTE_ADDRESS_KEY = \"tri.remote.address\";\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(AbstractServerCall.class);\n\n    public final Invoker<?> invoker;\n    public final FrameworkModel frameworkModel;\n    public final ServerStream stream;\n    public final Executor executor;\n    public final String methodName;\n    public final String serviceName;\n    public final ServiceDescriptor serviceDescriptor;\n    private final String acceptEncoding;\n    public boolean autoRequestN = true;\n    public Long timeout;\n    ServerCall.Listener listener;\n    private Compressor compressor;\n    private boolean headerSent;\n    private boolean closed;\n    CancellationContext cancellationContext;\n    protected MethodDescriptor methodDescriptor;\n    protected PackableMethod packableMethod;\n    protected Map<String, Object> requestMetadata;\n\n    private Integer exceptionCode = CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS;\n\n    public Integer getExceptionCode() {\n        return exceptionCode;\n    }\n\n    public void setExceptionCode(Integer exceptionCode) {\n        this.exceptionCode = exceptionCode;\n    }\n\n    private boolean isNeedReturnException = false;\n\n    public boolean isNeedReturnException() {\n        return isNeedReturnException;\n    }\n\n    public void setNeedReturnException(boolean needReturnException) {\n        isNeedReturnException = needReturnException;\n    }\n\n    AbstractServerCall(\n            Invoker<?> invoker,\n            ServerStream stream,\n            FrameworkModel frameworkModel,\n            ServiceDescriptor serviceDescriptor,\n            String acceptEncoding,\n            String serviceName,\n            String methodName,\n            Executor executor) {\n        Objects.requireNonNull(serviceDescriptor, \"No service descriptor found for \" + invoker.getUrl());\n        this.invoker = invoker;\n        // is already serialized in the stream, so we don't need to serialize it again.\n        this.executor = executor;\n        this.frameworkModel = frameworkModel;\n        this.serviceDescriptor = serviceDescriptor;\n        this.serviceName = serviceName;\n        this.methodName = methodName;\n        this.stream = stream;\n        this.acceptEncoding = acceptEncoding;\n    }\n\n    // stream listener start\n    @Override\n    public void onHeader(Map<String, Object> requestMetadata) {\n        this.requestMetadata = requestMetadata;\n        if (serviceDescriptor == null) {\n            responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n            return;\n        }\n        startCall();\n    }\n\n    protected void startCall() {\n        RpcInvocation invocation = buildInvocation(methodDescriptor);\n        listener = startInternalCall(invocation, methodDescriptor, invoker);\n    }\n\n    @Override\n    public final void request(int numMessages) {\n        stream.request(numMessages);\n    }\n\n    @Override\n    public final void sendMessage(Object message) {\n        if (closed) {\n            throw new IllegalStateException(\"Stream has already canceled\");\n        }\n        // is already in executor\n        doSendMessage(message);\n    }\n\n    private void doSendMessage(Object message) {\n        if (closed) {\n            return;\n        }\n        if (!headerSent) {\n            sendHeader();\n        }\n        final byte[] data;\n        try {\n            data = packableMethod.packResponse(message);\n        } catch (Exception e) {\n            close(\n                    TriRpcStatus.INTERNAL\n                            .withDescription(\"Serialize response failed\")\n                            .withCause(e),\n                    null);\n            LOGGER.error(\n                    PROTOCOL_FAILED_SERIALIZE_TRIPLE,\n                    \"\",\n                    \"\",\n                    String.format(\"Serialize triple response failed, service=%s method=%s\", serviceName, methodName),\n                    e);\n            return;\n        }\n        if (data == null) {\n            close(TriRpcStatus.INTERNAL.withDescription(\"Missing response\"), null);\n            return;\n        }\n        Future<?> future;\n        if (compressor != null) {\n            int compressedFlag = Identity.MESSAGE_ENCODING.equals(compressor.getMessageEncoding()) ? 0 : 1;\n            final byte[] compressed = compressor.compress(data);\n            future = stream.sendMessage(compressed, compressedFlag);\n        } else {\n            future = stream.sendMessage(data, 0);\n        }\n        future.addListener(f -> {\n            if (!f.isSuccess()) {\n                cancelDual(TriRpcStatus.CANCELLED\n                        .withDescription(\"Send message failed\")\n                        .withCause(f.cause()));\n            }\n        });\n    }\n\n    @Override\n    public final void onComplete() {\n        if (listener == null) {\n            // It will enter here when there is an error in the header\n            return;\n        }\n        // Both 'onError' and 'onComplete' are termination operators.\n        // The stream will be closed when 'onError' was called, and 'onComplete' is not allowed to be called again.\n        if (isClosed()) {\n            return;\n        }\n        listener.onComplete();\n    }\n\n    @Override\n    public final void onMessage(byte[] message, boolean isReturnTriException) {\n        ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n        try {\n            Object instance = parseSingleMessage(message);\n            listener.onMessage(instance, message.length);\n        } catch (Exception e) {\n            final TriRpcStatus status =\n                    TriRpcStatus.UNKNOWN.withDescription(\"Server error\").withCause(e);\n            close(status, null);\n            LOGGER.error(\n                    PROTOCOL_FAILED_REQUEST,\n                    \"\",\n                    \"\",\n                    \"Process request failed. service=\" + serviceName + \" method=\" + methodName,\n                    e);\n        } finally {\n            ClassLoadUtil.switchContextLoader(tccl);\n        }\n    }\n\n    protected abstract Object parseSingleMessage(byte[] data) throws Exception;\n\n    @Override\n    public final void onCancelByRemote(TriRpcStatus status) {\n        closed = true;\n        if (listener == null) {\n            return;\n        }\n        cancellationContext.cancel(status.cause);\n        listener.onCancel(status);\n    }\n    // stream listener end\n\n    public final boolean isClosed() {\n        return closed;\n    }\n\n    /**\n     * Build the RpcInvocation with metadata and execute headerFilter\n     *\n     * @return RpcInvocation\n     */\n    protected RpcInvocation buildInvocation(MethodDescriptor methodDescriptor) {\n        final URL url = invoker.getUrl();\n        RpcInvocation inv = new RpcInvocation(\n                url.getServiceModel(),\n                methodDescriptor.getMethodName(),\n                serviceDescriptor.getInterfaceName(),\n                url.getProtocolServiceKey(),\n                methodDescriptor.getParameterClasses(),\n                new Object[0]);\n        inv.setTargetServiceUniqueName(url.getServiceKey());\n        inv.setReturnTypes(methodDescriptor.getReturnTypes());\n        inv.setObjectAttachments(StreamUtils.toAttachments(requestMetadata));\n        inv.put(REMOTE_ADDRESS_KEY, stream.remoteAddress());\n        // handle timeout\n        String timeout = (String) requestMetadata.get(TripleHeaderEnum.TIMEOUT.getHeader());\n        try {\n            if (Objects.nonNull(timeout)) {\n                this.timeout = parseTimeoutToMills(timeout);\n            }\n        } catch (Throwable t) {\n            LOGGER.warn(\n                    PROTOCOL_FAILED_PARSE,\n                    \"\",\n                    \"\",\n                    String.format(\n                            \"Failed to parse request timeout set from:%s, service=%s \" + \"method=%s\",\n                            timeout, serviceDescriptor.getInterfaceName(), methodName));\n        }\n        if (null != requestMetadata.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader())) {\n            inv.put(\n                    TripleHeaderEnum.CONSUMER_APP_NAME_KEY,\n                    requestMetadata.get(TripleHeaderEnum.CONSUMER_APP_NAME_KEY.getHeader()));\n        }\n        return inv;\n    }\n\n    private void sendHeader() {\n        if (closed) {\n            return;\n        }\n        if (headerSent) {\n            throw new IllegalStateException(\"Header has already sent\");\n        }\n        headerSent = true;\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        headers.status(HttpResponseStatus.OK.codeAsText());\n        headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        if (acceptEncoding != null) {\n            headers.set(HttpHeaderNames.ACCEPT_ENCODING, acceptEncoding);\n        }\n        if (compressor != null) {\n            headers.set(TripleHeaderEnum.GRPC_ENCODING.getHeader(), compressor.getMessageEncoding());\n        }\n        if (!exceptionCode.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS)) {\n            headers.set(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader(), String.valueOf(exceptionCode));\n        }\n        // send header failed will reset stream and close request observer cause no more data will be sent\n        stream.sendHeader(headers).addListener(f -> {\n            if (!f.isSuccess()) {\n                cancelDual(TriRpcStatus.INTERNAL.withCause(f.cause()));\n            }\n        });\n    }\n\n    private void cancelDual(TriRpcStatus status) {\n        closed = true;\n        listener.onCancel(status);\n        cancellationContext.cancel(status.asException());\n    }\n\n    public void cancelByLocal(Throwable throwable) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        cancellationContext.cancel(throwable);\n        stream.cancelByLocal(TriRpcStatus.CANCELLED.withCause(throwable));\n    }\n\n    public void setCompression(String compression) {\n        if (headerSent) {\n            throw new IllegalStateException(\"Can not set compression after header sent\");\n        }\n        this.compressor = Compressor.getCompressor(frameworkModel, compression);\n    }\n\n    public void disableAutoRequestN() {\n        autoRequestN = false;\n    }\n\n    public boolean isAutoRequestN() {\n        return autoRequestN;\n    }\n\n    public void close(TriRpcStatus status, Map<String, Object> attachments) {\n        doClose(status, attachments);\n    }\n\n    private void doClose(TriRpcStatus status, Map<String, Object> attachments) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        stream.complete(status, attachments, isNeedReturnException, exceptionCode);\n    }\n\n    protected Long parseTimeoutToMills(String timeoutVal) {\n        if (StringUtils.isEmpty(timeoutVal) || StringUtils.isContains(timeoutVal, \"null\")) {\n            return null;\n        }\n        long value = Long.parseLong(timeoutVal.substring(0, timeoutVal.length() - 1));\n        char unit = timeoutVal.charAt(timeoutVal.length() - 1);\n        switch (unit) {\n            case 'n':\n                return TimeUnit.NANOSECONDS.toMillis(value);\n            case 'u':\n                return TimeUnit.MICROSECONDS.toMillis(value);\n            case 'm':\n                return value;\n            case 'S':\n                return TimeUnit.SECONDS.toMillis(value);\n            case 'M':\n                return TimeUnit.MINUTES.toMillis(value);\n            case 'H':\n                return TimeUnit.HOURS.toMillis(value);\n            default:\n                // invalid timeout config\n                return null;\n        }\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error.\n     *\n     * @param status response status\n     */\n    protected void responseErr(TriRpcStatus status) {\n        if (closed) {\n            return;\n        }\n        closed = true;\n        stream.complete(status, null, false, CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS);\n        LOGGER.error(\n                PROTOCOL_FAILED_REQUEST,\n                \"\",\n                \"\",\n                \"Triple request error: service=\" + serviceName + \" method\" + methodName,\n                status.asException());\n    }\n\n    protected ServerCall.Listener startInternalCall(\n            RpcInvocation invocation, MethodDescriptor methodDescriptor, Invoker<?> invoker) {\n        this.cancellationContext = RpcContext.getCancellationContext();\n        ServerCallToObserverAdapter<Object> responseObserver =\n                new ServerCallToObserverAdapter<>(this, cancellationContext);\n        try {\n            ServerCall.Listener listener;\n            switch (methodDescriptor.getRpcType()) {\n                case UNARY:\n                    listener = new UnaryServerCallListener(\n                            invocation, invoker, responseObserver, packableMethod.needWrapper());\n                    request(2);\n                    break;\n                case SERVER_STREAM:\n                    listener = new ServerStreamServerCallListener(invocation, invoker, responseObserver);\n                    request(2);\n                    break;\n                case BI_STREAM:\n                case CLIENT_STREAM:\n                    listener = new BiStreamServerCallListener(invocation, invoker, responseObserver);\n                    request(1);\n                    break;\n                default:\n                    throw new IllegalStateException(\"Can not reach here\");\n            }\n            return listener;\n        } catch (Exception e) {\n            LOGGER.error(PROTOCOL_FAILED_CREATE_STREAM_TRIPLE, \"\", \"\", \"Create triple stream failed\", e);\n            responseErr(TriRpcStatus.INTERNAL\n                    .withDescription(\"Create stream failed\")\n                    .withCause(e));\n        }\n        return null;\n    }\n}\n",
        "methodName": null,
        "exampleID": 286,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/call/AbstractServerCall.java",
        "line": 378,
        "sink": "java.util.concurrent.TimeUnit.toMillis",
        "source": "-",
        "sourceLine": 378,
        "qualifier": "Call to java.util.concurrent.TimeUnit.toMillis with untrusted data from [msg : Http2StreamFrame](1).\nCall to java.util.concurrent.TimeUnit.toMillis with untrusted data from [msg : Object](2).",
        "line_number": 378,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 287
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 287
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 287
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 287
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/compressor/DeCompressor.java#L35",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.compressor;\n\nimport org.apache.dubbo.common.extension.ExtensionScope;\nimport org.apache.dubbo.common.extension.SPI;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\n@SPI(scope = ExtensionScope.FRAMEWORK)\npublic interface DeCompressor extends MessageEncoding {\n\n    DeCompressor NONE = Identity.IDENTITY;\n\n    static DeCompressor getCompressor(FrameworkModel frameworkModel, String compressorStr) {\n        if (null == compressorStr) {\n            return null;\n        }\n        if (compressorStr.equals(Identity.MESSAGE_ENCODING)) {\n            return NONE;\n        }\n        return frameworkModel.getExtensionLoader(DeCompressor.class).getExtension(compressorStr);\n    }\n\n    /**\n     * decompress payload\n     *\n     * @param payloadByteArr payload byte array\n     * @return decompressed payload byte array\n     */\n    byte[] decompress(byte[] payloadByteArr);\n}\n",
        "methodName": null,
        "exampleID": 288,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/compressor/DeCompressor.java",
        "line": 35,
        "sink": "org.apache.dubbo.common.extension.ExtensionLoader<DeCompressor>.getExtension",
        "source": "-",
        "sourceLine": 35,
        "qualifier": "Call to org.apache.dubbo.common.extension.ExtensionLoader<DeCompressor>.getExtension with untrusted data from [msg : Http2StreamFrame](1).\nCall to org.apache.dubbo.common.extension.ExtensionLoader<DeCompressor>.getExtension with untrusted data from [msg : Object](2).",
        "line_number": 35,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 289
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 289
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 289
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/compressor/Snappy.java#L57",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.compressor;\n\nimport org.apache.dubbo.rpc.RpcException;\n\nimport java.io.IOException;\n\n/**\n * snappy compressor, Provide high-speed compression speed and reasonable compression ratio\n *\n * @link https://github.com/google/snappy\n */\npublic class Snappy implements Compressor, DeCompressor {\n\n    public static final String SNAPPY = \"snappy\";\n\n    @Override\n    public String getMessageEncoding() {\n        return SNAPPY;\n    }\n\n    @Override\n    public byte[] compress(byte[] payloadByteArr) throws RpcException {\n        if (null == payloadByteArr || 0 == payloadByteArr.length) {\n            return new byte[0];\n        }\n\n        try {\n            return org.xerial.snappy.Snappy.compress(payloadByteArr);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    @Override\n    public byte[] decompress(byte[] payloadByteArr) {\n        if (null == payloadByteArr || 0 == payloadByteArr.length) {\n            return new byte[0];\n        }\n\n        try {\n            return org.xerial.snappy.Snappy.uncompress(payloadByteArr);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 290,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/compressor/Snappy.java",
        "line": 57,
        "sink": "org.xerial.snappy.Snappy.uncompress",
        "source": "-",
        "sourceLine": 57,
        "qualifier": "Call to org.xerial.snappy.Snappy.uncompress with untrusted data from [msg : Http2StreamFrame](1).\nCall to org.xerial.snappy.Snappy.uncompress with untrusted data from [msg : Object](2).",
        "line_number": 57,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 291
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 291
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 291
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 291
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/TriDecoder.java#L110",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.frame;\n\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.CompositeByteBuf;\nimport io.netty.buffer.Unpooled;\n\npublic class TriDecoder implements Deframer {\n\n    private static final int HEADER_LENGTH = 5;\n    private static final int COMPRESSED_FLAG_MASK = 1;\n    private static final int RESERVED_MASK = 0xFE;\n    private final CompositeByteBuf accumulate = Unpooled.compositeBuffer();\n    private final Listener listener;\n    private final DeCompressor decompressor;\n    private boolean compressedFlag;\n    private long pendingDeliveries;\n    private boolean inDelivery = false;\n    private boolean closing;\n    private boolean closed;\n\n    private int requiredLength = HEADER_LENGTH;\n\n    private GrpcDecodeState state = GrpcDecodeState.HEADER;\n\n    public TriDecoder(DeCompressor decompressor, Listener listener) {\n        this.decompressor = decompressor;\n        this.listener = listener;\n    }\n\n    @Override\n    public void deframe(ByteBuf data) {\n        if (closing || closed) {\n            // ignored\n            return;\n        }\n        accumulate.addComponent(true, data);\n        deliver();\n    }\n\n    public void request(int numMessages) {\n        pendingDeliveries += numMessages;\n        deliver();\n    }\n\n    @Override\n    public void close() {\n        closing = true;\n        deliver();\n    }\n\n    private void deliver() {\n        // We can have reentrancy here when using a direct executor, triggered by calls to\n        // request more messages. This is safe as we simply loop until pendingDelivers = 0\n        if (inDelivery) {\n            return;\n        }\n        inDelivery = true;\n        try {\n            // Process the uncompressed bytes.\n            while (pendingDeliveries > 0 && hasEnoughBytes()) {\n                switch (state) {\n                    case HEADER:\n                        processHeader();\n                        break;\n                    case PAYLOAD:\n                        // Read the body and deliver the message.\n                        processBody();\n\n                        // Since we've delivered a message, decrement the number of pending\n                        // deliveries remaining.\n                        pendingDeliveries--;\n                        break;\n                    default:\n                        throw new AssertionError(\"Invalid state: \" + state);\n                }\n            }\n            if (closing) {\n                if (!closed) {\n                    closed = true;\n                    accumulate.clear();\n                    accumulate.release();\n                    listener.close();\n                }\n            }\n        } finally {\n            inDelivery = false;\n        }\n    }\n\n    private boolean hasEnoughBytes() {\n        return requiredLength - accumulate.readableBytes() <= 0;\n    }\n\n    /**\n     * Processes the GRPC compression header which is composed of the compression flag and the outer\n     * frame length.\n     */\n    private void processHeader() {\n        int type = accumulate.readUnsignedByte();\n        if ((type & RESERVED_MASK) != 0) {\n            throw new RpcException(\"gRPC frame header malformed: reserved bits not zero\");\n        }\n        compressedFlag = (type & COMPRESSED_FLAG_MASK) != 0;\n\n        requiredLength = accumulate.readInt();\n\n        // Continue reading the frame body.\n        state = GrpcDecodeState.PAYLOAD;\n    }\n\n    /**\n     * Processes the GRPC message body, which depending on frame header flags may be compressed.\n     */\n    private void processBody() {\n        // There is no reliable way to get the uncompressed size per message when it's compressed,\n        // because the uncompressed bytes are provided through an InputStream whose total size is\n        // unknown until all bytes are read, and we don't know when it happens.\n        byte[] stream = compressedFlag ? getCompressedBody() : getUncompressedBody();\n\n        listener.onRawMessage(stream);\n\n        // Done with this frame, begin processing the next header.\n        state = GrpcDecodeState.HEADER;\n        requiredLength = HEADER_LENGTH;\n    }\n\n    private byte[] getCompressedBody() {\n        final byte[] compressedBody = getUncompressedBody();\n        return decompressor.decompress(compressedBody);\n    }\n\n    private byte[] getUncompressedBody() {\n        byte[] data = new byte[requiredLength];\n        accumulate.readBytes(data);\n        accumulate.discardReadComponents();\n        return data;\n    }\n\n    private enum GrpcDecodeState {\n        HEADER,\n        PAYLOAD\n    }\n\n    public interface Listener {\n\n        void onRawMessage(byte[] data);\n\n        void close();\n    }\n}\n",
        "methodName": null,
        "exampleID": 292,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/TriDecoder.java",
        "line": 110,
        "sink": "io.netty.buffer.AbstractByteBuf.readableBytes",
        "source": "-",
        "sourceLine": 110,
        "qualifier": "Call to io.netty.buffer.AbstractByteBuf.readableBytes with untrusted data from [msg : Http2StreamFrame](1).\nCall to io.netty.buffer.AbstractByteBuf.readableBytes with untrusted data from [msg : Object](2).",
        "line_number": 110,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 293
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 293
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 293
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 293
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/TriDecoder.java#L124",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.frame;\n\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.CompositeByteBuf;\nimport io.netty.buffer.Unpooled;\n\npublic class TriDecoder implements Deframer {\n\n    private static final int HEADER_LENGTH = 5;\n    private static final int COMPRESSED_FLAG_MASK = 1;\n    private static final int RESERVED_MASK = 0xFE;\n    private final CompositeByteBuf accumulate = Unpooled.compositeBuffer();\n    private final Listener listener;\n    private final DeCompressor decompressor;\n    private boolean compressedFlag;\n    private long pendingDeliveries;\n    private boolean inDelivery = false;\n    private boolean closing;\n    private boolean closed;\n\n    private int requiredLength = HEADER_LENGTH;\n\n    private GrpcDecodeState state = GrpcDecodeState.HEADER;\n\n    public TriDecoder(DeCompressor decompressor, Listener listener) {\n        this.decompressor = decompressor;\n        this.listener = listener;\n    }\n\n    @Override\n    public void deframe(ByteBuf data) {\n        if (closing || closed) {\n            // ignored\n            return;\n        }\n        accumulate.addComponent(true, data);\n        deliver();\n    }\n\n    public void request(int numMessages) {\n        pendingDeliveries += numMessages;\n        deliver();\n    }\n\n    @Override\n    public void close() {\n        closing = true;\n        deliver();\n    }\n\n    private void deliver() {\n        // We can have reentrancy here when using a direct executor, triggered by calls to\n        // request more messages. This is safe as we simply loop until pendingDelivers = 0\n        if (inDelivery) {\n            return;\n        }\n        inDelivery = true;\n        try {\n            // Process the uncompressed bytes.\n            while (pendingDeliveries > 0 && hasEnoughBytes()) {\n                switch (state) {\n                    case HEADER:\n                        processHeader();\n                        break;\n                    case PAYLOAD:\n                        // Read the body and deliver the message.\n                        processBody();\n\n                        // Since we've delivered a message, decrement the number of pending\n                        // deliveries remaining.\n                        pendingDeliveries--;\n                        break;\n                    default:\n                        throw new AssertionError(\"Invalid state: \" + state);\n                }\n            }\n            if (closing) {\n                if (!closed) {\n                    closed = true;\n                    accumulate.clear();\n                    accumulate.release();\n                    listener.close();\n                }\n            }\n        } finally {\n            inDelivery = false;\n        }\n    }\n\n    private boolean hasEnoughBytes() {\n        return requiredLength - accumulate.readableBytes() <= 0;\n    }\n\n    /**\n     * Processes the GRPC compression header which is composed of the compression flag and the outer\n     * frame length.\n     */\n    private void processHeader() {\n        int type = accumulate.readUnsignedByte();\n        if ((type & RESERVED_MASK) != 0) {\n            throw new RpcException(\"gRPC frame header malformed: reserved bits not zero\");\n        }\n        compressedFlag = (type & COMPRESSED_FLAG_MASK) != 0;\n\n        requiredLength = accumulate.readInt();\n\n        // Continue reading the frame body.\n        state = GrpcDecodeState.PAYLOAD;\n    }\n\n    /**\n     * Processes the GRPC message body, which depending on frame header flags may be compressed.\n     */\n    private void processBody() {\n        // There is no reliable way to get the uncompressed size per message when it's compressed,\n        // because the uncompressed bytes are provided through an InputStream whose total size is\n        // unknown until all bytes are read, and we don't know when it happens.\n        byte[] stream = compressedFlag ? getCompressedBody() : getUncompressedBody();\n\n        listener.onRawMessage(stream);\n\n        // Done with this frame, begin processing the next header.\n        state = GrpcDecodeState.HEADER;\n        requiredLength = HEADER_LENGTH;\n    }\n\n    private byte[] getCompressedBody() {\n        final byte[] compressedBody = getUncompressedBody();\n        return decompressor.decompress(compressedBody);\n    }\n\n    private byte[] getUncompressedBody() {\n        byte[] data = new byte[requiredLength];\n        accumulate.readBytes(data);\n        accumulate.discardReadComponents();\n        return data;\n    }\n\n    private enum GrpcDecodeState {\n        HEADER,\n        PAYLOAD\n    }\n\n    public interface Listener {\n\n        void onRawMessage(byte[] data);\n\n        void close();\n    }\n}\n",
        "methodName": null,
        "exampleID": 294,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/TriDecoder.java",
        "line": 124,
        "sink": "io.netty.buffer.AbstractByteBuf.readInt",
        "source": "-",
        "sourceLine": 124,
        "qualifier": "Call to io.netty.buffer.AbstractByteBuf.readInt with untrusted data from [msg : Http2StreamFrame](1).\nCall to io.netty.buffer.AbstractByteBuf.readInt with untrusted data from [msg : Object](2).",
        "line_number": 124,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 295
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 295
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 295
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 295
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/TriDecoder.java#L154",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.frame;\n\nimport org.apache.dubbo.rpc.RpcException;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.CompositeByteBuf;\nimport io.netty.buffer.Unpooled;\n\npublic class TriDecoder implements Deframer {\n\n    private static final int HEADER_LENGTH = 5;\n    private static final int COMPRESSED_FLAG_MASK = 1;\n    private static final int RESERVED_MASK = 0xFE;\n    private final CompositeByteBuf accumulate = Unpooled.compositeBuffer();\n    private final Listener listener;\n    private final DeCompressor decompressor;\n    private boolean compressedFlag;\n    private long pendingDeliveries;\n    private boolean inDelivery = false;\n    private boolean closing;\n    private boolean closed;\n\n    private int requiredLength = HEADER_LENGTH;\n\n    private GrpcDecodeState state = GrpcDecodeState.HEADER;\n\n    public TriDecoder(DeCompressor decompressor, Listener listener) {\n        this.decompressor = decompressor;\n        this.listener = listener;\n    }\n\n    @Override\n    public void deframe(ByteBuf data) {\n        if (closing || closed) {\n            // ignored\n            return;\n        }\n        accumulate.addComponent(true, data);\n        deliver();\n    }\n\n    public void request(int numMessages) {\n        pendingDeliveries += numMessages;\n        deliver();\n    }\n\n    @Override\n    public void close() {\n        closing = true;\n        deliver();\n    }\n\n    private void deliver() {\n        // We can have reentrancy here when using a direct executor, triggered by calls to\n        // request more messages. This is safe as we simply loop until pendingDelivers = 0\n        if (inDelivery) {\n            return;\n        }\n        inDelivery = true;\n        try {\n            // Process the uncompressed bytes.\n            while (pendingDeliveries > 0 && hasEnoughBytes()) {\n                switch (state) {\n                    case HEADER:\n                        processHeader();\n                        break;\n                    case PAYLOAD:\n                        // Read the body and deliver the message.\n                        processBody();\n\n                        // Since we've delivered a message, decrement the number of pending\n                        // deliveries remaining.\n                        pendingDeliveries--;\n                        break;\n                    default:\n                        throw new AssertionError(\"Invalid state: \" + state);\n                }\n            }\n            if (closing) {\n                if (!closed) {\n                    closed = true;\n                    accumulate.clear();\n                    accumulate.release();\n                    listener.close();\n                }\n            }\n        } finally {\n            inDelivery = false;\n        }\n    }\n\n    private boolean hasEnoughBytes() {\n        return requiredLength - accumulate.readableBytes() <= 0;\n    }\n\n    /**\n     * Processes the GRPC compression header which is composed of the compression flag and the outer\n     * frame length.\n     */\n    private void processHeader() {\n        int type = accumulate.readUnsignedByte();\n        if ((type & RESERVED_MASK) != 0) {\n            throw new RpcException(\"gRPC frame header malformed: reserved bits not zero\");\n        }\n        compressedFlag = (type & COMPRESSED_FLAG_MASK) != 0;\n\n        requiredLength = accumulate.readInt();\n\n        // Continue reading the frame body.\n        state = GrpcDecodeState.PAYLOAD;\n    }\n\n    /**\n     * Processes the GRPC message body, which depending on frame header flags may be compressed.\n     */\n    private void processBody() {\n        // There is no reliable way to get the uncompressed size per message when it's compressed,\n        // because the uncompressed bytes are provided through an InputStream whose total size is\n        // unknown until all bytes are read, and we don't know when it happens.\n        byte[] stream = compressedFlag ? getCompressedBody() : getUncompressedBody();\n\n        listener.onRawMessage(stream);\n\n        // Done with this frame, begin processing the next header.\n        state = GrpcDecodeState.HEADER;\n        requiredLength = HEADER_LENGTH;\n    }\n\n    private byte[] getCompressedBody() {\n        final byte[] compressedBody = getUncompressedBody();\n        return decompressor.decompress(compressedBody);\n    }\n\n    private byte[] getUncompressedBody() {\n        byte[] data = new byte[requiredLength];\n        accumulate.readBytes(data);\n        accumulate.discardReadComponents();\n        return data;\n    }\n\n    private enum GrpcDecodeState {\n        HEADER,\n        PAYLOAD\n    }\n\n    public interface Listener {\n\n        void onRawMessage(byte[] data);\n\n        void close();\n    }\n}\n",
        "methodName": null,
        "exampleID": 296,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/frame/TriDecoder.java",
        "line": 154,
        "sink": "io.netty.buffer.CompositeByteBuf.discardReadComponents",
        "source": "-",
        "sourceLine": 154,
        "qualifier": "Call to io.netty.buffer.CompositeByteBuf.discardReadComponents with untrusted data from [msg : Http2StreamFrame](1).\nCall to io.netty.buffer.CompositeByteBuf.discardReadComponents with untrusted data from [msg : Object](2).",
        "line_number": 154,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 297
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 297
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 297
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 297
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java#L253",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.CreateStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.EndStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2ClientResponseHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\nimport org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.ErrorInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\nimport io.netty.util.ReferenceCountUtil;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_RESPONSE;\n\n/**\n * ClientStream is an abstraction for bi-directional messaging. It maintains a {@link WriteQueue} to\n * write Http2Frame to remote. A {@link H2TransportListener} receives Http2Frame from remote.\n * Instead of maintaining state, this class depends on upper layer or transport layer's states.\n */\npublic class TripleClientStream extends AbstractStream implements ClientStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleClientStream.class);\n\n    public final ClientStream.Listener listener;\n    private final TripleWriteQueue writeQueue;\n    private Deframer deframer;\n    private final Channel parent;\n    private final TripleStreamChannelFuture streamChannelFuture;\n    private boolean halfClosed;\n    private boolean rst;\n\n    private boolean isReturnTriException = false;\n\n    // for test\n    TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            TripleWriteQueue writeQueue,\n            ClientStream.Listener listener,\n            Http2StreamChannel http2StreamChannel) {\n        super(executor, frameworkModel);\n        this.parent = http2StreamChannel.parent();\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(http2StreamChannel);\n    }\n\n    public TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            Channel parent,\n            ClientStream.Listener listener,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.parent = parent;\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(parent);\n    }\n\n    private TripleStreamChannelFuture initHttp2StreamChannel(Channel parent) {\n        TripleStreamChannelFuture streamChannelFuture = new TripleStreamChannelFuture(parent);\n        Http2StreamChannelBootstrap bootstrap = new Http2StreamChannelBootstrap(parent);\n        bootstrap.handler(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n                Channel channel = ctx.channel();\n                channel.pipeline().addLast(new TripleCommandOutBoundHandler());\n                channel.pipeline().addLast(new TripleHttp2ClientResponseHandler(createTransportListener()));\n            }\n        });\n        CreateStreamQueueCommand cmd = CreateStreamQueueCommand.create(bootstrap, streamChannelFuture);\n        this.writeQueue.enqueue(cmd);\n        return streamChannelFuture;\n    }\n\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (this.writeQueue == null) {\n            // already processed at createStream()\n            return parent.newFailedFuture(new IllegalStateException(\"Stream already closed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final HeaderQueueCommand headerCmd = HeaderQueueCommand.createHeaders(streamChannelFuture, headers);\n        return writeQueue.enqueueFuture(headerCmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                transportException(future.cause());\n            }\n        });\n    }\n\n    private void transportException(Throwable cause) {\n        final TriRpcStatus status =\n                TriRpcStatus.INTERNAL.withDescription(\"Http2 exception\").withCause(cause);\n        listener.onComplete(status, null, null, false);\n    }\n\n    public ChannelFuture cancelByLocal(TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final CancelQueueCommand cmd = CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL);\n\n        TripleClientStream.this.rst = true;\n        return this.writeQueue.enqueue(cmd);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return parent.remoteAddress();\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag, boolean eos) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final DataQueueCommand cmd = DataQueueCommand.create(streamChannelFuture, message, false, compressFlag);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                cancelByLocal(TriRpcStatus.INTERNAL\n                        .withDescription(\"Client write message failed\")\n                        .withCause(future.cause()));\n                transportException(future.cause());\n            }\n        });\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    @Override\n    public ChannelFuture halfClose() {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final EndStreamQueueCommand cmd = EndStreamQueueCommand.create(streamChannelFuture);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (future.isSuccess()) {\n                halfClosed = true;\n            }\n        });\n    }\n\n    private ChannelFuture preCheck() {\n        if (rst) {\n            return streamChannelFuture.getNow().newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return parent.newSucceededFuture();\n    }\n\n    /**\n     * @return transport listener\n     */\n    H2TransportListener createTransportListener() {\n        return new ClientTransportListener();\n    }\n\n    class ClientTransportListener extends AbstractH2TransportListener implements H2TransportListener {\n\n        private TriRpcStatus transportError;\n        private DeCompressor decompressor;\n        private boolean headerReceived;\n        private Http2Headers trailers;\n\n        void handleH2TransportError(TriRpcStatus status) {\n            writeQueue.enqueue(CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.NO_ERROR));\n            TripleClientStream.this.rst = true;\n            finishProcess(status, null, false);\n        }\n\n        void finishProcess(TriRpcStatus status, Http2Headers trailers, boolean isReturnTriException) {\n            final Map<String, String> reserved = filterReservedHeaders(trailers);\n            final Map<String, Object> attachments =\n                    headersToMap(trailers, () -> reserved.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()));\n            final TriRpcStatus detailStatus;\n            final TriRpcStatus statusFromTrailers = getStatusFromTrailers(reserved);\n            if (statusFromTrailers != null) {\n                detailStatus = statusFromTrailers;\n            } else {\n                detailStatus = status;\n            }\n            listener.onComplete(detailStatus, attachments, reserved, isReturnTriException);\n        }\n\n        private TriRpcStatus validateHeaderStatus(Http2Headers headers) {\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n            if (httpStatus == null) {\n                return TriRpcStatus.INTERNAL.withDescription(\"Missing HTTP status code\");\n            }\n            final CharSequence contentType = headers.get(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader());\n            if (contentType == null\n                    || !contentType.toString().startsWith(TripleHeaderEnum.APPLICATION_GRPC.getHeader())) {\n                return TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus))\n                        .withDescription(\"invalid content-type: \" + contentType);\n            }\n            return null;\n        }\n\n        void onHeaderReceived(Http2Headers headers) {\n            if (transportError != null) {\n                transportError.appendDescription(\"headers:\" + headers);\n                return;\n            }\n            if (headerReceived) {\n                transportError = TriRpcStatus.INTERNAL.withDescription(\"Received headers twice\");\n                return;\n            }\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n\n            if (httpStatus != null && Integer.parseInt(httpStatus.toString()) > 100 && httpStatus < 200) {\n                // ignored\n                return;\n            }\n            headerReceived = true;\n            transportError = validateHeaderStatus(headers);\n\n            // todo support full payload compressor\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            CharSequence triExceptionCode = headers.get(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader());\n            if (triExceptionCode != null) {\n                Integer triExceptionCodeNum = Integer.parseInt(triExceptionCode.toString());\n                if (!(triExceptionCodeNum.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS))) {\n                    isReturnTriException = true;\n                }\n            }\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.IDENTITY.getMessageEncoding().equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        throw TriRpcStatus.UNIMPLEMENTED\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr))\n                                .asException();\n                    } else {\n                        decompressor = compressor;\n                    }\n                }\n            }\n            TriDecoder.Listener listener = new TriDecoder.Listener() {\n                @Override\n                public void onRawMessage(byte[] data) {\n                    TripleClientStream.this.listener.onMessage(data, isReturnTriException);\n                }\n\n                public void close() {\n                    finishProcess(statusFromTrailers(trailers), trailers, isReturnTriException);\n                }\n            };\n            deframer = new TriDecoder(decompressor, listener);\n            TripleClientStream.this.listener.onStart();\n        }\n\n        void onTrailersReceived(Http2Headers trailers) {\n            if (transportError == null && !headerReceived) {\n                transportError = validateHeaderStatus(trailers);\n            }\n            if (transportError != null) {\n                transportError = transportError.appendDescription(\"trailers: \" + trailers);\n            } else {\n                this.trailers = trailers;\n                TriRpcStatus status = statusFromTrailers(trailers);\n                if (deframer == null) {\n                    finishProcess(status, trailers, false);\n                }\n                if (deframer != null) {\n                    deframer.close();\n                }\n            }\n        }\n\n        /**\n         * Extract the response status from trailers.\n         */\n        private TriRpcStatus statusFromTrailers(Http2Headers trailers) {\n            final Integer intStatus = trailers.getInt(TripleHeaderEnum.STATUS_KEY.getHeader());\n            TriRpcStatus status = intStatus == null ? null : TriRpcStatus.fromCode(intStatus);\n            if (status != null) {\n                final CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());\n                if (message != null) {\n                    final String description = TriRpcStatus.decodeMessage(message.toString());\n                    status = status.withDescription(description);\n                }\n                return status;\n            }\n            // No status; something is broken. Try to provide a rational error.\n            if (headerReceived) {\n                return TriRpcStatus.UNKNOWN.withDescription(\"missing GRPC status in response\");\n            }\n            Integer httpStatus = trailers.status() == null\n                    ? null\n                    : Integer.parseInt(trailers.status().toString());\n            if (httpStatus != null) {\n                status = TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus));\n            } else {\n                status = TriRpcStatus.INTERNAL.withDescription(\"missing HTTP status code\");\n            }\n            return status.appendDescription(\"missing GRPC status, inferred error from HTTP status code\");\n        }\n\n        private TriRpcStatus getStatusFromTrailers(Map<String, String> metadata) {\n            if (null == metadata) {\n                return null;\n            }\n            if (!getGrpcStatusDetailEnabled()) {\n                return null;\n            }\n            // second get status detail\n            if (!metadata.containsKey(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader())) {\n                return null;\n            }\n            final String raw = (metadata.remove(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader()));\n            byte[] statusDetailBin = StreamUtils.decodeASCIIByte(raw);\n            ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n            try {\n                final Status statusDetail = Status.parseFrom(statusDetailBin);\n                List<Any> detailList = statusDetail.getDetailsList();\n                Map<Class<?>, Object> classObjectMap = tranFromStatusDetails(detailList);\n\n                // get common exception from DebugInfo\n                TriRpcStatus status = TriRpcStatus.fromCode(statusDetail.getCode())\n                        .withDescription(TriRpcStatus.decodeMessage(statusDetail.getMessage()));\n                DebugInfo debugInfo = (DebugInfo) classObjectMap.get(DebugInfo.class);\n                if (debugInfo != null) {\n                    String msg = ExceptionUtils.getStackFrameString(debugInfo.getStackEntriesList());\n                    status = status.appendDescription(msg);\n                }\n                return status;\n            } catch (IOException ioException) {\n                return null;\n            } finally {\n                ClassLoadUtil.switchContextLoader(tccl);\n            }\n        }\n\n        private Map<Class<?>, Object> tranFromStatusDetails(List<Any> detailList) {\n            Map<Class<?>, Object> map = new HashMap<>(detailList.size());\n            try {\n                for (Any any : detailList) {\n                    if (any.is(ErrorInfo.class)) {\n                        ErrorInfo errorInfo = any.unpack(ErrorInfo.class);\n                        map.putIfAbsent(ErrorInfo.class, errorInfo);\n                    } else if (any.is(DebugInfo.class)) {\n                        DebugInfo debugInfo = any.unpack(DebugInfo.class);\n                        map.putIfAbsent(DebugInfo.class, debugInfo);\n                    }\n                    // support others type but now only support this\n                }\n            } catch (Throwable t) {\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"tran from grpc-status-details error\", t);\n            }\n            return map;\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> {\n                if (endStream) {\n                    if (!halfClosed) {\n                        Http2StreamChannel channel = streamChannelFuture.getNow();\n                        if (channel.isActive() && !rst) {\n                            writeQueue.enqueue(\n                                    CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL));\n                            rst = true;\n                        }\n                    }\n                    onTrailersReceived(headers);\n                } else {\n                    onHeaderReceived(headers);\n                }\n            });\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (transportError != null) {\n                transportError.appendDescription(\"Data:\" + data.toString(StandardCharsets.UTF_8));\n                ReferenceCountUtil.release(data);\n                if (transportError.description.length() > 512 || endStream) {\n                    handleH2TransportError(transportError);\n                }\n                return;\n            }\n            if (!headerReceived) {\n                handleH2TransportError(TriRpcStatus.INTERNAL.withDescription(\"headers not received before payload\"));\n                return;\n            }\n            deframer.deframe(data);\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            executor.execute(() -> {\n                transportError =\n                        TriRpcStatus.CANCELLED.withDescription(\"Canceled by remote peer, errorCode=\" + errorCode);\n                finishProcess(transportError, null, false);\n            });\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 298,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java",
        "line": 253,
        "sink": "io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get",
        "source": "-",
        "sourceLine": 253,
        "qualifier": "Call to io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get with untrusted data from [msg : Http2StreamFrame](1).",
        "line_number": 253,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 299
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 299
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleGoAwayHandler.java#L45",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.transport;\n\nimport org.apache.dubbo.common.logger.Logger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.remoting.Constants;\nimport org.apache.dubbo.remoting.api.connection.ConnectionHandler;\n\nimport io.netty.channel.ChannelDuplexHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.http2.Http2GoAwayFrame;\nimport io.netty.util.ReferenceCountUtil;\n\npublic class TripleGoAwayHandler extends ChannelDuplexHandler {\n\n    private static final Logger logger = LoggerFactory.getLogger(TripleGoAwayHandler.class);\n\n    public TripleGoAwayHandler() {}\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        if (msg instanceof Http2GoAwayFrame) {\n            final ConnectionHandler connectionHandler =\n                    (ConnectionHandler) ctx.pipeline().get(Constants.CONNECTION_HANDLER_NAME);\n            if (logger.isInfoEnabled()) {\n                logger.info(\"Receive go away frame of \" + ctx.channel().localAddress() + \" -> \"\n                        + ctx.channel().remoteAddress() + \" and will reconnect later.\");\n            }\n            connectionHandler.onGoAway(ctx.channel());\n            ReferenceCountUtil.release(msg);\n            return;\n        }\n        super.channelRead(ctx, msg);\n    }\n}\n",
        "methodName": null,
        "exampleID": 300,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleGoAwayHandler.java",
        "line": 45,
        "sink": "io.netty.util.ReferenceCountUtil.release",
        "source": "-",
        "sourceLine": 45,
        "qualifier": "Call to io.netty.util.ReferenceCountUtil.release with untrusted data from [msg : Object](1).",
        "line_number": 45,
        "steps": [
            {
                "line": 36,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleGoAwayHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleGoAwayHandler.java",
                "methodName": null,
                "exampleID": 301
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java#L67",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.transport;\n\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.TriRpcStatus;\n\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.SimpleChannelInboundHandler;\nimport io.netty.handler.codec.http2.Http2DataFrame;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2GoAwayFrame;\nimport io.netty.handler.codec.http2.Http2HeadersFrame;\nimport io.netty.handler.codec.http2.Http2ResetFrame;\nimport io.netty.handler.codec.http2.Http2StreamFrame;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_SERIALIZE_TRIPLE;\n\npublic final class TripleHttp2ClientResponseHandler extends SimpleChannelInboundHandler<Http2StreamFrame> {\n\n    private static final ErrorTypeAwareLogger LOGGER =\n            LoggerFactory.getErrorTypeAwareLogger(TripleHttp2ClientResponseHandler.class);\n    private final H2TransportListener transportListener;\n\n    public TripleHttp2ClientResponseHandler(H2TransportListener listener) {\n        super(false);\n        this.transportListener = listener;\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        super.userEventTriggered(ctx, evt);\n        if (evt instanceof Http2GoAwayFrame) {\n            Http2GoAwayFrame event = (Http2GoAwayFrame) evt;\n            ctx.close();\n            LOGGER.debug(\n                    \"Event triggered, event name is: \" + event.name() + \", last stream id is: \" + event.lastStreamId());\n        } else if (evt instanceof Http2ResetFrame) {\n            onResetRead(ctx, (Http2ResetFrame) evt);\n        }\n    }\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, Http2StreamFrame msg) throws Exception {\n        if (msg instanceof Http2HeadersFrame) {\n            final Http2HeadersFrame headers = (Http2HeadersFrame) msg;\n            transportListener.onHeader(headers.headers(), headers.isEndStream());\n        } else if (msg instanceof Http2DataFrame) {\n            final Http2DataFrame data = (Http2DataFrame) msg;\n            transportListener.onData(data.content(), data.isEndStream());\n        } else {\n            super.channelRead(ctx, msg);\n        }\n    }\n\n    private void onResetRead(ChannelHandlerContext ctx, Http2ResetFrame resetFrame) {\n        LOGGER.warn(\n                PROTOCOL_FAILED_SERIALIZE_TRIPLE,\n                \"\",\n                \"\",\n                \"Triple Client received remote reset errorCode=\" + resetFrame.errorCode());\n        transportListener.cancelByRemote(resetFrame.errorCode());\n        ctx.close();\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) {\n        ctx.close();\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n        final TriRpcStatus status = TriRpcStatus.INTERNAL.withCause(cause);\n        LOGGER.warn(\n                PROTOCOL_FAILED_SERIALIZE_TRIPLE,\n                \"\",\n                \"\",\n                \"Meet Exception on ClientResponseHandler, status code is: \" + status.code,\n                cause);\n        transportListener.cancelByRemote(Http2Error.INTERNAL_ERROR.code());\n        ctx.close();\n    }\n}\n",
        "methodName": null,
        "exampleID": 302,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
        "line": 67,
        "sink": "io.netty.channel.SimpleChannelInboundHandler<Http2StreamFrame>.channelRead",
        "source": "-",
        "sourceLine": 67,
        "qualifier": "Call to io.netty.channel.SimpleChannelInboundHandler<Http2StreamFrame>.channelRead with untrusted data from [msg : Http2StreamFrame](1).",
        "line_number": 67,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 303
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java#L284",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.CreateStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.EndStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2ClientResponseHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\nimport org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.ErrorInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\nimport io.netty.util.ReferenceCountUtil;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_RESPONSE;\n\n/**\n * ClientStream is an abstraction for bi-directional messaging. It maintains a {@link WriteQueue} to\n * write Http2Frame to remote. A {@link H2TransportListener} receives Http2Frame from remote.\n * Instead of maintaining state, this class depends on upper layer or transport layer's states.\n */\npublic class TripleClientStream extends AbstractStream implements ClientStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleClientStream.class);\n\n    public final ClientStream.Listener listener;\n    private final TripleWriteQueue writeQueue;\n    private Deframer deframer;\n    private final Channel parent;\n    private final TripleStreamChannelFuture streamChannelFuture;\n    private boolean halfClosed;\n    private boolean rst;\n\n    private boolean isReturnTriException = false;\n\n    // for test\n    TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            TripleWriteQueue writeQueue,\n            ClientStream.Listener listener,\n            Http2StreamChannel http2StreamChannel) {\n        super(executor, frameworkModel);\n        this.parent = http2StreamChannel.parent();\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(http2StreamChannel);\n    }\n\n    public TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            Channel parent,\n            ClientStream.Listener listener,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.parent = parent;\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(parent);\n    }\n\n    private TripleStreamChannelFuture initHttp2StreamChannel(Channel parent) {\n        TripleStreamChannelFuture streamChannelFuture = new TripleStreamChannelFuture(parent);\n        Http2StreamChannelBootstrap bootstrap = new Http2StreamChannelBootstrap(parent);\n        bootstrap.handler(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n                Channel channel = ctx.channel();\n                channel.pipeline().addLast(new TripleCommandOutBoundHandler());\n                channel.pipeline().addLast(new TripleHttp2ClientResponseHandler(createTransportListener()));\n            }\n        });\n        CreateStreamQueueCommand cmd = CreateStreamQueueCommand.create(bootstrap, streamChannelFuture);\n        this.writeQueue.enqueue(cmd);\n        return streamChannelFuture;\n    }\n\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (this.writeQueue == null) {\n            // already processed at createStream()\n            return parent.newFailedFuture(new IllegalStateException(\"Stream already closed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final HeaderQueueCommand headerCmd = HeaderQueueCommand.createHeaders(streamChannelFuture, headers);\n        return writeQueue.enqueueFuture(headerCmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                transportException(future.cause());\n            }\n        });\n    }\n\n    private void transportException(Throwable cause) {\n        final TriRpcStatus status =\n                TriRpcStatus.INTERNAL.withDescription(\"Http2 exception\").withCause(cause);\n        listener.onComplete(status, null, null, false);\n    }\n\n    public ChannelFuture cancelByLocal(TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final CancelQueueCommand cmd = CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL);\n\n        TripleClientStream.this.rst = true;\n        return this.writeQueue.enqueue(cmd);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return parent.remoteAddress();\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag, boolean eos) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final DataQueueCommand cmd = DataQueueCommand.create(streamChannelFuture, message, false, compressFlag);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                cancelByLocal(TriRpcStatus.INTERNAL\n                        .withDescription(\"Client write message failed\")\n                        .withCause(future.cause()));\n                transportException(future.cause());\n            }\n        });\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    @Override\n    public ChannelFuture halfClose() {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final EndStreamQueueCommand cmd = EndStreamQueueCommand.create(streamChannelFuture);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (future.isSuccess()) {\n                halfClosed = true;\n            }\n        });\n    }\n\n    private ChannelFuture preCheck() {\n        if (rst) {\n            return streamChannelFuture.getNow().newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return parent.newSucceededFuture();\n    }\n\n    /**\n     * @return transport listener\n     */\n    H2TransportListener createTransportListener() {\n        return new ClientTransportListener();\n    }\n\n    class ClientTransportListener extends AbstractH2TransportListener implements H2TransportListener {\n\n        private TriRpcStatus transportError;\n        private DeCompressor decompressor;\n        private boolean headerReceived;\n        private Http2Headers trailers;\n\n        void handleH2TransportError(TriRpcStatus status) {\n            writeQueue.enqueue(CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.NO_ERROR));\n            TripleClientStream.this.rst = true;\n            finishProcess(status, null, false);\n        }\n\n        void finishProcess(TriRpcStatus status, Http2Headers trailers, boolean isReturnTriException) {\n            final Map<String, String> reserved = filterReservedHeaders(trailers);\n            final Map<String, Object> attachments =\n                    headersToMap(trailers, () -> reserved.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()));\n            final TriRpcStatus detailStatus;\n            final TriRpcStatus statusFromTrailers = getStatusFromTrailers(reserved);\n            if (statusFromTrailers != null) {\n                detailStatus = statusFromTrailers;\n            } else {\n                detailStatus = status;\n            }\n            listener.onComplete(detailStatus, attachments, reserved, isReturnTriException);\n        }\n\n        private TriRpcStatus validateHeaderStatus(Http2Headers headers) {\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n            if (httpStatus == null) {\n                return TriRpcStatus.INTERNAL.withDescription(\"Missing HTTP status code\");\n            }\n            final CharSequence contentType = headers.get(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader());\n            if (contentType == null\n                    || !contentType.toString().startsWith(TripleHeaderEnum.APPLICATION_GRPC.getHeader())) {\n                return TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus))\n                        .withDescription(\"invalid content-type: \" + contentType);\n            }\n            return null;\n        }\n\n        void onHeaderReceived(Http2Headers headers) {\n            if (transportError != null) {\n                transportError.appendDescription(\"headers:\" + headers);\n                return;\n            }\n            if (headerReceived) {\n                transportError = TriRpcStatus.INTERNAL.withDescription(\"Received headers twice\");\n                return;\n            }\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n\n            if (httpStatus != null && Integer.parseInt(httpStatus.toString()) > 100 && httpStatus < 200) {\n                // ignored\n                return;\n            }\n            headerReceived = true;\n            transportError = validateHeaderStatus(headers);\n\n            // todo support full payload compressor\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            CharSequence triExceptionCode = headers.get(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader());\n            if (triExceptionCode != null) {\n                Integer triExceptionCodeNum = Integer.parseInt(triExceptionCode.toString());\n                if (!(triExceptionCodeNum.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS))) {\n                    isReturnTriException = true;\n                }\n            }\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.IDENTITY.getMessageEncoding().equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        throw TriRpcStatus.UNIMPLEMENTED\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr))\n                                .asException();\n                    } else {\n                        decompressor = compressor;\n                    }\n                }\n            }\n            TriDecoder.Listener listener = new TriDecoder.Listener() {\n                @Override\n                public void onRawMessage(byte[] data) {\n                    TripleClientStream.this.listener.onMessage(data, isReturnTriException);\n                }\n\n                public void close() {\n                    finishProcess(statusFromTrailers(trailers), trailers, isReturnTriException);\n                }\n            };\n            deframer = new TriDecoder(decompressor, listener);\n            TripleClientStream.this.listener.onStart();\n        }\n\n        void onTrailersReceived(Http2Headers trailers) {\n            if (transportError == null && !headerReceived) {\n                transportError = validateHeaderStatus(trailers);\n            }\n            if (transportError != null) {\n                transportError = transportError.appendDescription(\"trailers: \" + trailers);\n            } else {\n                this.trailers = trailers;\n                TriRpcStatus status = statusFromTrailers(trailers);\n                if (deframer == null) {\n                    finishProcess(status, trailers, false);\n                }\n                if (deframer != null) {\n                    deframer.close();\n                }\n            }\n        }\n\n        /**\n         * Extract the response status from trailers.\n         */\n        private TriRpcStatus statusFromTrailers(Http2Headers trailers) {\n            final Integer intStatus = trailers.getInt(TripleHeaderEnum.STATUS_KEY.getHeader());\n            TriRpcStatus status = intStatus == null ? null : TriRpcStatus.fromCode(intStatus);\n            if (status != null) {\n                final CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());\n                if (message != null) {\n                    final String description = TriRpcStatus.decodeMessage(message.toString());\n                    status = status.withDescription(description);\n                }\n                return status;\n            }\n            // No status; something is broken. Try to provide a rational error.\n            if (headerReceived) {\n                return TriRpcStatus.UNKNOWN.withDescription(\"missing GRPC status in response\");\n            }\n            Integer httpStatus = trailers.status() == null\n                    ? null\n                    : Integer.parseInt(trailers.status().toString());\n            if (httpStatus != null) {\n                status = TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus));\n            } else {\n                status = TriRpcStatus.INTERNAL.withDescription(\"missing HTTP status code\");\n            }\n            return status.appendDescription(\"missing GRPC status, inferred error from HTTP status code\");\n        }\n\n        private TriRpcStatus getStatusFromTrailers(Map<String, String> metadata) {\n            if (null == metadata) {\n                return null;\n            }\n            if (!getGrpcStatusDetailEnabled()) {\n                return null;\n            }\n            // second get status detail\n            if (!metadata.containsKey(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader())) {\n                return null;\n            }\n            final String raw = (metadata.remove(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader()));\n            byte[] statusDetailBin = StreamUtils.decodeASCIIByte(raw);\n            ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n            try {\n                final Status statusDetail = Status.parseFrom(statusDetailBin);\n                List<Any> detailList = statusDetail.getDetailsList();\n                Map<Class<?>, Object> classObjectMap = tranFromStatusDetails(detailList);\n\n                // get common exception from DebugInfo\n                TriRpcStatus status = TriRpcStatus.fromCode(statusDetail.getCode())\n                        .withDescription(TriRpcStatus.decodeMessage(statusDetail.getMessage()));\n                DebugInfo debugInfo = (DebugInfo) classObjectMap.get(DebugInfo.class);\n                if (debugInfo != null) {\n                    String msg = ExceptionUtils.getStackFrameString(debugInfo.getStackEntriesList());\n                    status = status.appendDescription(msg);\n                }\n                return status;\n            } catch (IOException ioException) {\n                return null;\n            } finally {\n                ClassLoadUtil.switchContextLoader(tccl);\n            }\n        }\n\n        private Map<Class<?>, Object> tranFromStatusDetails(List<Any> detailList) {\n            Map<Class<?>, Object> map = new HashMap<>(detailList.size());\n            try {\n                for (Any any : detailList) {\n                    if (any.is(ErrorInfo.class)) {\n                        ErrorInfo errorInfo = any.unpack(ErrorInfo.class);\n                        map.putIfAbsent(ErrorInfo.class, errorInfo);\n                    } else if (any.is(DebugInfo.class)) {\n                        DebugInfo debugInfo = any.unpack(DebugInfo.class);\n                        map.putIfAbsent(DebugInfo.class, debugInfo);\n                    }\n                    // support others type but now only support this\n                }\n            } catch (Throwable t) {\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"tran from grpc-status-details error\", t);\n            }\n            return map;\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> {\n                if (endStream) {\n                    if (!halfClosed) {\n                        Http2StreamChannel channel = streamChannelFuture.getNow();\n                        if (channel.isActive() && !rst) {\n                            writeQueue.enqueue(\n                                    CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL));\n                            rst = true;\n                        }\n                    }\n                    onTrailersReceived(headers);\n                } else {\n                    onHeaderReceived(headers);\n                }\n            });\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (transportError != null) {\n                transportError.appendDescription(\"Data:\" + data.toString(StandardCharsets.UTF_8));\n                ReferenceCountUtil.release(data);\n                if (transportError.description.length() > 512 || endStream) {\n                    handleH2TransportError(transportError);\n                }\n                return;\n            }\n            if (!headerReceived) {\n                handleH2TransportError(TriRpcStatus.INTERNAL.withDescription(\"headers not received before payload\"));\n                return;\n            }\n            deframer.deframe(data);\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            executor.execute(() -> {\n                transportError =\n                        TriRpcStatus.CANCELLED.withDescription(\"Canceled by remote peer, errorCode=\" + errorCode);\n                finishProcess(transportError, null, false);\n            });\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 304,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java",
        "line": 284,
        "sink": "io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get",
        "source": "-",
        "sourceLine": 284,
        "qualifier": "Call to io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get with untrusted data from [msg : Http2StreamFrame](1).",
        "line_number": 284,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 305
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java#L356",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.CreateStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.EndStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2ClientResponseHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\nimport org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.ErrorInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\nimport io.netty.util.ReferenceCountUtil;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_RESPONSE;\n\n/**\n * ClientStream is an abstraction for bi-directional messaging. It maintains a {@link WriteQueue} to\n * write Http2Frame to remote. A {@link H2TransportListener} receives Http2Frame from remote.\n * Instead of maintaining state, this class depends on upper layer or transport layer's states.\n */\npublic class TripleClientStream extends AbstractStream implements ClientStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleClientStream.class);\n\n    public final ClientStream.Listener listener;\n    private final TripleWriteQueue writeQueue;\n    private Deframer deframer;\n    private final Channel parent;\n    private final TripleStreamChannelFuture streamChannelFuture;\n    private boolean halfClosed;\n    private boolean rst;\n\n    private boolean isReturnTriException = false;\n\n    // for test\n    TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            TripleWriteQueue writeQueue,\n            ClientStream.Listener listener,\n            Http2StreamChannel http2StreamChannel) {\n        super(executor, frameworkModel);\n        this.parent = http2StreamChannel.parent();\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(http2StreamChannel);\n    }\n\n    public TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            Channel parent,\n            ClientStream.Listener listener,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.parent = parent;\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(parent);\n    }\n\n    private TripleStreamChannelFuture initHttp2StreamChannel(Channel parent) {\n        TripleStreamChannelFuture streamChannelFuture = new TripleStreamChannelFuture(parent);\n        Http2StreamChannelBootstrap bootstrap = new Http2StreamChannelBootstrap(parent);\n        bootstrap.handler(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n                Channel channel = ctx.channel();\n                channel.pipeline().addLast(new TripleCommandOutBoundHandler());\n                channel.pipeline().addLast(new TripleHttp2ClientResponseHandler(createTransportListener()));\n            }\n        });\n        CreateStreamQueueCommand cmd = CreateStreamQueueCommand.create(bootstrap, streamChannelFuture);\n        this.writeQueue.enqueue(cmd);\n        return streamChannelFuture;\n    }\n\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (this.writeQueue == null) {\n            // already processed at createStream()\n            return parent.newFailedFuture(new IllegalStateException(\"Stream already closed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final HeaderQueueCommand headerCmd = HeaderQueueCommand.createHeaders(streamChannelFuture, headers);\n        return writeQueue.enqueueFuture(headerCmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                transportException(future.cause());\n            }\n        });\n    }\n\n    private void transportException(Throwable cause) {\n        final TriRpcStatus status =\n                TriRpcStatus.INTERNAL.withDescription(\"Http2 exception\").withCause(cause);\n        listener.onComplete(status, null, null, false);\n    }\n\n    public ChannelFuture cancelByLocal(TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final CancelQueueCommand cmd = CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL);\n\n        TripleClientStream.this.rst = true;\n        return this.writeQueue.enqueue(cmd);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return parent.remoteAddress();\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag, boolean eos) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final DataQueueCommand cmd = DataQueueCommand.create(streamChannelFuture, message, false, compressFlag);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                cancelByLocal(TriRpcStatus.INTERNAL\n                        .withDescription(\"Client write message failed\")\n                        .withCause(future.cause()));\n                transportException(future.cause());\n            }\n        });\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    @Override\n    public ChannelFuture halfClose() {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final EndStreamQueueCommand cmd = EndStreamQueueCommand.create(streamChannelFuture);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (future.isSuccess()) {\n                halfClosed = true;\n            }\n        });\n    }\n\n    private ChannelFuture preCheck() {\n        if (rst) {\n            return streamChannelFuture.getNow().newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return parent.newSucceededFuture();\n    }\n\n    /**\n     * @return transport listener\n     */\n    H2TransportListener createTransportListener() {\n        return new ClientTransportListener();\n    }\n\n    class ClientTransportListener extends AbstractH2TransportListener implements H2TransportListener {\n\n        private TriRpcStatus transportError;\n        private DeCompressor decompressor;\n        private boolean headerReceived;\n        private Http2Headers trailers;\n\n        void handleH2TransportError(TriRpcStatus status) {\n            writeQueue.enqueue(CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.NO_ERROR));\n            TripleClientStream.this.rst = true;\n            finishProcess(status, null, false);\n        }\n\n        void finishProcess(TriRpcStatus status, Http2Headers trailers, boolean isReturnTriException) {\n            final Map<String, String> reserved = filterReservedHeaders(trailers);\n            final Map<String, Object> attachments =\n                    headersToMap(trailers, () -> reserved.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()));\n            final TriRpcStatus detailStatus;\n            final TriRpcStatus statusFromTrailers = getStatusFromTrailers(reserved);\n            if (statusFromTrailers != null) {\n                detailStatus = statusFromTrailers;\n            } else {\n                detailStatus = status;\n            }\n            listener.onComplete(detailStatus, attachments, reserved, isReturnTriException);\n        }\n\n        private TriRpcStatus validateHeaderStatus(Http2Headers headers) {\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n            if (httpStatus == null) {\n                return TriRpcStatus.INTERNAL.withDescription(\"Missing HTTP status code\");\n            }\n            final CharSequence contentType = headers.get(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader());\n            if (contentType == null\n                    || !contentType.toString().startsWith(TripleHeaderEnum.APPLICATION_GRPC.getHeader())) {\n                return TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus))\n                        .withDescription(\"invalid content-type: \" + contentType);\n            }\n            return null;\n        }\n\n        void onHeaderReceived(Http2Headers headers) {\n            if (transportError != null) {\n                transportError.appendDescription(\"headers:\" + headers);\n                return;\n            }\n            if (headerReceived) {\n                transportError = TriRpcStatus.INTERNAL.withDescription(\"Received headers twice\");\n                return;\n            }\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n\n            if (httpStatus != null && Integer.parseInt(httpStatus.toString()) > 100 && httpStatus < 200) {\n                // ignored\n                return;\n            }\n            headerReceived = true;\n            transportError = validateHeaderStatus(headers);\n\n            // todo support full payload compressor\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            CharSequence triExceptionCode = headers.get(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader());\n            if (triExceptionCode != null) {\n                Integer triExceptionCodeNum = Integer.parseInt(triExceptionCode.toString());\n                if (!(triExceptionCodeNum.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS))) {\n                    isReturnTriException = true;\n                }\n            }\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.IDENTITY.getMessageEncoding().equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        throw TriRpcStatus.UNIMPLEMENTED\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr))\n                                .asException();\n                    } else {\n                        decompressor = compressor;\n                    }\n                }\n            }\n            TriDecoder.Listener listener = new TriDecoder.Listener() {\n                @Override\n                public void onRawMessage(byte[] data) {\n                    TripleClientStream.this.listener.onMessage(data, isReturnTriException);\n                }\n\n                public void close() {\n                    finishProcess(statusFromTrailers(trailers), trailers, isReturnTriException);\n                }\n            };\n            deframer = new TriDecoder(decompressor, listener);\n            TripleClientStream.this.listener.onStart();\n        }\n\n        void onTrailersReceived(Http2Headers trailers) {\n            if (transportError == null && !headerReceived) {\n                transportError = validateHeaderStatus(trailers);\n            }\n            if (transportError != null) {\n                transportError = transportError.appendDescription(\"trailers: \" + trailers);\n            } else {\n                this.trailers = trailers;\n                TriRpcStatus status = statusFromTrailers(trailers);\n                if (deframer == null) {\n                    finishProcess(status, trailers, false);\n                }\n                if (deframer != null) {\n                    deframer.close();\n                }\n            }\n        }\n\n        /**\n         * Extract the response status from trailers.\n         */\n        private TriRpcStatus statusFromTrailers(Http2Headers trailers) {\n            final Integer intStatus = trailers.getInt(TripleHeaderEnum.STATUS_KEY.getHeader());\n            TriRpcStatus status = intStatus == null ? null : TriRpcStatus.fromCode(intStatus);\n            if (status != null) {\n                final CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());\n                if (message != null) {\n                    final String description = TriRpcStatus.decodeMessage(message.toString());\n                    status = status.withDescription(description);\n                }\n                return status;\n            }\n            // No status; something is broken. Try to provide a rational error.\n            if (headerReceived) {\n                return TriRpcStatus.UNKNOWN.withDescription(\"missing GRPC status in response\");\n            }\n            Integer httpStatus = trailers.status() == null\n                    ? null\n                    : Integer.parseInt(trailers.status().toString());\n            if (httpStatus != null) {\n                status = TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus));\n            } else {\n                status = TriRpcStatus.INTERNAL.withDescription(\"missing HTTP status code\");\n            }\n            return status.appendDescription(\"missing GRPC status, inferred error from HTTP status code\");\n        }\n\n        private TriRpcStatus getStatusFromTrailers(Map<String, String> metadata) {\n            if (null == metadata) {\n                return null;\n            }\n            if (!getGrpcStatusDetailEnabled()) {\n                return null;\n            }\n            // second get status detail\n            if (!metadata.containsKey(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader())) {\n                return null;\n            }\n            final String raw = (metadata.remove(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader()));\n            byte[] statusDetailBin = StreamUtils.decodeASCIIByte(raw);\n            ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n            try {\n                final Status statusDetail = Status.parseFrom(statusDetailBin);\n                List<Any> detailList = statusDetail.getDetailsList();\n                Map<Class<?>, Object> classObjectMap = tranFromStatusDetails(detailList);\n\n                // get common exception from DebugInfo\n                TriRpcStatus status = TriRpcStatus.fromCode(statusDetail.getCode())\n                        .withDescription(TriRpcStatus.decodeMessage(statusDetail.getMessage()));\n                DebugInfo debugInfo = (DebugInfo) classObjectMap.get(DebugInfo.class);\n                if (debugInfo != null) {\n                    String msg = ExceptionUtils.getStackFrameString(debugInfo.getStackEntriesList());\n                    status = status.appendDescription(msg);\n                }\n                return status;\n            } catch (IOException ioException) {\n                return null;\n            } finally {\n                ClassLoadUtil.switchContextLoader(tccl);\n            }\n        }\n\n        private Map<Class<?>, Object> tranFromStatusDetails(List<Any> detailList) {\n            Map<Class<?>, Object> map = new HashMap<>(detailList.size());\n            try {\n                for (Any any : detailList) {\n                    if (any.is(ErrorInfo.class)) {\n                        ErrorInfo errorInfo = any.unpack(ErrorInfo.class);\n                        map.putIfAbsent(ErrorInfo.class, errorInfo);\n                    } else if (any.is(DebugInfo.class)) {\n                        DebugInfo debugInfo = any.unpack(DebugInfo.class);\n                        map.putIfAbsent(DebugInfo.class, debugInfo);\n                    }\n                    // support others type but now only support this\n                }\n            } catch (Throwable t) {\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"tran from grpc-status-details error\", t);\n            }\n            return map;\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> {\n                if (endStream) {\n                    if (!halfClosed) {\n                        Http2StreamChannel channel = streamChannelFuture.getNow();\n                        if (channel.isActive() && !rst) {\n                            writeQueue.enqueue(\n                                    CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL));\n                            rst = true;\n                        }\n                    }\n                    onTrailersReceived(headers);\n                } else {\n                    onHeaderReceived(headers);\n                }\n            });\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (transportError != null) {\n                transportError.appendDescription(\"Data:\" + data.toString(StandardCharsets.UTF_8));\n                ReferenceCountUtil.release(data);\n                if (transportError.description.length() > 512 || endStream) {\n                    handleH2TransportError(transportError);\n                }\n                return;\n            }\n            if (!headerReceived) {\n                handleH2TransportError(TriRpcStatus.INTERNAL.withDescription(\"headers not received before payload\"));\n                return;\n            }\n            deframer.deframe(data);\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            executor.execute(() -> {\n                transportError =\n                        TriRpcStatus.CANCELLED.withDescription(\"Canceled by remote peer, errorCode=\" + errorCode);\n                finishProcess(transportError, null, false);\n            });\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 306,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java",
        "line": 356,
        "sink": "io.netty.handler.codec.http2.Http2Headers.status",
        "source": "-",
        "sourceLine": 356,
        "qualifier": "Call to io.netty.handler.codec.http2.Http2Headers.status with untrusted data from [msg : Http2StreamFrame](1).",
        "line_number": 356,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 307
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java#L343",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.CreateStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.EndStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2ClientResponseHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\nimport org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.ErrorInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\nimport io.netty.util.ReferenceCountUtil;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_RESPONSE;\n\n/**\n * ClientStream is an abstraction for bi-directional messaging. It maintains a {@link WriteQueue} to\n * write Http2Frame to remote. A {@link H2TransportListener} receives Http2Frame from remote.\n * Instead of maintaining state, this class depends on upper layer or transport layer's states.\n */\npublic class TripleClientStream extends AbstractStream implements ClientStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleClientStream.class);\n\n    public final ClientStream.Listener listener;\n    private final TripleWriteQueue writeQueue;\n    private Deframer deframer;\n    private final Channel parent;\n    private final TripleStreamChannelFuture streamChannelFuture;\n    private boolean halfClosed;\n    private boolean rst;\n\n    private boolean isReturnTriException = false;\n\n    // for test\n    TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            TripleWriteQueue writeQueue,\n            ClientStream.Listener listener,\n            Http2StreamChannel http2StreamChannel) {\n        super(executor, frameworkModel);\n        this.parent = http2StreamChannel.parent();\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(http2StreamChannel);\n    }\n\n    public TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            Channel parent,\n            ClientStream.Listener listener,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.parent = parent;\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(parent);\n    }\n\n    private TripleStreamChannelFuture initHttp2StreamChannel(Channel parent) {\n        TripleStreamChannelFuture streamChannelFuture = new TripleStreamChannelFuture(parent);\n        Http2StreamChannelBootstrap bootstrap = new Http2StreamChannelBootstrap(parent);\n        bootstrap.handler(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n                Channel channel = ctx.channel();\n                channel.pipeline().addLast(new TripleCommandOutBoundHandler());\n                channel.pipeline().addLast(new TripleHttp2ClientResponseHandler(createTransportListener()));\n            }\n        });\n        CreateStreamQueueCommand cmd = CreateStreamQueueCommand.create(bootstrap, streamChannelFuture);\n        this.writeQueue.enqueue(cmd);\n        return streamChannelFuture;\n    }\n\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (this.writeQueue == null) {\n            // already processed at createStream()\n            return parent.newFailedFuture(new IllegalStateException(\"Stream already closed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final HeaderQueueCommand headerCmd = HeaderQueueCommand.createHeaders(streamChannelFuture, headers);\n        return writeQueue.enqueueFuture(headerCmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                transportException(future.cause());\n            }\n        });\n    }\n\n    private void transportException(Throwable cause) {\n        final TriRpcStatus status =\n                TriRpcStatus.INTERNAL.withDescription(\"Http2 exception\").withCause(cause);\n        listener.onComplete(status, null, null, false);\n    }\n\n    public ChannelFuture cancelByLocal(TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final CancelQueueCommand cmd = CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL);\n\n        TripleClientStream.this.rst = true;\n        return this.writeQueue.enqueue(cmd);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return parent.remoteAddress();\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag, boolean eos) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final DataQueueCommand cmd = DataQueueCommand.create(streamChannelFuture, message, false, compressFlag);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                cancelByLocal(TriRpcStatus.INTERNAL\n                        .withDescription(\"Client write message failed\")\n                        .withCause(future.cause()));\n                transportException(future.cause());\n            }\n        });\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    @Override\n    public ChannelFuture halfClose() {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final EndStreamQueueCommand cmd = EndStreamQueueCommand.create(streamChannelFuture);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (future.isSuccess()) {\n                halfClosed = true;\n            }\n        });\n    }\n\n    private ChannelFuture preCheck() {\n        if (rst) {\n            return streamChannelFuture.getNow().newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return parent.newSucceededFuture();\n    }\n\n    /**\n     * @return transport listener\n     */\n    H2TransportListener createTransportListener() {\n        return new ClientTransportListener();\n    }\n\n    class ClientTransportListener extends AbstractH2TransportListener implements H2TransportListener {\n\n        private TriRpcStatus transportError;\n        private DeCompressor decompressor;\n        private boolean headerReceived;\n        private Http2Headers trailers;\n\n        void handleH2TransportError(TriRpcStatus status) {\n            writeQueue.enqueue(CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.NO_ERROR));\n            TripleClientStream.this.rst = true;\n            finishProcess(status, null, false);\n        }\n\n        void finishProcess(TriRpcStatus status, Http2Headers trailers, boolean isReturnTriException) {\n            final Map<String, String> reserved = filterReservedHeaders(trailers);\n            final Map<String, Object> attachments =\n                    headersToMap(trailers, () -> reserved.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()));\n            final TriRpcStatus detailStatus;\n            final TriRpcStatus statusFromTrailers = getStatusFromTrailers(reserved);\n            if (statusFromTrailers != null) {\n                detailStatus = statusFromTrailers;\n            } else {\n                detailStatus = status;\n            }\n            listener.onComplete(detailStatus, attachments, reserved, isReturnTriException);\n        }\n\n        private TriRpcStatus validateHeaderStatus(Http2Headers headers) {\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n            if (httpStatus == null) {\n                return TriRpcStatus.INTERNAL.withDescription(\"Missing HTTP status code\");\n            }\n            final CharSequence contentType = headers.get(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader());\n            if (contentType == null\n                    || !contentType.toString().startsWith(TripleHeaderEnum.APPLICATION_GRPC.getHeader())) {\n                return TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus))\n                        .withDescription(\"invalid content-type: \" + contentType);\n            }\n            return null;\n        }\n\n        void onHeaderReceived(Http2Headers headers) {\n            if (transportError != null) {\n                transportError.appendDescription(\"headers:\" + headers);\n                return;\n            }\n            if (headerReceived) {\n                transportError = TriRpcStatus.INTERNAL.withDescription(\"Received headers twice\");\n                return;\n            }\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n\n            if (httpStatus != null && Integer.parseInt(httpStatus.toString()) > 100 && httpStatus < 200) {\n                // ignored\n                return;\n            }\n            headerReceived = true;\n            transportError = validateHeaderStatus(headers);\n\n            // todo support full payload compressor\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            CharSequence triExceptionCode = headers.get(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader());\n            if (triExceptionCode != null) {\n                Integer triExceptionCodeNum = Integer.parseInt(triExceptionCode.toString());\n                if (!(triExceptionCodeNum.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS))) {\n                    isReturnTriException = true;\n                }\n            }\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.IDENTITY.getMessageEncoding().equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        throw TriRpcStatus.UNIMPLEMENTED\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr))\n                                .asException();\n                    } else {\n                        decompressor = compressor;\n                    }\n                }\n            }\n            TriDecoder.Listener listener = new TriDecoder.Listener() {\n                @Override\n                public void onRawMessage(byte[] data) {\n                    TripleClientStream.this.listener.onMessage(data, isReturnTriException);\n                }\n\n                public void close() {\n                    finishProcess(statusFromTrailers(trailers), trailers, isReturnTriException);\n                }\n            };\n            deframer = new TriDecoder(decompressor, listener);\n            TripleClientStream.this.listener.onStart();\n        }\n\n        void onTrailersReceived(Http2Headers trailers) {\n            if (transportError == null && !headerReceived) {\n                transportError = validateHeaderStatus(trailers);\n            }\n            if (transportError != null) {\n                transportError = transportError.appendDescription(\"trailers: \" + trailers);\n            } else {\n                this.trailers = trailers;\n                TriRpcStatus status = statusFromTrailers(trailers);\n                if (deframer == null) {\n                    finishProcess(status, trailers, false);\n                }\n                if (deframer != null) {\n                    deframer.close();\n                }\n            }\n        }\n\n        /**\n         * Extract the response status from trailers.\n         */\n        private TriRpcStatus statusFromTrailers(Http2Headers trailers) {\n            final Integer intStatus = trailers.getInt(TripleHeaderEnum.STATUS_KEY.getHeader());\n            TriRpcStatus status = intStatus == null ? null : TriRpcStatus.fromCode(intStatus);\n            if (status != null) {\n                final CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());\n                if (message != null) {\n                    final String description = TriRpcStatus.decodeMessage(message.toString());\n                    status = status.withDescription(description);\n                }\n                return status;\n            }\n            // No status; something is broken. Try to provide a rational error.\n            if (headerReceived) {\n                return TriRpcStatus.UNKNOWN.withDescription(\"missing GRPC status in response\");\n            }\n            Integer httpStatus = trailers.status() == null\n                    ? null\n                    : Integer.parseInt(trailers.status().toString());\n            if (httpStatus != null) {\n                status = TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus));\n            } else {\n                status = TriRpcStatus.INTERNAL.withDescription(\"missing HTTP status code\");\n            }\n            return status.appendDescription(\"missing GRPC status, inferred error from HTTP status code\");\n        }\n\n        private TriRpcStatus getStatusFromTrailers(Map<String, String> metadata) {\n            if (null == metadata) {\n                return null;\n            }\n            if (!getGrpcStatusDetailEnabled()) {\n                return null;\n            }\n            // second get status detail\n            if (!metadata.containsKey(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader())) {\n                return null;\n            }\n            final String raw = (metadata.remove(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader()));\n            byte[] statusDetailBin = StreamUtils.decodeASCIIByte(raw);\n            ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n            try {\n                final Status statusDetail = Status.parseFrom(statusDetailBin);\n                List<Any> detailList = statusDetail.getDetailsList();\n                Map<Class<?>, Object> classObjectMap = tranFromStatusDetails(detailList);\n\n                // get common exception from DebugInfo\n                TriRpcStatus status = TriRpcStatus.fromCode(statusDetail.getCode())\n                        .withDescription(TriRpcStatus.decodeMessage(statusDetail.getMessage()));\n                DebugInfo debugInfo = (DebugInfo) classObjectMap.get(DebugInfo.class);\n                if (debugInfo != null) {\n                    String msg = ExceptionUtils.getStackFrameString(debugInfo.getStackEntriesList());\n                    status = status.appendDescription(msg);\n                }\n                return status;\n            } catch (IOException ioException) {\n                return null;\n            } finally {\n                ClassLoadUtil.switchContextLoader(tccl);\n            }\n        }\n\n        private Map<Class<?>, Object> tranFromStatusDetails(List<Any> detailList) {\n            Map<Class<?>, Object> map = new HashMap<>(detailList.size());\n            try {\n                for (Any any : detailList) {\n                    if (any.is(ErrorInfo.class)) {\n                        ErrorInfo errorInfo = any.unpack(ErrorInfo.class);\n                        map.putIfAbsent(ErrorInfo.class, errorInfo);\n                    } else if (any.is(DebugInfo.class)) {\n                        DebugInfo debugInfo = any.unpack(DebugInfo.class);\n                        map.putIfAbsent(DebugInfo.class, debugInfo);\n                    }\n                    // support others type but now only support this\n                }\n            } catch (Throwable t) {\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"tran from grpc-status-details error\", t);\n            }\n            return map;\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> {\n                if (endStream) {\n                    if (!halfClosed) {\n                        Http2StreamChannel channel = streamChannelFuture.getNow();\n                        if (channel.isActive() && !rst) {\n                            writeQueue.enqueue(\n                                    CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL));\n                            rst = true;\n                        }\n                    }\n                    onTrailersReceived(headers);\n                } else {\n                    onHeaderReceived(headers);\n                }\n            });\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (transportError != null) {\n                transportError.appendDescription(\"Data:\" + data.toString(StandardCharsets.UTF_8));\n                ReferenceCountUtil.release(data);\n                if (transportError.description.length() > 512 || endStream) {\n                    handleH2TransportError(transportError);\n                }\n                return;\n            }\n            if (!headerReceived) {\n                handleH2TransportError(TriRpcStatus.INTERNAL.withDescription(\"headers not received before payload\"));\n                return;\n            }\n            deframer.deframe(data);\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            executor.execute(() -> {\n                transportError =\n                        TriRpcStatus.CANCELLED.withDescription(\"Canceled by remote peer, errorCode=\" + errorCode);\n                finishProcess(transportError, null, false);\n            });\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 308,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java",
        "line": 343,
        "sink": "io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get",
        "source": "-",
        "sourceLine": 343,
        "qualifier": "Call to io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get with untrusted data from [msg : Http2StreamFrame](1).",
        "line_number": 343,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 309
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java#L76",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.transport;\n\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.HeaderFilter;\nimport org.apache.dubbo.rpc.PathResolver;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.executor.ExecutorSupport;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.stream.TripleServerStream;\n\nimport java.util.List;\nimport java.util.concurrent.Executor;\n\nimport io.netty.channel.ChannelDuplexHandler;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.http2.Http2DataFrame;\nimport io.netty.handler.codec.http2.Http2HeadersFrame;\nimport io.netty.handler.codec.http2.Http2ResetFrame;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.ReferenceCounted;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_RESPONSE;\n\npublic class TripleHttp2FrameServerHandler extends ChannelDuplexHandler {\n\n    private static final ErrorTypeAwareLogger LOGGER =\n            LoggerFactory.getErrorTypeAwareLogger(TripleHttp2FrameServerHandler.class);\n    private final PathResolver pathResolver;\n    private final ExecutorSupport executorSupport;\n    private final String acceptEncoding;\n    private final TripleServerStream tripleServerStream;\n\n    public TripleHttp2FrameServerHandler(\n            FrameworkModel frameworkModel,\n            ExecutorSupport executorSupport,\n            List<HeaderFilter> filters,\n            Http2StreamChannel channel,\n            TripleWriteQueue writeQueue) {\n        this.executorSupport = executorSupport;\n        this.acceptEncoding = String.join(\n                \",\", frameworkModel.getExtensionLoader(DeCompressor.class).getSupportedExtensions());\n        this.pathResolver =\n                frameworkModel.getExtensionLoader(PathResolver.class).getDefaultExtension();\n        // The executor will be assigned in onHeadersRead method\n        tripleServerStream = new TripleServerStream(\n                channel, frameworkModel, null, pathResolver, acceptEncoding, filters, writeQueue);\n    }\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        if (msg instanceof Http2HeadersFrame) {\n            onHeadersRead(ctx, (Http2HeadersFrame) msg);\n        } else if (msg instanceof Http2DataFrame) {\n            onDataRead(ctx, (Http2DataFrame) msg);\n        } else if (msg instanceof ReferenceCounted) {\n            // ignored\n            ReferenceCountUtil.release(msg);\n        }\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        if (evt instanceof Http2ResetFrame) {\n            onResetRead(ctx, (Http2ResetFrame) evt);\n        } else {\n            super.userEventTriggered(ctx, evt);\n        }\n    }\n\n    public void onResetRead(ChannelHandlerContext ctx, Http2ResetFrame frame) {\n        LOGGER.warn(\n                PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"Triple Server received remote reset errorCode=\" + frame.errorCode());\n        if (tripleServerStream != null) {\n            tripleServerStream.transportObserver.cancelByRemote(frame.errorCode());\n        }\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        if (LOGGER.isWarnEnabled()) {\n            LOGGER.warn(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"Exception in processing triple message\", cause);\n        }\n        TriRpcStatus status = TriRpcStatus.getStatus(cause, \"Provider's error:\\n\" + cause.getMessage());\n        tripleServerStream.cancelByLocal(status);\n    }\n\n    public void onDataRead(ChannelHandlerContext ctx, Http2DataFrame msg) throws Exception {\n        tripleServerStream.transportObserver.onData(msg.content(), msg.isEndStream());\n    }\n\n    public void onHeadersRead(ChannelHandlerContext ctx, Http2HeadersFrame msg) throws Exception {\n        Executor executor = executorSupport.getExecutor(msg.headers());\n        tripleServerStream.setExecutor(executor);\n        tripleServerStream.transportObserver.onHeader(msg.headers(), msg.isEndStream());\n    }\n}\n",
        "methodName": null,
        "exampleID": 310,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
        "line": 76,
        "sink": "io.netty.util.ReferenceCountUtil.release",
        "source": "-",
        "sourceLine": 76,
        "qualifier": "Call to io.netty.util.ReferenceCountUtil.release with untrusted data from [msg : Object](1).",
        "line_number": 76,
        "steps": [
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 311
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/AbstractH2TransportListener.java#L104",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.transport;\n\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.JsonUtils;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.stream.StreamUtils;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\nimport io.netty.handler.codec.http2.Http2Headers;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.INTERNAL_ERROR;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_PARSE;\n\npublic abstract class AbstractH2TransportListener implements H2TransportListener {\n\n    private static final ErrorTypeAwareLogger LOGGER =\n            LoggerFactory.getErrorTypeAwareLogger(AbstractH2TransportListener.class);\n\n    /**\n     * Parse metadata to a KV pairs map.\n     *\n     * @param trailers the metadata from remote\n     * @return KV pairs map\n     */\n    protected Map<String, Object> headersToMap(Http2Headers trailers, Supplier<Object> convertUpperHeaderSupplier) {\n        if (trailers == null) {\n            return Collections.emptyMap();\n        }\n        Map<String, Object> attachments = new HashMap<>(trailers.size());\n        for (Map.Entry<CharSequence, CharSequence> header : trailers) {\n            String key = header.getKey().toString();\n            if (key.endsWith(TripleConstant.HEADER_BIN_SUFFIX)\n                    && key.length() > TripleConstant.HEADER_BIN_SUFFIX.length()) {\n                try {\n                    String realKey = key.substring(0, key.length() - TripleConstant.HEADER_BIN_SUFFIX.length());\n                    byte[] value = StreamUtils.decodeASCIIByte(header.getValue());\n                    attachments.put(realKey, value);\n                } catch (Exception e) {\n                    LOGGER.error(PROTOCOL_FAILED_PARSE, \"\", \"\", \"Failed to parse response attachment key=\" + key, e);\n                }\n            } else {\n                attachments.put(key, header.getValue().toString());\n            }\n        }\n\n        // try converting upper key\n        Object obj = convertUpperHeaderSupplier.get();\n        if (obj == null) {\n            return attachments;\n        }\n        if (obj instanceof String) {\n            String json = TriRpcStatus.decodeMessage((String) obj);\n            Map<String, String> map = JsonUtils.toJavaObject(json, Map.class);\n            for (Map.Entry<String, String> entry : map.entrySet()) {\n                Object val = attachments.remove(entry.getKey());\n                if (val != null) {\n                    attachments.put(entry.getValue(), val);\n                }\n            }\n        } else {\n            // If convertUpperHeaderSupplier does not return String, just fail...\n            // Internal invocation, use INTERNAL_ERROR instead.\n\n            LOGGER.error(\n                    INTERNAL_ERROR,\n                    \"wrong internal invocation\",\n                    \"\",\n                    \"Triple convertNoLowerCaseHeader error, obj is not String\");\n        }\n        return attachments;\n    }\n\n    protected Map<String, String> filterReservedHeaders(Http2Headers trailers) {\n        if (trailers == null) {\n            return Collections.emptyMap();\n        }\n        Map<String, String> excludeHeaders = new HashMap<>(trailers.size());\n        for (Map.Entry<CharSequence, CharSequence> header : trailers) {\n            String key = header.getKey().toString();\n            if (TripleHeaderEnum.containsExcludeAttachments(key)) {\n                excludeHeaders.put(key, trailers.getAndRemove(key).toString());\n            }\n        }\n        return excludeHeaders;\n    }\n}\n",
        "methodName": null,
        "exampleID": 312,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/AbstractH2TransportListener.java",
        "line": 104,
        "sink": "io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.getAndRemove",
        "source": "-",
        "sourceLine": 104,
        "qualifier": "Call to io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.getAndRemove with untrusted data from [msg : Http2StreamFrame](1).",
        "line_number": 104,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 313
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleTailHandler.java#L31",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.transport;\n\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.ReferenceCounted;\n\n/**\n * Process unhandled message to avoid mem leak and netty's unhandled exception\n */\npublic class TripleTailHandler extends ChannelInboundHandlerAdapter {\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        if (msg instanceof ReferenceCounted) {\n            ReferenceCountUtil.release(msg);\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 314,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleTailHandler.java",
        "line": 31,
        "sink": "io.netty.util.ReferenceCountUtil.release",
        "source": "-",
        "sourceLine": 31,
        "qualifier": "Call to io.netty.util.ReferenceCountUtil.release with untrusted data from [msg : Object](1).",
        "line_number": 31,
        "steps": [
            {
                "line": 29,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleTailHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleTailHandler.java",
                "methodName": null,
                "exampleID": 315
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleIsolationExecutorSupport.java#L50",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.transport;\n\nimport org.apache.dubbo.common.ServiceKey;\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.executor.AbstractIsolationExecutorSupport;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\n\nimport io.netty.handler.codec.http2.Http2Headers;\n\npublic class TripleIsolationExecutorSupport extends AbstractIsolationExecutorSupport {\n    private static final ErrorTypeAwareLogger logger =\n            LoggerFactory.getErrorTypeAwareLogger(TripleIsolationExecutorSupport.class);\n\n    public TripleIsolationExecutorSupport(URL url) {\n        super(url);\n    }\n\n    @Override\n    protected ServiceKey getServiceKey(Object data) {\n        if (!(data instanceof Http2Headers)) {\n            return null;\n        }\n\n        Http2Headers headers = (Http2Headers) data;\n        String path = headers.path().toString();\n        String[] parts = path.split(\"/\"); // path like /{interfaceName}/{methodName}\n        String interfaceName = parts[1];\n        String version = headers.contains(TripleHeaderEnum.SERVICE_VERSION.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_VERSION.getHeader()).toString()\n                : null;\n        String group = headers.contains(TripleHeaderEnum.SERVICE_GROUP.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_GROUP.getHeader()).toString()\n                : null;\n        return new ServiceKey(interfaceName, version, group);\n    }\n}\n",
        "methodName": null,
        "exampleID": 316,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleIsolationExecutorSupport.java",
        "line": 50,
        "sink": "io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get",
        "source": "-",
        "sourceLine": 50,
        "qualifier": "Call to io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get with untrusted data from [msg : Object](1).\nCall to io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get with untrusted data from [msg : Object](2).\nCall to io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get with untrusted data from [msg : Object](3).\nCall to io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get with untrusted data from [msg : Object](4).",
        "line_number": 50,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 317
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 317
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 317
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 317
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java#L405",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.CreateStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.EndStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2ClientResponseHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\nimport org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.ErrorInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\nimport io.netty.util.ReferenceCountUtil;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_RESPONSE;\n\n/**\n * ClientStream is an abstraction for bi-directional messaging. It maintains a {@link WriteQueue} to\n * write Http2Frame to remote. A {@link H2TransportListener} receives Http2Frame from remote.\n * Instead of maintaining state, this class depends on upper layer or transport layer's states.\n */\npublic class TripleClientStream extends AbstractStream implements ClientStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleClientStream.class);\n\n    public final ClientStream.Listener listener;\n    private final TripleWriteQueue writeQueue;\n    private Deframer deframer;\n    private final Channel parent;\n    private final TripleStreamChannelFuture streamChannelFuture;\n    private boolean halfClosed;\n    private boolean rst;\n\n    private boolean isReturnTriException = false;\n\n    // for test\n    TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            TripleWriteQueue writeQueue,\n            ClientStream.Listener listener,\n            Http2StreamChannel http2StreamChannel) {\n        super(executor, frameworkModel);\n        this.parent = http2StreamChannel.parent();\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(http2StreamChannel);\n    }\n\n    public TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            Channel parent,\n            ClientStream.Listener listener,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.parent = parent;\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(parent);\n    }\n\n    private TripleStreamChannelFuture initHttp2StreamChannel(Channel parent) {\n        TripleStreamChannelFuture streamChannelFuture = new TripleStreamChannelFuture(parent);\n        Http2StreamChannelBootstrap bootstrap = new Http2StreamChannelBootstrap(parent);\n        bootstrap.handler(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n                Channel channel = ctx.channel();\n                channel.pipeline().addLast(new TripleCommandOutBoundHandler());\n                channel.pipeline().addLast(new TripleHttp2ClientResponseHandler(createTransportListener()));\n            }\n        });\n        CreateStreamQueueCommand cmd = CreateStreamQueueCommand.create(bootstrap, streamChannelFuture);\n        this.writeQueue.enqueue(cmd);\n        return streamChannelFuture;\n    }\n\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (this.writeQueue == null) {\n            // already processed at createStream()\n            return parent.newFailedFuture(new IllegalStateException(\"Stream already closed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final HeaderQueueCommand headerCmd = HeaderQueueCommand.createHeaders(streamChannelFuture, headers);\n        return writeQueue.enqueueFuture(headerCmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                transportException(future.cause());\n            }\n        });\n    }\n\n    private void transportException(Throwable cause) {\n        final TriRpcStatus status =\n                TriRpcStatus.INTERNAL.withDescription(\"Http2 exception\").withCause(cause);\n        listener.onComplete(status, null, null, false);\n    }\n\n    public ChannelFuture cancelByLocal(TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final CancelQueueCommand cmd = CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL);\n\n        TripleClientStream.this.rst = true;\n        return this.writeQueue.enqueue(cmd);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return parent.remoteAddress();\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag, boolean eos) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final DataQueueCommand cmd = DataQueueCommand.create(streamChannelFuture, message, false, compressFlag);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                cancelByLocal(TriRpcStatus.INTERNAL\n                        .withDescription(\"Client write message failed\")\n                        .withCause(future.cause()));\n                transportException(future.cause());\n            }\n        });\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    @Override\n    public ChannelFuture halfClose() {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final EndStreamQueueCommand cmd = EndStreamQueueCommand.create(streamChannelFuture);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (future.isSuccess()) {\n                halfClosed = true;\n            }\n        });\n    }\n\n    private ChannelFuture preCheck() {\n        if (rst) {\n            return streamChannelFuture.getNow().newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return parent.newSucceededFuture();\n    }\n\n    /**\n     * @return transport listener\n     */\n    H2TransportListener createTransportListener() {\n        return new ClientTransportListener();\n    }\n\n    class ClientTransportListener extends AbstractH2TransportListener implements H2TransportListener {\n\n        private TriRpcStatus transportError;\n        private DeCompressor decompressor;\n        private boolean headerReceived;\n        private Http2Headers trailers;\n\n        void handleH2TransportError(TriRpcStatus status) {\n            writeQueue.enqueue(CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.NO_ERROR));\n            TripleClientStream.this.rst = true;\n            finishProcess(status, null, false);\n        }\n\n        void finishProcess(TriRpcStatus status, Http2Headers trailers, boolean isReturnTriException) {\n            final Map<String, String> reserved = filterReservedHeaders(trailers);\n            final Map<String, Object> attachments =\n                    headersToMap(trailers, () -> reserved.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()));\n            final TriRpcStatus detailStatus;\n            final TriRpcStatus statusFromTrailers = getStatusFromTrailers(reserved);\n            if (statusFromTrailers != null) {\n                detailStatus = statusFromTrailers;\n            } else {\n                detailStatus = status;\n            }\n            listener.onComplete(detailStatus, attachments, reserved, isReturnTriException);\n        }\n\n        private TriRpcStatus validateHeaderStatus(Http2Headers headers) {\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n            if (httpStatus == null) {\n                return TriRpcStatus.INTERNAL.withDescription(\"Missing HTTP status code\");\n            }\n            final CharSequence contentType = headers.get(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader());\n            if (contentType == null\n                    || !contentType.toString().startsWith(TripleHeaderEnum.APPLICATION_GRPC.getHeader())) {\n                return TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus))\n                        .withDescription(\"invalid content-type: \" + contentType);\n            }\n            return null;\n        }\n\n        void onHeaderReceived(Http2Headers headers) {\n            if (transportError != null) {\n                transportError.appendDescription(\"headers:\" + headers);\n                return;\n            }\n            if (headerReceived) {\n                transportError = TriRpcStatus.INTERNAL.withDescription(\"Received headers twice\");\n                return;\n            }\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n\n            if (httpStatus != null && Integer.parseInt(httpStatus.toString()) > 100 && httpStatus < 200) {\n                // ignored\n                return;\n            }\n            headerReceived = true;\n            transportError = validateHeaderStatus(headers);\n\n            // todo support full payload compressor\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            CharSequence triExceptionCode = headers.get(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader());\n            if (triExceptionCode != null) {\n                Integer triExceptionCodeNum = Integer.parseInt(triExceptionCode.toString());\n                if (!(triExceptionCodeNum.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS))) {\n                    isReturnTriException = true;\n                }\n            }\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.IDENTITY.getMessageEncoding().equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        throw TriRpcStatus.UNIMPLEMENTED\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr))\n                                .asException();\n                    } else {\n                        decompressor = compressor;\n                    }\n                }\n            }\n            TriDecoder.Listener listener = new TriDecoder.Listener() {\n                @Override\n                public void onRawMessage(byte[] data) {\n                    TripleClientStream.this.listener.onMessage(data, isReturnTriException);\n                }\n\n                public void close() {\n                    finishProcess(statusFromTrailers(trailers), trailers, isReturnTriException);\n                }\n            };\n            deframer = new TriDecoder(decompressor, listener);\n            TripleClientStream.this.listener.onStart();\n        }\n\n        void onTrailersReceived(Http2Headers trailers) {\n            if (transportError == null && !headerReceived) {\n                transportError = validateHeaderStatus(trailers);\n            }\n            if (transportError != null) {\n                transportError = transportError.appendDescription(\"trailers: \" + trailers);\n            } else {\n                this.trailers = trailers;\n                TriRpcStatus status = statusFromTrailers(trailers);\n                if (deframer == null) {\n                    finishProcess(status, trailers, false);\n                }\n                if (deframer != null) {\n                    deframer.close();\n                }\n            }\n        }\n\n        /**\n         * Extract the response status from trailers.\n         */\n        private TriRpcStatus statusFromTrailers(Http2Headers trailers) {\n            final Integer intStatus = trailers.getInt(TripleHeaderEnum.STATUS_KEY.getHeader());\n            TriRpcStatus status = intStatus == null ? null : TriRpcStatus.fromCode(intStatus);\n            if (status != null) {\n                final CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());\n                if (message != null) {\n                    final String description = TriRpcStatus.decodeMessage(message.toString());\n                    status = status.withDescription(description);\n                }\n                return status;\n            }\n            // No status; something is broken. Try to provide a rational error.\n            if (headerReceived) {\n                return TriRpcStatus.UNKNOWN.withDescription(\"missing GRPC status in response\");\n            }\n            Integer httpStatus = trailers.status() == null\n                    ? null\n                    : Integer.parseInt(trailers.status().toString());\n            if (httpStatus != null) {\n                status = TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus));\n            } else {\n                status = TriRpcStatus.INTERNAL.withDescription(\"missing HTTP status code\");\n            }\n            return status.appendDescription(\"missing GRPC status, inferred error from HTTP status code\");\n        }\n\n        private TriRpcStatus getStatusFromTrailers(Map<String, String> metadata) {\n            if (null == metadata) {\n                return null;\n            }\n            if (!getGrpcStatusDetailEnabled()) {\n                return null;\n            }\n            // second get status detail\n            if (!metadata.containsKey(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader())) {\n                return null;\n            }\n            final String raw = (metadata.remove(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader()));\n            byte[] statusDetailBin = StreamUtils.decodeASCIIByte(raw);\n            ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n            try {\n                final Status statusDetail = Status.parseFrom(statusDetailBin);\n                List<Any> detailList = statusDetail.getDetailsList();\n                Map<Class<?>, Object> classObjectMap = tranFromStatusDetails(detailList);\n\n                // get common exception from DebugInfo\n                TriRpcStatus status = TriRpcStatus.fromCode(statusDetail.getCode())\n                        .withDescription(TriRpcStatus.decodeMessage(statusDetail.getMessage()));\n                DebugInfo debugInfo = (DebugInfo) classObjectMap.get(DebugInfo.class);\n                if (debugInfo != null) {\n                    String msg = ExceptionUtils.getStackFrameString(debugInfo.getStackEntriesList());\n                    status = status.appendDescription(msg);\n                }\n                return status;\n            } catch (IOException ioException) {\n                return null;\n            } finally {\n                ClassLoadUtil.switchContextLoader(tccl);\n            }\n        }\n\n        private Map<Class<?>, Object> tranFromStatusDetails(List<Any> detailList) {\n            Map<Class<?>, Object> map = new HashMap<>(detailList.size());\n            try {\n                for (Any any : detailList) {\n                    if (any.is(ErrorInfo.class)) {\n                        ErrorInfo errorInfo = any.unpack(ErrorInfo.class);\n                        map.putIfAbsent(ErrorInfo.class, errorInfo);\n                    } else if (any.is(DebugInfo.class)) {\n                        DebugInfo debugInfo = any.unpack(DebugInfo.class);\n                        map.putIfAbsent(DebugInfo.class, debugInfo);\n                    }\n                    // support others type but now only support this\n                }\n            } catch (Throwable t) {\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"tran from grpc-status-details error\", t);\n            }\n            return map;\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> {\n                if (endStream) {\n                    if (!halfClosed) {\n                        Http2StreamChannel channel = streamChannelFuture.getNow();\n                        if (channel.isActive() && !rst) {\n                            writeQueue.enqueue(\n                                    CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL));\n                            rst = true;\n                        }\n                    }\n                    onTrailersReceived(headers);\n                } else {\n                    onHeaderReceived(headers);\n                }\n            });\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (transportError != null) {\n                transportError.appendDescription(\"Data:\" + data.toString(StandardCharsets.UTF_8));\n                ReferenceCountUtil.release(data);\n                if (transportError.description.length() > 512 || endStream) {\n                    handleH2TransportError(transportError);\n                }\n                return;\n            }\n            if (!headerReceived) {\n                handleH2TransportError(TriRpcStatus.INTERNAL.withDescription(\"headers not received before payload\"));\n                return;\n            }\n            deframer.deframe(data);\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            executor.execute(() -> {\n                transportError =\n                        TriRpcStatus.CANCELLED.withDescription(\"Canceled by remote peer, errorCode=\" + errorCode);\n                finishProcess(transportError, null, false);\n            });\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 318,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java",
        "line": 405,
        "sink": "com.google.protobuf.Any.unpack",
        "source": "-",
        "sourceLine": 405,
        "qualifier": "Call to com.google.protobuf.Any.unpack with untrusted data from [msg : Http2StreamFrame](1).",
        "line_number": 405,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 319
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 319
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java#L408",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.CreateStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.EndStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2ClientResponseHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\nimport org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.ErrorInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\nimport io.netty.util.ReferenceCountUtil;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_RESPONSE;\n\n/**\n * ClientStream is an abstraction for bi-directional messaging. It maintains a {@link WriteQueue} to\n * write Http2Frame to remote. A {@link H2TransportListener} receives Http2Frame from remote.\n * Instead of maintaining state, this class depends on upper layer or transport layer's states.\n */\npublic class TripleClientStream extends AbstractStream implements ClientStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleClientStream.class);\n\n    public final ClientStream.Listener listener;\n    private final TripleWriteQueue writeQueue;\n    private Deframer deframer;\n    private final Channel parent;\n    private final TripleStreamChannelFuture streamChannelFuture;\n    private boolean halfClosed;\n    private boolean rst;\n\n    private boolean isReturnTriException = false;\n\n    // for test\n    TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            TripleWriteQueue writeQueue,\n            ClientStream.Listener listener,\n            Http2StreamChannel http2StreamChannel) {\n        super(executor, frameworkModel);\n        this.parent = http2StreamChannel.parent();\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(http2StreamChannel);\n    }\n\n    public TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            Channel parent,\n            ClientStream.Listener listener,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.parent = parent;\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(parent);\n    }\n\n    private TripleStreamChannelFuture initHttp2StreamChannel(Channel parent) {\n        TripleStreamChannelFuture streamChannelFuture = new TripleStreamChannelFuture(parent);\n        Http2StreamChannelBootstrap bootstrap = new Http2StreamChannelBootstrap(parent);\n        bootstrap.handler(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n                Channel channel = ctx.channel();\n                channel.pipeline().addLast(new TripleCommandOutBoundHandler());\n                channel.pipeline().addLast(new TripleHttp2ClientResponseHandler(createTransportListener()));\n            }\n        });\n        CreateStreamQueueCommand cmd = CreateStreamQueueCommand.create(bootstrap, streamChannelFuture);\n        this.writeQueue.enqueue(cmd);\n        return streamChannelFuture;\n    }\n\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (this.writeQueue == null) {\n            // already processed at createStream()\n            return parent.newFailedFuture(new IllegalStateException(\"Stream already closed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final HeaderQueueCommand headerCmd = HeaderQueueCommand.createHeaders(streamChannelFuture, headers);\n        return writeQueue.enqueueFuture(headerCmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                transportException(future.cause());\n            }\n        });\n    }\n\n    private void transportException(Throwable cause) {\n        final TriRpcStatus status =\n                TriRpcStatus.INTERNAL.withDescription(\"Http2 exception\").withCause(cause);\n        listener.onComplete(status, null, null, false);\n    }\n\n    public ChannelFuture cancelByLocal(TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final CancelQueueCommand cmd = CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL);\n\n        TripleClientStream.this.rst = true;\n        return this.writeQueue.enqueue(cmd);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return parent.remoteAddress();\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag, boolean eos) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final DataQueueCommand cmd = DataQueueCommand.create(streamChannelFuture, message, false, compressFlag);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                cancelByLocal(TriRpcStatus.INTERNAL\n                        .withDescription(\"Client write message failed\")\n                        .withCause(future.cause()));\n                transportException(future.cause());\n            }\n        });\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    @Override\n    public ChannelFuture halfClose() {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final EndStreamQueueCommand cmd = EndStreamQueueCommand.create(streamChannelFuture);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (future.isSuccess()) {\n                halfClosed = true;\n            }\n        });\n    }\n\n    private ChannelFuture preCheck() {\n        if (rst) {\n            return streamChannelFuture.getNow().newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return parent.newSucceededFuture();\n    }\n\n    /**\n     * @return transport listener\n     */\n    H2TransportListener createTransportListener() {\n        return new ClientTransportListener();\n    }\n\n    class ClientTransportListener extends AbstractH2TransportListener implements H2TransportListener {\n\n        private TriRpcStatus transportError;\n        private DeCompressor decompressor;\n        private boolean headerReceived;\n        private Http2Headers trailers;\n\n        void handleH2TransportError(TriRpcStatus status) {\n            writeQueue.enqueue(CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.NO_ERROR));\n            TripleClientStream.this.rst = true;\n            finishProcess(status, null, false);\n        }\n\n        void finishProcess(TriRpcStatus status, Http2Headers trailers, boolean isReturnTriException) {\n            final Map<String, String> reserved = filterReservedHeaders(trailers);\n            final Map<String, Object> attachments =\n                    headersToMap(trailers, () -> reserved.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()));\n            final TriRpcStatus detailStatus;\n            final TriRpcStatus statusFromTrailers = getStatusFromTrailers(reserved);\n            if (statusFromTrailers != null) {\n                detailStatus = statusFromTrailers;\n            } else {\n                detailStatus = status;\n            }\n            listener.onComplete(detailStatus, attachments, reserved, isReturnTriException);\n        }\n\n        private TriRpcStatus validateHeaderStatus(Http2Headers headers) {\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n            if (httpStatus == null) {\n                return TriRpcStatus.INTERNAL.withDescription(\"Missing HTTP status code\");\n            }\n            final CharSequence contentType = headers.get(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader());\n            if (contentType == null\n                    || !contentType.toString().startsWith(TripleHeaderEnum.APPLICATION_GRPC.getHeader())) {\n                return TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus))\n                        .withDescription(\"invalid content-type: \" + contentType);\n            }\n            return null;\n        }\n\n        void onHeaderReceived(Http2Headers headers) {\n            if (transportError != null) {\n                transportError.appendDescription(\"headers:\" + headers);\n                return;\n            }\n            if (headerReceived) {\n                transportError = TriRpcStatus.INTERNAL.withDescription(\"Received headers twice\");\n                return;\n            }\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n\n            if (httpStatus != null && Integer.parseInt(httpStatus.toString()) > 100 && httpStatus < 200) {\n                // ignored\n                return;\n            }\n            headerReceived = true;\n            transportError = validateHeaderStatus(headers);\n\n            // todo support full payload compressor\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            CharSequence triExceptionCode = headers.get(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader());\n            if (triExceptionCode != null) {\n                Integer triExceptionCodeNum = Integer.parseInt(triExceptionCode.toString());\n                if (!(triExceptionCodeNum.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS))) {\n                    isReturnTriException = true;\n                }\n            }\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.IDENTITY.getMessageEncoding().equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        throw TriRpcStatus.UNIMPLEMENTED\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr))\n                                .asException();\n                    } else {\n                        decompressor = compressor;\n                    }\n                }\n            }\n            TriDecoder.Listener listener = new TriDecoder.Listener() {\n                @Override\n                public void onRawMessage(byte[] data) {\n                    TripleClientStream.this.listener.onMessage(data, isReturnTriException);\n                }\n\n                public void close() {\n                    finishProcess(statusFromTrailers(trailers), trailers, isReturnTriException);\n                }\n            };\n            deframer = new TriDecoder(decompressor, listener);\n            TripleClientStream.this.listener.onStart();\n        }\n\n        void onTrailersReceived(Http2Headers trailers) {\n            if (transportError == null && !headerReceived) {\n                transportError = validateHeaderStatus(trailers);\n            }\n            if (transportError != null) {\n                transportError = transportError.appendDescription(\"trailers: \" + trailers);\n            } else {\n                this.trailers = trailers;\n                TriRpcStatus status = statusFromTrailers(trailers);\n                if (deframer == null) {\n                    finishProcess(status, trailers, false);\n                }\n                if (deframer != null) {\n                    deframer.close();\n                }\n            }\n        }\n\n        /**\n         * Extract the response status from trailers.\n         */\n        private TriRpcStatus statusFromTrailers(Http2Headers trailers) {\n            final Integer intStatus = trailers.getInt(TripleHeaderEnum.STATUS_KEY.getHeader());\n            TriRpcStatus status = intStatus == null ? null : TriRpcStatus.fromCode(intStatus);\n            if (status != null) {\n                final CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());\n                if (message != null) {\n                    final String description = TriRpcStatus.decodeMessage(message.toString());\n                    status = status.withDescription(description);\n                }\n                return status;\n            }\n            // No status; something is broken. Try to provide a rational error.\n            if (headerReceived) {\n                return TriRpcStatus.UNKNOWN.withDescription(\"missing GRPC status in response\");\n            }\n            Integer httpStatus = trailers.status() == null\n                    ? null\n                    : Integer.parseInt(trailers.status().toString());\n            if (httpStatus != null) {\n                status = TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus));\n            } else {\n                status = TriRpcStatus.INTERNAL.withDescription(\"missing HTTP status code\");\n            }\n            return status.appendDescription(\"missing GRPC status, inferred error from HTTP status code\");\n        }\n\n        private TriRpcStatus getStatusFromTrailers(Map<String, String> metadata) {\n            if (null == metadata) {\n                return null;\n            }\n            if (!getGrpcStatusDetailEnabled()) {\n                return null;\n            }\n            // second get status detail\n            if (!metadata.containsKey(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader())) {\n                return null;\n            }\n            final String raw = (metadata.remove(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader()));\n            byte[] statusDetailBin = StreamUtils.decodeASCIIByte(raw);\n            ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n            try {\n                final Status statusDetail = Status.parseFrom(statusDetailBin);\n                List<Any> detailList = statusDetail.getDetailsList();\n                Map<Class<?>, Object> classObjectMap = tranFromStatusDetails(detailList);\n\n                // get common exception from DebugInfo\n                TriRpcStatus status = TriRpcStatus.fromCode(statusDetail.getCode())\n                        .withDescription(TriRpcStatus.decodeMessage(statusDetail.getMessage()));\n                DebugInfo debugInfo = (DebugInfo) classObjectMap.get(DebugInfo.class);\n                if (debugInfo != null) {\n                    String msg = ExceptionUtils.getStackFrameString(debugInfo.getStackEntriesList());\n                    status = status.appendDescription(msg);\n                }\n                return status;\n            } catch (IOException ioException) {\n                return null;\n            } finally {\n                ClassLoadUtil.switchContextLoader(tccl);\n            }\n        }\n\n        private Map<Class<?>, Object> tranFromStatusDetails(List<Any> detailList) {\n            Map<Class<?>, Object> map = new HashMap<>(detailList.size());\n            try {\n                for (Any any : detailList) {\n                    if (any.is(ErrorInfo.class)) {\n                        ErrorInfo errorInfo = any.unpack(ErrorInfo.class);\n                        map.putIfAbsent(ErrorInfo.class, errorInfo);\n                    } else if (any.is(DebugInfo.class)) {\n                        DebugInfo debugInfo = any.unpack(DebugInfo.class);\n                        map.putIfAbsent(DebugInfo.class, debugInfo);\n                    }\n                    // support others type but now only support this\n                }\n            } catch (Throwable t) {\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"tran from grpc-status-details error\", t);\n            }\n            return map;\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> {\n                if (endStream) {\n                    if (!halfClosed) {\n                        Http2StreamChannel channel = streamChannelFuture.getNow();\n                        if (channel.isActive() && !rst) {\n                            writeQueue.enqueue(\n                                    CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL));\n                            rst = true;\n                        }\n                    }\n                    onTrailersReceived(headers);\n                } else {\n                    onHeaderReceived(headers);\n                }\n            });\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (transportError != null) {\n                transportError.appendDescription(\"Data:\" + data.toString(StandardCharsets.UTF_8));\n                ReferenceCountUtil.release(data);\n                if (transportError.description.length() > 512 || endStream) {\n                    handleH2TransportError(transportError);\n                }\n                return;\n            }\n            if (!headerReceived) {\n                handleH2TransportError(TriRpcStatus.INTERNAL.withDescription(\"headers not received before payload\"));\n                return;\n            }\n            deframer.deframe(data);\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            executor.execute(() -> {\n                transportError =\n                        TriRpcStatus.CANCELLED.withDescription(\"Canceled by remote peer, errorCode=\" + errorCode);\n                finishProcess(transportError, null, false);\n            });\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 320,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java",
        "line": 408,
        "sink": "com.google.protobuf.Any.unpack",
        "source": "-",
        "sourceLine": 408,
        "qualifier": "Call to com.google.protobuf.Any.unpack with untrusted data from [msg : Http2StreamFrame](1).",
        "line_number": 408,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 321
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 321
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java#L446",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.CreateStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.EndStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2ClientResponseHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\nimport org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.ErrorInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\nimport io.netty.util.ReferenceCountUtil;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_RESPONSE;\n\n/**\n * ClientStream is an abstraction for bi-directional messaging. It maintains a {@link WriteQueue} to\n * write Http2Frame to remote. A {@link H2TransportListener} receives Http2Frame from remote.\n * Instead of maintaining state, this class depends on upper layer or transport layer's states.\n */\npublic class TripleClientStream extends AbstractStream implements ClientStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleClientStream.class);\n\n    public final ClientStream.Listener listener;\n    private final TripleWriteQueue writeQueue;\n    private Deframer deframer;\n    private final Channel parent;\n    private final TripleStreamChannelFuture streamChannelFuture;\n    private boolean halfClosed;\n    private boolean rst;\n\n    private boolean isReturnTriException = false;\n\n    // for test\n    TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            TripleWriteQueue writeQueue,\n            ClientStream.Listener listener,\n            Http2StreamChannel http2StreamChannel) {\n        super(executor, frameworkModel);\n        this.parent = http2StreamChannel.parent();\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(http2StreamChannel);\n    }\n\n    public TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            Channel parent,\n            ClientStream.Listener listener,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.parent = parent;\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(parent);\n    }\n\n    private TripleStreamChannelFuture initHttp2StreamChannel(Channel parent) {\n        TripleStreamChannelFuture streamChannelFuture = new TripleStreamChannelFuture(parent);\n        Http2StreamChannelBootstrap bootstrap = new Http2StreamChannelBootstrap(parent);\n        bootstrap.handler(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n                Channel channel = ctx.channel();\n                channel.pipeline().addLast(new TripleCommandOutBoundHandler());\n                channel.pipeline().addLast(new TripleHttp2ClientResponseHandler(createTransportListener()));\n            }\n        });\n        CreateStreamQueueCommand cmd = CreateStreamQueueCommand.create(bootstrap, streamChannelFuture);\n        this.writeQueue.enqueue(cmd);\n        return streamChannelFuture;\n    }\n\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (this.writeQueue == null) {\n            // already processed at createStream()\n            return parent.newFailedFuture(new IllegalStateException(\"Stream already closed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final HeaderQueueCommand headerCmd = HeaderQueueCommand.createHeaders(streamChannelFuture, headers);\n        return writeQueue.enqueueFuture(headerCmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                transportException(future.cause());\n            }\n        });\n    }\n\n    private void transportException(Throwable cause) {\n        final TriRpcStatus status =\n                TriRpcStatus.INTERNAL.withDescription(\"Http2 exception\").withCause(cause);\n        listener.onComplete(status, null, null, false);\n    }\n\n    public ChannelFuture cancelByLocal(TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final CancelQueueCommand cmd = CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL);\n\n        TripleClientStream.this.rst = true;\n        return this.writeQueue.enqueue(cmd);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return parent.remoteAddress();\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag, boolean eos) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final DataQueueCommand cmd = DataQueueCommand.create(streamChannelFuture, message, false, compressFlag);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                cancelByLocal(TriRpcStatus.INTERNAL\n                        .withDescription(\"Client write message failed\")\n                        .withCause(future.cause()));\n                transportException(future.cause());\n            }\n        });\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    @Override\n    public ChannelFuture halfClose() {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final EndStreamQueueCommand cmd = EndStreamQueueCommand.create(streamChannelFuture);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (future.isSuccess()) {\n                halfClosed = true;\n            }\n        });\n    }\n\n    private ChannelFuture preCheck() {\n        if (rst) {\n            return streamChannelFuture.getNow().newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return parent.newSucceededFuture();\n    }\n\n    /**\n     * @return transport listener\n     */\n    H2TransportListener createTransportListener() {\n        return new ClientTransportListener();\n    }\n\n    class ClientTransportListener extends AbstractH2TransportListener implements H2TransportListener {\n\n        private TriRpcStatus transportError;\n        private DeCompressor decompressor;\n        private boolean headerReceived;\n        private Http2Headers trailers;\n\n        void handleH2TransportError(TriRpcStatus status) {\n            writeQueue.enqueue(CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.NO_ERROR));\n            TripleClientStream.this.rst = true;\n            finishProcess(status, null, false);\n        }\n\n        void finishProcess(TriRpcStatus status, Http2Headers trailers, boolean isReturnTriException) {\n            final Map<String, String> reserved = filterReservedHeaders(trailers);\n            final Map<String, Object> attachments =\n                    headersToMap(trailers, () -> reserved.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()));\n            final TriRpcStatus detailStatus;\n            final TriRpcStatus statusFromTrailers = getStatusFromTrailers(reserved);\n            if (statusFromTrailers != null) {\n                detailStatus = statusFromTrailers;\n            } else {\n                detailStatus = status;\n            }\n            listener.onComplete(detailStatus, attachments, reserved, isReturnTriException);\n        }\n\n        private TriRpcStatus validateHeaderStatus(Http2Headers headers) {\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n            if (httpStatus == null) {\n                return TriRpcStatus.INTERNAL.withDescription(\"Missing HTTP status code\");\n            }\n            final CharSequence contentType = headers.get(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader());\n            if (contentType == null\n                    || !contentType.toString().startsWith(TripleHeaderEnum.APPLICATION_GRPC.getHeader())) {\n                return TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus))\n                        .withDescription(\"invalid content-type: \" + contentType);\n            }\n            return null;\n        }\n\n        void onHeaderReceived(Http2Headers headers) {\n            if (transportError != null) {\n                transportError.appendDescription(\"headers:\" + headers);\n                return;\n            }\n            if (headerReceived) {\n                transportError = TriRpcStatus.INTERNAL.withDescription(\"Received headers twice\");\n                return;\n            }\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n\n            if (httpStatus != null && Integer.parseInt(httpStatus.toString()) > 100 && httpStatus < 200) {\n                // ignored\n                return;\n            }\n            headerReceived = true;\n            transportError = validateHeaderStatus(headers);\n\n            // todo support full payload compressor\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            CharSequence triExceptionCode = headers.get(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader());\n            if (triExceptionCode != null) {\n                Integer triExceptionCodeNum = Integer.parseInt(triExceptionCode.toString());\n                if (!(triExceptionCodeNum.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS))) {\n                    isReturnTriException = true;\n                }\n            }\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.IDENTITY.getMessageEncoding().equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        throw TriRpcStatus.UNIMPLEMENTED\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr))\n                                .asException();\n                    } else {\n                        decompressor = compressor;\n                    }\n                }\n            }\n            TriDecoder.Listener listener = new TriDecoder.Listener() {\n                @Override\n                public void onRawMessage(byte[] data) {\n                    TripleClientStream.this.listener.onMessage(data, isReturnTriException);\n                }\n\n                public void close() {\n                    finishProcess(statusFromTrailers(trailers), trailers, isReturnTriException);\n                }\n            };\n            deframer = new TriDecoder(decompressor, listener);\n            TripleClientStream.this.listener.onStart();\n        }\n\n        void onTrailersReceived(Http2Headers trailers) {\n            if (transportError == null && !headerReceived) {\n                transportError = validateHeaderStatus(trailers);\n            }\n            if (transportError != null) {\n                transportError = transportError.appendDescription(\"trailers: \" + trailers);\n            } else {\n                this.trailers = trailers;\n                TriRpcStatus status = statusFromTrailers(trailers);\n                if (deframer == null) {\n                    finishProcess(status, trailers, false);\n                }\n                if (deframer != null) {\n                    deframer.close();\n                }\n            }\n        }\n\n        /**\n         * Extract the response status from trailers.\n         */\n        private TriRpcStatus statusFromTrailers(Http2Headers trailers) {\n            final Integer intStatus = trailers.getInt(TripleHeaderEnum.STATUS_KEY.getHeader());\n            TriRpcStatus status = intStatus == null ? null : TriRpcStatus.fromCode(intStatus);\n            if (status != null) {\n                final CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());\n                if (message != null) {\n                    final String description = TriRpcStatus.decodeMessage(message.toString());\n                    status = status.withDescription(description);\n                }\n                return status;\n            }\n            // No status; something is broken. Try to provide a rational error.\n            if (headerReceived) {\n                return TriRpcStatus.UNKNOWN.withDescription(\"missing GRPC status in response\");\n            }\n            Integer httpStatus = trailers.status() == null\n                    ? null\n                    : Integer.parseInt(trailers.status().toString());\n            if (httpStatus != null) {\n                status = TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus));\n            } else {\n                status = TriRpcStatus.INTERNAL.withDescription(\"missing HTTP status code\");\n            }\n            return status.appendDescription(\"missing GRPC status, inferred error from HTTP status code\");\n        }\n\n        private TriRpcStatus getStatusFromTrailers(Map<String, String> metadata) {\n            if (null == metadata) {\n                return null;\n            }\n            if (!getGrpcStatusDetailEnabled()) {\n                return null;\n            }\n            // second get status detail\n            if (!metadata.containsKey(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader())) {\n                return null;\n            }\n            final String raw = (metadata.remove(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader()));\n            byte[] statusDetailBin = StreamUtils.decodeASCIIByte(raw);\n            ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n            try {\n                final Status statusDetail = Status.parseFrom(statusDetailBin);\n                List<Any> detailList = statusDetail.getDetailsList();\n                Map<Class<?>, Object> classObjectMap = tranFromStatusDetails(detailList);\n\n                // get common exception from DebugInfo\n                TriRpcStatus status = TriRpcStatus.fromCode(statusDetail.getCode())\n                        .withDescription(TriRpcStatus.decodeMessage(statusDetail.getMessage()));\n                DebugInfo debugInfo = (DebugInfo) classObjectMap.get(DebugInfo.class);\n                if (debugInfo != null) {\n                    String msg = ExceptionUtils.getStackFrameString(debugInfo.getStackEntriesList());\n                    status = status.appendDescription(msg);\n                }\n                return status;\n            } catch (IOException ioException) {\n                return null;\n            } finally {\n                ClassLoadUtil.switchContextLoader(tccl);\n            }\n        }\n\n        private Map<Class<?>, Object> tranFromStatusDetails(List<Any> detailList) {\n            Map<Class<?>, Object> map = new HashMap<>(detailList.size());\n            try {\n                for (Any any : detailList) {\n                    if (any.is(ErrorInfo.class)) {\n                        ErrorInfo errorInfo = any.unpack(ErrorInfo.class);\n                        map.putIfAbsent(ErrorInfo.class, errorInfo);\n                    } else if (any.is(DebugInfo.class)) {\n                        DebugInfo debugInfo = any.unpack(DebugInfo.class);\n                        map.putIfAbsent(DebugInfo.class, debugInfo);\n                    }\n                    // support others type but now only support this\n                }\n            } catch (Throwable t) {\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"tran from grpc-status-details error\", t);\n            }\n            return map;\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> {\n                if (endStream) {\n                    if (!halfClosed) {\n                        Http2StreamChannel channel = streamChannelFuture.getNow();\n                        if (channel.isActive() && !rst) {\n                            writeQueue.enqueue(\n                                    CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL));\n                            rst = true;\n                        }\n                    }\n                    onTrailersReceived(headers);\n                } else {\n                    onHeaderReceived(headers);\n                }\n            });\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (transportError != null) {\n                transportError.appendDescription(\"Data:\" + data.toString(StandardCharsets.UTF_8));\n                ReferenceCountUtil.release(data);\n                if (transportError.description.length() > 512 || endStream) {\n                    handleH2TransportError(transportError);\n                }\n                return;\n            }\n            if (!headerReceived) {\n                handleH2TransportError(TriRpcStatus.INTERNAL.withDescription(\"headers not received before payload\"));\n                return;\n            }\n            deframer.deframe(data);\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            executor.execute(() -> {\n                transportError =\n                        TriRpcStatus.CANCELLED.withDescription(\"Canceled by remote peer, errorCode=\" + errorCode);\n                finishProcess(transportError, null, false);\n            });\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 322,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java",
        "line": 446,
        "sink": "io.netty.util.ReferenceCountUtil.release",
        "source": "-",
        "sourceLine": 446,
        "qualifier": "Call to io.netty.util.ReferenceCountUtil.release with untrusted data from [msg : Http2StreamFrame](1).",
        "line_number": 446,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 323
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java#L454",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ClassLoadUtil;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.CreateStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.EndStreamQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleCommandOutBoundHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleHttp2ClientResponseHandler;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\nimport org.apache.dubbo.rpc.protocol.tri.transport.WriteQueue;\n\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.ErrorInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInboundHandlerAdapter;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.handler.codec.http2.Http2StreamChannelBootstrap;\nimport io.netty.util.ReferenceCountUtil;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_RESPONSE;\n\n/**\n * ClientStream is an abstraction for bi-directional messaging. It maintains a {@link WriteQueue} to\n * write Http2Frame to remote. A {@link H2TransportListener} receives Http2Frame from remote.\n * Instead of maintaining state, this class depends on upper layer or transport layer's states.\n */\npublic class TripleClientStream extends AbstractStream implements ClientStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleClientStream.class);\n\n    public final ClientStream.Listener listener;\n    private final TripleWriteQueue writeQueue;\n    private Deframer deframer;\n    private final Channel parent;\n    private final TripleStreamChannelFuture streamChannelFuture;\n    private boolean halfClosed;\n    private boolean rst;\n\n    private boolean isReturnTriException = false;\n\n    // for test\n    TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            TripleWriteQueue writeQueue,\n            ClientStream.Listener listener,\n            Http2StreamChannel http2StreamChannel) {\n        super(executor, frameworkModel);\n        this.parent = http2StreamChannel.parent();\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(http2StreamChannel);\n    }\n\n    public TripleClientStream(\n            FrameworkModel frameworkModel,\n            Executor executor,\n            Channel parent,\n            ClientStream.Listener listener,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.parent = parent;\n        this.listener = listener;\n        this.writeQueue = writeQueue;\n        this.streamChannelFuture = initHttp2StreamChannel(parent);\n    }\n\n    private TripleStreamChannelFuture initHttp2StreamChannel(Channel parent) {\n        TripleStreamChannelFuture streamChannelFuture = new TripleStreamChannelFuture(parent);\n        Http2StreamChannelBootstrap bootstrap = new Http2StreamChannelBootstrap(parent);\n        bootstrap.handler(new ChannelInboundHandlerAdapter() {\n            @Override\n            public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n                Channel channel = ctx.channel();\n                channel.pipeline().addLast(new TripleCommandOutBoundHandler());\n                channel.pipeline().addLast(new TripleHttp2ClientResponseHandler(createTransportListener()));\n            }\n        });\n        CreateStreamQueueCommand cmd = CreateStreamQueueCommand.create(bootstrap, streamChannelFuture);\n        this.writeQueue.enqueue(cmd);\n        return streamChannelFuture;\n    }\n\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (this.writeQueue == null) {\n            // already processed at createStream()\n            return parent.newFailedFuture(new IllegalStateException(\"Stream already closed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final HeaderQueueCommand headerCmd = HeaderQueueCommand.createHeaders(streamChannelFuture, headers);\n        return writeQueue.enqueueFuture(headerCmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                transportException(future.cause());\n            }\n        });\n    }\n\n    private void transportException(Throwable cause) {\n        final TriRpcStatus status =\n                TriRpcStatus.INTERNAL.withDescription(\"Http2 exception\").withCause(cause);\n        listener.onComplete(status, null, null, false);\n    }\n\n    public ChannelFuture cancelByLocal(TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final CancelQueueCommand cmd = CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL);\n\n        TripleClientStream.this.rst = true;\n        return this.writeQueue.enqueue(cmd);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return parent.remoteAddress();\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag, boolean eos) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final DataQueueCommand cmd = DataQueueCommand.create(streamChannelFuture, message, false, compressFlag);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (!future.isSuccess()) {\n                cancelByLocal(TriRpcStatus.INTERNAL\n                        .withDescription(\"Client write message failed\")\n                        .withCause(future.cause()));\n                transportException(future.cause());\n            }\n        });\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    @Override\n    public ChannelFuture halfClose() {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        final EndStreamQueueCommand cmd = EndStreamQueueCommand.create(streamChannelFuture);\n        return this.writeQueue.enqueueFuture(cmd, parent.eventLoop()).addListener(future -> {\n            if (future.isSuccess()) {\n                halfClosed = true;\n            }\n        });\n    }\n\n    private ChannelFuture preCheck() {\n        if (rst) {\n            return streamChannelFuture.getNow().newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return parent.newSucceededFuture();\n    }\n\n    /**\n     * @return transport listener\n     */\n    H2TransportListener createTransportListener() {\n        return new ClientTransportListener();\n    }\n\n    class ClientTransportListener extends AbstractH2TransportListener implements H2TransportListener {\n\n        private TriRpcStatus transportError;\n        private DeCompressor decompressor;\n        private boolean headerReceived;\n        private Http2Headers trailers;\n\n        void handleH2TransportError(TriRpcStatus status) {\n            writeQueue.enqueue(CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.NO_ERROR));\n            TripleClientStream.this.rst = true;\n            finishProcess(status, null, false);\n        }\n\n        void finishProcess(TriRpcStatus status, Http2Headers trailers, boolean isReturnTriException) {\n            final Map<String, String> reserved = filterReservedHeaders(trailers);\n            final Map<String, Object> attachments =\n                    headersToMap(trailers, () -> reserved.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()));\n            final TriRpcStatus detailStatus;\n            final TriRpcStatus statusFromTrailers = getStatusFromTrailers(reserved);\n            if (statusFromTrailers != null) {\n                detailStatus = statusFromTrailers;\n            } else {\n                detailStatus = status;\n            }\n            listener.onComplete(detailStatus, attachments, reserved, isReturnTriException);\n        }\n\n        private TriRpcStatus validateHeaderStatus(Http2Headers headers) {\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n            if (httpStatus == null) {\n                return TriRpcStatus.INTERNAL.withDescription(\"Missing HTTP status code\");\n            }\n            final CharSequence contentType = headers.get(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader());\n            if (contentType == null\n                    || !contentType.toString().startsWith(TripleHeaderEnum.APPLICATION_GRPC.getHeader())) {\n                return TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus))\n                        .withDescription(\"invalid content-type: \" + contentType);\n            }\n            return null;\n        }\n\n        void onHeaderReceived(Http2Headers headers) {\n            if (transportError != null) {\n                transportError.appendDescription(\"headers:\" + headers);\n                return;\n            }\n            if (headerReceived) {\n                transportError = TriRpcStatus.INTERNAL.withDescription(\"Received headers twice\");\n                return;\n            }\n            Integer httpStatus = headers.status() == null\n                    ? null\n                    : Integer.parseInt(headers.status().toString());\n\n            if (httpStatus != null && Integer.parseInt(httpStatus.toString()) > 100 && httpStatus < 200) {\n                // ignored\n                return;\n            }\n            headerReceived = true;\n            transportError = validateHeaderStatus(headers);\n\n            // todo support full payload compressor\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            CharSequence triExceptionCode = headers.get(TripleHeaderEnum.TRI_EXCEPTION_CODE.getHeader());\n            if (triExceptionCode != null) {\n                Integer triExceptionCodeNum = Integer.parseInt(triExceptionCode.toString());\n                if (!(triExceptionCodeNum.equals(CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS))) {\n                    isReturnTriException = true;\n                }\n            }\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.IDENTITY.getMessageEncoding().equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        throw TriRpcStatus.UNIMPLEMENTED\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr))\n                                .asException();\n                    } else {\n                        decompressor = compressor;\n                    }\n                }\n            }\n            TriDecoder.Listener listener = new TriDecoder.Listener() {\n                @Override\n                public void onRawMessage(byte[] data) {\n                    TripleClientStream.this.listener.onMessage(data, isReturnTriException);\n                }\n\n                public void close() {\n                    finishProcess(statusFromTrailers(trailers), trailers, isReturnTriException);\n                }\n            };\n            deframer = new TriDecoder(decompressor, listener);\n            TripleClientStream.this.listener.onStart();\n        }\n\n        void onTrailersReceived(Http2Headers trailers) {\n            if (transportError == null && !headerReceived) {\n                transportError = validateHeaderStatus(trailers);\n            }\n            if (transportError != null) {\n                transportError = transportError.appendDescription(\"trailers: \" + trailers);\n            } else {\n                this.trailers = trailers;\n                TriRpcStatus status = statusFromTrailers(trailers);\n                if (deframer == null) {\n                    finishProcess(status, trailers, false);\n                }\n                if (deframer != null) {\n                    deframer.close();\n                }\n            }\n        }\n\n        /**\n         * Extract the response status from trailers.\n         */\n        private TriRpcStatus statusFromTrailers(Http2Headers trailers) {\n            final Integer intStatus = trailers.getInt(TripleHeaderEnum.STATUS_KEY.getHeader());\n            TriRpcStatus status = intStatus == null ? null : TriRpcStatus.fromCode(intStatus);\n            if (status != null) {\n                final CharSequence message = trailers.get(TripleHeaderEnum.MESSAGE_KEY.getHeader());\n                if (message != null) {\n                    final String description = TriRpcStatus.decodeMessage(message.toString());\n                    status = status.withDescription(description);\n                }\n                return status;\n            }\n            // No status; something is broken. Try to provide a rational error.\n            if (headerReceived) {\n                return TriRpcStatus.UNKNOWN.withDescription(\"missing GRPC status in response\");\n            }\n            Integer httpStatus = trailers.status() == null\n                    ? null\n                    : Integer.parseInt(trailers.status().toString());\n            if (httpStatus != null) {\n                status = TriRpcStatus.fromCode(TriRpcStatus.httpStatusToGrpcCode(httpStatus));\n            } else {\n                status = TriRpcStatus.INTERNAL.withDescription(\"missing HTTP status code\");\n            }\n            return status.appendDescription(\"missing GRPC status, inferred error from HTTP status code\");\n        }\n\n        private TriRpcStatus getStatusFromTrailers(Map<String, String> metadata) {\n            if (null == metadata) {\n                return null;\n            }\n            if (!getGrpcStatusDetailEnabled()) {\n                return null;\n            }\n            // second get status detail\n            if (!metadata.containsKey(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader())) {\n                return null;\n            }\n            final String raw = (metadata.remove(TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader()));\n            byte[] statusDetailBin = StreamUtils.decodeASCIIByte(raw);\n            ClassLoader tccl = Thread.currentThread().getContextClassLoader();\n            try {\n                final Status statusDetail = Status.parseFrom(statusDetailBin);\n                List<Any> detailList = statusDetail.getDetailsList();\n                Map<Class<?>, Object> classObjectMap = tranFromStatusDetails(detailList);\n\n                // get common exception from DebugInfo\n                TriRpcStatus status = TriRpcStatus.fromCode(statusDetail.getCode())\n                        .withDescription(TriRpcStatus.decodeMessage(statusDetail.getMessage()));\n                DebugInfo debugInfo = (DebugInfo) classObjectMap.get(DebugInfo.class);\n                if (debugInfo != null) {\n                    String msg = ExceptionUtils.getStackFrameString(debugInfo.getStackEntriesList());\n                    status = status.appendDescription(msg);\n                }\n                return status;\n            } catch (IOException ioException) {\n                return null;\n            } finally {\n                ClassLoadUtil.switchContextLoader(tccl);\n            }\n        }\n\n        private Map<Class<?>, Object> tranFromStatusDetails(List<Any> detailList) {\n            Map<Class<?>, Object> map = new HashMap<>(detailList.size());\n            try {\n                for (Any any : detailList) {\n                    if (any.is(ErrorInfo.class)) {\n                        ErrorInfo errorInfo = any.unpack(ErrorInfo.class);\n                        map.putIfAbsent(ErrorInfo.class, errorInfo);\n                    } else if (any.is(DebugInfo.class)) {\n                        DebugInfo debugInfo = any.unpack(DebugInfo.class);\n                        map.putIfAbsent(DebugInfo.class, debugInfo);\n                    }\n                    // support others type but now only support this\n                }\n            } catch (Throwable t) {\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"tran from grpc-status-details error\", t);\n            }\n            return map;\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> {\n                if (endStream) {\n                    if (!halfClosed) {\n                        Http2StreamChannel channel = streamChannelFuture.getNow();\n                        if (channel.isActive() && !rst) {\n                            writeQueue.enqueue(\n                                    CancelQueueCommand.createCommand(streamChannelFuture, Http2Error.CANCEL));\n                            rst = true;\n                        }\n                    }\n                    onTrailersReceived(headers);\n                } else {\n                    onHeaderReceived(headers);\n                }\n            });\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_RESPONSE, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (transportError != null) {\n                transportError.appendDescription(\"Data:\" + data.toString(StandardCharsets.UTF_8));\n                ReferenceCountUtil.release(data);\n                if (transportError.description.length() > 512 || endStream) {\n                    handleH2TransportError(transportError);\n                }\n                return;\n            }\n            if (!headerReceived) {\n                handleH2TransportError(TriRpcStatus.INTERNAL.withDescription(\"headers not received before payload\"));\n                return;\n            }\n            deframer.deframe(data);\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            executor.execute(() -> {\n                transportError =\n                        TriRpcStatus.CANCELLED.withDescription(\"Canceled by remote peer, errorCode=\" + errorCode);\n                finishProcess(transportError, null, false);\n            });\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 324,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleClientStream.java",
        "line": 454,
        "sink": "io.netty.util.ReferenceCountUtil.release",
        "source": "-",
        "sourceLine": 454,
        "qualifier": "Call to io.netty.util.ReferenceCountUtil.release with untrusted data from [msg : Http2StreamFrame](1).",
        "line_number": 454,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 325
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleServerConnectionHandler.java#L57",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.transport;\n\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\n\nimport java.io.IOException;\nimport java.net.SocketException;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.handler.codec.http2.DefaultHttp2ResetFrame;\nimport io.netty.handler.codec.http2.Http2ChannelDuplexHandler;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2GoAwayFrame;\nimport io.netty.handler.codec.http2.Http2PingFrame;\nimport io.netty.util.ReferenceCountUtil;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_RESPONSE;\nimport static org.apache.dubbo.rpc.protocol.tri.transport.GracefulShutdown.GRACEFUL_SHUTDOWN_PING;\n\npublic class TripleServerConnectionHandler extends Http2ChannelDuplexHandler {\n    private static final ErrorTypeAwareLogger logger =\n            LoggerFactory.getErrorTypeAwareLogger(TripleServerConnectionHandler.class);\n    // Some exceptions are not very useful and add too much noise to the log\n    private static final Set<String> QUIET_EXCEPTIONS = new HashSet<>();\n    private static final Set<Class<?>> QUIET_EXCEPTIONS_CLASS = new HashSet<>();\n\n    static {\n        QUIET_EXCEPTIONS.add(\"NativeIoException\");\n        QUIET_EXCEPTIONS_CLASS.add(IOException.class);\n        QUIET_EXCEPTIONS_CLASS.add(SocketException.class);\n    }\n\n    private GracefulShutdown gracefulShutdown;\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        if (msg instanceof Http2PingFrame) {\n            if (((Http2PingFrame) msg).content() == GRACEFUL_SHUTDOWN_PING) {\n                if (gracefulShutdown == null) {\n                    // this should never happen\n                    logger.warn(\n                            PROTOCOL_FAILED_RESPONSE,\n                            \"\",\n                            \"\",\n                            \"Received GRACEFUL_SHUTDOWN_PING Ack but gracefulShutdown is null\");\n                } else {\n                    gracefulShutdown.secondGoAwayAndClose(ctx);\n                }\n            }\n        } else if (msg instanceof Http2GoAwayFrame) {\n            ReferenceCountUtil.release(msg);\n        } else {\n            super.channelRead(ctx, msg);\n        }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        super.channelInactive(ctx);\n        // reset all active stream on connection close\n        forEachActiveStream(stream -> {\n            DefaultHttp2ResetFrame resetFrame = new DefaultHttp2ResetFrame(Http2Error.NO_ERROR).stream(stream);\n            ctx.fireChannelRead(resetFrame);\n            return true;\n        });\n    }\n\n    private boolean isQuiteException(Throwable t) {\n        if (QUIET_EXCEPTIONS_CLASS.contains(t.getClass())) {\n            return true;\n        }\n        return QUIET_EXCEPTIONS.contains(t.getClass().getSimpleName());\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        super.userEventTriggered(ctx, evt);\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        // this may be change in future follow https://github.com/apache/dubbo/pull/8644\n        if (isQuiteException(cause)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(String.format(\"Channel:%s Error\", ctx.channel()), cause);\n            }\n        } else {\n            logger.warn(PROTOCOL_FAILED_RESPONSE, \"\", \"\", String.format(\"Channel:%s Error\", ctx.channel()), cause);\n        }\n        ctx.close();\n    }\n\n    @Override\n    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n        if (gracefulShutdown == null) {\n            gracefulShutdown = new GracefulShutdown(ctx, \"app_requested\", promise);\n        }\n        gracefulShutdown.gracefulShutdown();\n    }\n}\n",
        "methodName": null,
        "exampleID": 326,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleServerConnectionHandler.java",
        "line": 57,
        "sink": "io.netty.handler.codec.http2.Http2PingFrame.content",
        "source": "-",
        "sourceLine": 57,
        "qualifier": "Call to io.netty.handler.codec.http2.Http2PingFrame.content with untrusted data from [msg : Object](1).",
        "line_number": 57,
        "steps": [
            {
                "line": 55,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleServerConnectionHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleServerConnectionHandler.java",
                "methodName": null,
                "exampleID": 327
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleServerConnectionHandler.java#L70",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.transport;\n\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\n\nimport java.io.IOException;\nimport java.net.SocketException;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.handler.codec.http2.DefaultHttp2ResetFrame;\nimport io.netty.handler.codec.http2.Http2ChannelDuplexHandler;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2GoAwayFrame;\nimport io.netty.handler.codec.http2.Http2PingFrame;\nimport io.netty.util.ReferenceCountUtil;\n\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_RESPONSE;\nimport static org.apache.dubbo.rpc.protocol.tri.transport.GracefulShutdown.GRACEFUL_SHUTDOWN_PING;\n\npublic class TripleServerConnectionHandler extends Http2ChannelDuplexHandler {\n    private static final ErrorTypeAwareLogger logger =\n            LoggerFactory.getErrorTypeAwareLogger(TripleServerConnectionHandler.class);\n    // Some exceptions are not very useful and add too much noise to the log\n    private static final Set<String> QUIET_EXCEPTIONS = new HashSet<>();\n    private static final Set<Class<?>> QUIET_EXCEPTIONS_CLASS = new HashSet<>();\n\n    static {\n        QUIET_EXCEPTIONS.add(\"NativeIoException\");\n        QUIET_EXCEPTIONS_CLASS.add(IOException.class);\n        QUIET_EXCEPTIONS_CLASS.add(SocketException.class);\n    }\n\n    private GracefulShutdown gracefulShutdown;\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        if (msg instanceof Http2PingFrame) {\n            if (((Http2PingFrame) msg).content() == GRACEFUL_SHUTDOWN_PING) {\n                if (gracefulShutdown == null) {\n                    // this should never happen\n                    logger.warn(\n                            PROTOCOL_FAILED_RESPONSE,\n                            \"\",\n                            \"\",\n                            \"Received GRACEFUL_SHUTDOWN_PING Ack but gracefulShutdown is null\");\n                } else {\n                    gracefulShutdown.secondGoAwayAndClose(ctx);\n                }\n            }\n        } else if (msg instanceof Http2GoAwayFrame) {\n            ReferenceCountUtil.release(msg);\n        } else {\n            super.channelRead(ctx, msg);\n        }\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        super.channelInactive(ctx);\n        // reset all active stream on connection close\n        forEachActiveStream(stream -> {\n            DefaultHttp2ResetFrame resetFrame = new DefaultHttp2ResetFrame(Http2Error.NO_ERROR).stream(stream);\n            ctx.fireChannelRead(resetFrame);\n            return true;\n        });\n    }\n\n    private boolean isQuiteException(Throwable t) {\n        if (QUIET_EXCEPTIONS_CLASS.contains(t.getClass())) {\n            return true;\n        }\n        return QUIET_EXCEPTIONS.contains(t.getClass().getSimpleName());\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        super.userEventTriggered(ctx, evt);\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        // this may be change in future follow https://github.com/apache/dubbo/pull/8644\n        if (isQuiteException(cause)) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(String.format(\"Channel:%s Error\", ctx.channel()), cause);\n            }\n        } else {\n            logger.warn(PROTOCOL_FAILED_RESPONSE, \"\", \"\", String.format(\"Channel:%s Error\", ctx.channel()), cause);\n        }\n        ctx.close();\n    }\n\n    @Override\n    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n        if (gracefulShutdown == null) {\n            gracefulShutdown = new GracefulShutdown(ctx, \"app_requested\", promise);\n        }\n        gracefulShutdown.gracefulShutdown();\n    }\n}\n",
        "methodName": null,
        "exampleID": 328,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleServerConnectionHandler.java",
        "line": 70,
        "sink": "io.netty.util.ReferenceCountUtil.release",
        "source": "-",
        "sourceLine": 70,
        "qualifier": "Call to io.netty.util.ReferenceCountUtil.release with untrusted data from [msg : Object](1).",
        "line_number": 70,
        "steps": [
            {
                "line": 55,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleServerConnectionHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleServerConnectionHandler.java",
                "methodName": null,
                "exampleID": 329
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java#L302",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.HeaderFilter;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.PathResolver;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.TripleProtocol;\nimport org.apache.dubbo.rpc.protocol.tri.call.ReflectionAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.call.StubAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.TextDataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.Future;\n\nimport static io.netty.handler.codec.http.HttpResponseStatus.OK;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\n\npublic class TripleServerStream extends AbstractStream implements ServerStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleServerStream.class);\n    public final ServerTransportObserver transportObserver = new ServerTransportObserver();\n    private final TripleWriteQueue writeQueue;\n    private final PathResolver pathResolver;\n    private final List<HeaderFilter> filters;\n    private final String acceptEncoding;\n    private boolean headerSent;\n    private boolean trailersSent;\n    private volatile boolean reset;\n    private ServerStream.Listener listener;\n    private final InetSocketAddress remoteAddress;\n    private Deframer deframer;\n    private boolean rst = false;\n    private final Http2StreamChannel http2StreamChannel;\n    private final TripleStreamChannelFuture tripleStreamChannelFuture;\n\n    public TripleServerStream(\n            Http2StreamChannel channel,\n            FrameworkModel frameworkModel,\n            Executor executor,\n            PathResolver pathResolver,\n            String acceptEncoding,\n            List<HeaderFilter> filters,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.pathResolver = pathResolver;\n        this.acceptEncoding = acceptEncoding;\n        this.filters = filters;\n        this.writeQueue = writeQueue;\n        this.remoteAddress = (InetSocketAddress) channel.remoteAddress();\n        this.http2StreamChannel = channel;\n        this.tripleStreamChannelFuture = new TripleStreamChannelFuture(channel);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return remoteAddress;\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    public ChannelFuture reset(Http2Error cause) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        this.rst = true;\n        return writeQueue.enqueue(CancelQueueCommand.createCommand(tripleStreamChannelFuture, cause));\n    }\n\n    @Override\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more headers allowed\"));\n        }\n        if (headerSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Header already sent\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    @Override\n    public Future<?> cancelByLocal(TriRpcStatus status) {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(String.format(\"Cancel stream:%s by local: %s\", http2StreamChannel, status));\n        }\n        return reset(Http2Error.CANCEL);\n    }\n\n    @Override\n    public ChannelFuture complete(\n            TriRpcStatus status, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        Http2Headers trailers =\n                getTrailers(status, attachments, isNeedReturnException, CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS);\n        return sendTrailers(trailers);\n    }\n\n    private ChannelFuture sendTrailers(Http2Headers trailers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more trailers allowed\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        trailersSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, trailers, true))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    private Http2Headers getTrailers(\n            TriRpcStatus rpcStatus, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        if (!headerSent) {\n            headers.status(HttpResponseStatus.OK.codeAsText());\n            headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        }\n        StreamUtils.convertAttachment(headers, attachments, TripleProtocol.CONVERT_NO_LOWER_HEADER);\n        headers.set(TripleHeaderEnum.STATUS_KEY.getHeader(), String.valueOf(rpcStatus.code.code));\n        if (rpcStatus.isOk()) {\n            return headers;\n        }\n        String grpcMessage = getGrpcMessage(rpcStatus);\n        grpcMessage = TriRpcStatus.encodeMessage(TriRpcStatus.limitSizeTo1KB(grpcMessage));\n        headers.set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), grpcMessage);\n        if (!getGrpcStatusDetailEnabled()) {\n            return headers;\n        }\n        Status.Builder builder =\n                Status.newBuilder().setCode(rpcStatus.code.code).setMessage(grpcMessage);\n        Throwable throwable = rpcStatus.cause;\n        if (throwable == null) {\n            Status status = builder.build();\n            headers.set(\n                    TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(),\n                    StreamUtils.encodeBase64ASCII(status.toByteArray()));\n            return headers;\n        }\n        DebugInfo debugInfo = DebugInfo.newBuilder()\n                .addAllStackEntries(ExceptionUtils.getStackFrameList(throwable, 6))\n                // can not use now\n                // .setDetail(throwable.getMessage())\n                .build();\n        builder.addDetails(Any.pack(debugInfo));\n        Status status = builder.build();\n        headers.set(\n                TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(), StreamUtils.encodeBase64ASCII(status.toByteArray()));\n        return headers;\n    }\n\n    private String getGrpcMessage(TriRpcStatus status) {\n        if (StringUtils.isNotEmpty(status.description)) {\n            return status.description;\n        }\n        return Optional.ofNullable(status.cause).map(Throwable::getMessage).orElse(\"unknown\");\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more body allowed\"));\n        }\n        if (!headerSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Headers did not sent before send body\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Trailers already sent, no more body allowed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        return writeQueue.enqueue(DataQueueCommand.create(tripleStreamChannelFuture, message, false, compressFlag));\n    }\n\n    /**\n     * Error before create server stream, http plain text will be returned\n     *\n     * @param code   code of error\n     * @param status status of error\n     */\n    private void responsePlainTextError(int code, TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return;\n        }\n        Http2Headers headers = new DefaultHttp2Headers(true)\n                .status(String.valueOf(code))\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.description)\n                .set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(), TripleConstant.TEXT_PLAIN_UTF8);\n        writeQueue.enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false));\n        writeQueue.enqueue(TextDataQueueCommand.createCommand(tripleStreamChannelFuture, status.description, true));\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error. There is no return value\n     * because stream will be reset if send trailers failed.\n     *\n     * @param status status of error\n     */\n    private void responseErr(TriRpcStatus status) {\n        Http2Headers trailers = new DefaultHttp2Headers()\n                .status(OK.codeAsText())\n                .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.toEncodedMessage());\n        sendTrailers(trailers);\n    }\n\n    private Invoker<?> getInvoker(Http2Headers headers, String serviceName) {\n        final String version = headers.contains(TripleHeaderEnum.SERVICE_VERSION.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_VERSION.getHeader()).toString()\n                : null;\n        final String group = headers.contains(TripleHeaderEnum.SERVICE_GROUP.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_GROUP.getHeader()).toString()\n                : null;\n        final String key = URL.buildKey(serviceName, group, version);\n        Invoker<?> invoker = pathResolver.resolve(key);\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(URL.buildKey(serviceName, group, \"1.0.0\"));\n        }\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(serviceName);\n        }\n        return invoker;\n    }\n\n    private ChannelFuture preCheck() {\n        if (!http2StreamChannel.isActive()) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel is closed\"));\n        }\n        if (rst) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return http2StreamChannel.newSucceededFuture();\n    }\n\n    public class ServerTransportObserver extends AbstractH2TransportListener implements H2TransportListener {\n\n        /**\n         * must starts from application/grpc\n         */\n        private boolean supportContentType(String contentType) {\n            if (contentType == null) {\n                return false;\n            }\n            return contentType.startsWith(TripleConstant.APPLICATION_GRPC);\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> processHeader(headers, endStream));\n        }\n\n        private void processHeader(Http2Headers headers, boolean endStream) {\n            if (!HttpMethod.POST.asciiName().contentEquals(headers.method())) {\n                responsePlainTextError(\n                        HttpResponseStatus.METHOD_NOT_ALLOWED.code(),\n                        TriRpcStatus.INTERNAL.withDescription(\n                                String.format(\"Method '%s' is not supported\", headers.method())));\n                return;\n            }\n\n            if (headers.path() == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(\"Expected path but is missing\"));\n                return;\n            }\n\n            final String path = headers.path().toString();\n            if (path.charAt(0) != '/') {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Expected path to start with /: %s\", path)));\n                return;\n            }\n\n            final CharSequence contentType = HttpUtil.getMimeType(headers.get(HttpHeaderNames.CONTENT_TYPE));\n            if (contentType == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(\"Content-Type is missing from the request\"));\n                return;\n            }\n\n            final String contentString = contentType.toString();\n            if (!supportContentType(contentString)) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(String.format(\"Content-Type '%s' is not supported\", contentString)));\n                return;\n            }\n\n            String[] parts = path.split(\"/\");\n            if (parts.length != 3) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Bad path format:\" + path));\n                return;\n            }\n            String serviceName = parts[1];\n            String originalMethodName = parts[2];\n\n            Invoker<?> invoker = getInvoker(headers, serviceName);\n            if (invoker == null) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n                return;\n            }\n\n            if (endStream) {\n                return;\n            }\n\n            DeCompressor deCompressor = DeCompressor.NONE;\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.MESSAGE_ENCODING.equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        responseErr(TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr)));\n                        return;\n                    }\n                    deCompressor = compressor;\n                }\n            }\n\n            Map<String, Object> requestMetadata = headersToMap(\n                    headers, () -> Optional.ofNullable(headers.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()))\n                            .map(CharSequence::toString)\n                            .orElse(null));\n            boolean hasStub = pathResolver.hasNativeStub(path);\n            if (hasStub) {\n                listener = new StubAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        executor);\n            } else {\n                listener = new ReflectionAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        filters,\n                        executor);\n            }\n            // must before onHeader\n            deframer = new TriDecoder(deCompressor, new ServerDecoderListener(listener));\n            listener.onHeader(requestMetadata);\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_REQUEST, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (deframer == null) {\n                ReferenceCountUtil.release(data);\n                return;\n            }\n            deframer.deframe(data);\n            if (endStream) {\n                deframer.close();\n            }\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            TripleServerStream.this.reset = true;\n            if (!trailersSent) {\n                // send rst if stream not closed\n                reset(Http2Error.valueOf(errorCode));\n            }\n            if (listener == null) {\n                return;\n            }\n            executor.execute(() -> listener.onCancelByRemote(\n                    TriRpcStatus.CANCELLED.withDescription(\"Canceled by client ,errorCode=\" + errorCode)));\n        }\n    }\n\n    private static class ServerDecoderListener implements TriDecoder.Listener {\n\n        private final ServerStream.Listener listener;\n\n        public ServerDecoderListener(ServerStream.Listener listener) {\n            this.listener = listener;\n        }\n\n        @Override\n        public void onRawMessage(byte[] data) {\n            listener.onMessage(data, false);\n        }\n\n        @Override\n        public void close() {\n            listener.onComplete();\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 330,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java",
        "line": 302,
        "sink": "io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get",
        "source": "-",
        "sourceLine": 302,
        "qualifier": "Call to io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get with untrusted data from [msg : Http2StreamFrame](1).\nCall to io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get with untrusted data from [msg : Object](2).",
        "line_number": 302,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 331
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 331
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java#L368",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.HeaderFilter;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.PathResolver;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.TripleProtocol;\nimport org.apache.dubbo.rpc.protocol.tri.call.ReflectionAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.call.StubAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.TextDataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.Future;\n\nimport static io.netty.handler.codec.http.HttpResponseStatus.OK;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\n\npublic class TripleServerStream extends AbstractStream implements ServerStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleServerStream.class);\n    public final ServerTransportObserver transportObserver = new ServerTransportObserver();\n    private final TripleWriteQueue writeQueue;\n    private final PathResolver pathResolver;\n    private final List<HeaderFilter> filters;\n    private final String acceptEncoding;\n    private boolean headerSent;\n    private boolean trailersSent;\n    private volatile boolean reset;\n    private ServerStream.Listener listener;\n    private final InetSocketAddress remoteAddress;\n    private Deframer deframer;\n    private boolean rst = false;\n    private final Http2StreamChannel http2StreamChannel;\n    private final TripleStreamChannelFuture tripleStreamChannelFuture;\n\n    public TripleServerStream(\n            Http2StreamChannel channel,\n            FrameworkModel frameworkModel,\n            Executor executor,\n            PathResolver pathResolver,\n            String acceptEncoding,\n            List<HeaderFilter> filters,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.pathResolver = pathResolver;\n        this.acceptEncoding = acceptEncoding;\n        this.filters = filters;\n        this.writeQueue = writeQueue;\n        this.remoteAddress = (InetSocketAddress) channel.remoteAddress();\n        this.http2StreamChannel = channel;\n        this.tripleStreamChannelFuture = new TripleStreamChannelFuture(channel);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return remoteAddress;\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    public ChannelFuture reset(Http2Error cause) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        this.rst = true;\n        return writeQueue.enqueue(CancelQueueCommand.createCommand(tripleStreamChannelFuture, cause));\n    }\n\n    @Override\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more headers allowed\"));\n        }\n        if (headerSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Header already sent\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    @Override\n    public Future<?> cancelByLocal(TriRpcStatus status) {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(String.format(\"Cancel stream:%s by local: %s\", http2StreamChannel, status));\n        }\n        return reset(Http2Error.CANCEL);\n    }\n\n    @Override\n    public ChannelFuture complete(\n            TriRpcStatus status, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        Http2Headers trailers =\n                getTrailers(status, attachments, isNeedReturnException, CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS);\n        return sendTrailers(trailers);\n    }\n\n    private ChannelFuture sendTrailers(Http2Headers trailers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more trailers allowed\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        trailersSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, trailers, true))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    private Http2Headers getTrailers(\n            TriRpcStatus rpcStatus, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        if (!headerSent) {\n            headers.status(HttpResponseStatus.OK.codeAsText());\n            headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        }\n        StreamUtils.convertAttachment(headers, attachments, TripleProtocol.CONVERT_NO_LOWER_HEADER);\n        headers.set(TripleHeaderEnum.STATUS_KEY.getHeader(), String.valueOf(rpcStatus.code.code));\n        if (rpcStatus.isOk()) {\n            return headers;\n        }\n        String grpcMessage = getGrpcMessage(rpcStatus);\n        grpcMessage = TriRpcStatus.encodeMessage(TriRpcStatus.limitSizeTo1KB(grpcMessage));\n        headers.set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), grpcMessage);\n        if (!getGrpcStatusDetailEnabled()) {\n            return headers;\n        }\n        Status.Builder builder =\n                Status.newBuilder().setCode(rpcStatus.code.code).setMessage(grpcMessage);\n        Throwable throwable = rpcStatus.cause;\n        if (throwable == null) {\n            Status status = builder.build();\n            headers.set(\n                    TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(),\n                    StreamUtils.encodeBase64ASCII(status.toByteArray()));\n            return headers;\n        }\n        DebugInfo debugInfo = DebugInfo.newBuilder()\n                .addAllStackEntries(ExceptionUtils.getStackFrameList(throwable, 6))\n                // can not use now\n                // .setDetail(throwable.getMessage())\n                .build();\n        builder.addDetails(Any.pack(debugInfo));\n        Status status = builder.build();\n        headers.set(\n                TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(), StreamUtils.encodeBase64ASCII(status.toByteArray()));\n        return headers;\n    }\n\n    private String getGrpcMessage(TriRpcStatus status) {\n        if (StringUtils.isNotEmpty(status.description)) {\n            return status.description;\n        }\n        return Optional.ofNullable(status.cause).map(Throwable::getMessage).orElse(\"unknown\");\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more body allowed\"));\n        }\n        if (!headerSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Headers did not sent before send body\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Trailers already sent, no more body allowed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        return writeQueue.enqueue(DataQueueCommand.create(tripleStreamChannelFuture, message, false, compressFlag));\n    }\n\n    /**\n     * Error before create server stream, http plain text will be returned\n     *\n     * @param code   code of error\n     * @param status status of error\n     */\n    private void responsePlainTextError(int code, TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return;\n        }\n        Http2Headers headers = new DefaultHttp2Headers(true)\n                .status(String.valueOf(code))\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.description)\n                .set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(), TripleConstant.TEXT_PLAIN_UTF8);\n        writeQueue.enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false));\n        writeQueue.enqueue(TextDataQueueCommand.createCommand(tripleStreamChannelFuture, status.description, true));\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error. There is no return value\n     * because stream will be reset if send trailers failed.\n     *\n     * @param status status of error\n     */\n    private void responseErr(TriRpcStatus status) {\n        Http2Headers trailers = new DefaultHttp2Headers()\n                .status(OK.codeAsText())\n                .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.toEncodedMessage());\n        sendTrailers(trailers);\n    }\n\n    private Invoker<?> getInvoker(Http2Headers headers, String serviceName) {\n        final String version = headers.contains(TripleHeaderEnum.SERVICE_VERSION.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_VERSION.getHeader()).toString()\n                : null;\n        final String group = headers.contains(TripleHeaderEnum.SERVICE_GROUP.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_GROUP.getHeader()).toString()\n                : null;\n        final String key = URL.buildKey(serviceName, group, version);\n        Invoker<?> invoker = pathResolver.resolve(key);\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(URL.buildKey(serviceName, group, \"1.0.0\"));\n        }\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(serviceName);\n        }\n        return invoker;\n    }\n\n    private ChannelFuture preCheck() {\n        if (!http2StreamChannel.isActive()) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel is closed\"));\n        }\n        if (rst) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return http2StreamChannel.newSucceededFuture();\n    }\n\n    public class ServerTransportObserver extends AbstractH2TransportListener implements H2TransportListener {\n\n        /**\n         * must starts from application/grpc\n         */\n        private boolean supportContentType(String contentType) {\n            if (contentType == null) {\n                return false;\n            }\n            return contentType.startsWith(TripleConstant.APPLICATION_GRPC);\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> processHeader(headers, endStream));\n        }\n\n        private void processHeader(Http2Headers headers, boolean endStream) {\n            if (!HttpMethod.POST.asciiName().contentEquals(headers.method())) {\n                responsePlainTextError(\n                        HttpResponseStatus.METHOD_NOT_ALLOWED.code(),\n                        TriRpcStatus.INTERNAL.withDescription(\n                                String.format(\"Method '%s' is not supported\", headers.method())));\n                return;\n            }\n\n            if (headers.path() == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(\"Expected path but is missing\"));\n                return;\n            }\n\n            final String path = headers.path().toString();\n            if (path.charAt(0) != '/') {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Expected path to start with /: %s\", path)));\n                return;\n            }\n\n            final CharSequence contentType = HttpUtil.getMimeType(headers.get(HttpHeaderNames.CONTENT_TYPE));\n            if (contentType == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(\"Content-Type is missing from the request\"));\n                return;\n            }\n\n            final String contentString = contentType.toString();\n            if (!supportContentType(contentString)) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(String.format(\"Content-Type '%s' is not supported\", contentString)));\n                return;\n            }\n\n            String[] parts = path.split(\"/\");\n            if (parts.length != 3) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Bad path format:\" + path));\n                return;\n            }\n            String serviceName = parts[1];\n            String originalMethodName = parts[2];\n\n            Invoker<?> invoker = getInvoker(headers, serviceName);\n            if (invoker == null) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n                return;\n            }\n\n            if (endStream) {\n                return;\n            }\n\n            DeCompressor deCompressor = DeCompressor.NONE;\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.MESSAGE_ENCODING.equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        responseErr(TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr)));\n                        return;\n                    }\n                    deCompressor = compressor;\n                }\n            }\n\n            Map<String, Object> requestMetadata = headersToMap(\n                    headers, () -> Optional.ofNullable(headers.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()))\n                            .map(CharSequence::toString)\n                            .orElse(null));\n            boolean hasStub = pathResolver.hasNativeStub(path);\n            if (hasStub) {\n                listener = new StubAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        executor);\n            } else {\n                listener = new ReflectionAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        filters,\n                        executor);\n            }\n            // must before onHeader\n            deframer = new TriDecoder(deCompressor, new ServerDecoderListener(listener));\n            listener.onHeader(requestMetadata);\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_REQUEST, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (deframer == null) {\n                ReferenceCountUtil.release(data);\n                return;\n            }\n            deframer.deframe(data);\n            if (endStream) {\n                deframer.close();\n            }\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            TripleServerStream.this.reset = true;\n            if (!trailersSent) {\n                // send rst if stream not closed\n                reset(Http2Error.valueOf(errorCode));\n            }\n            if (listener == null) {\n                return;\n            }\n            executor.execute(() -> listener.onCancelByRemote(\n                    TriRpcStatus.CANCELLED.withDescription(\"Canceled by client ,errorCode=\" + errorCode)));\n        }\n    }\n\n    private static class ServerDecoderListener implements TriDecoder.Listener {\n\n        private final ServerStream.Listener listener;\n\n        public ServerDecoderListener(ServerStream.Listener listener) {\n            this.listener = listener;\n        }\n\n        @Override\n        public void onRawMessage(byte[] data) {\n            listener.onMessage(data, false);\n        }\n\n        @Override\n        public void close() {\n            listener.onComplete();\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 332,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java",
        "line": 368,
        "sink": "io.netty.handler.codec.http.HttpUtil.getMimeType",
        "source": "-",
        "sourceLine": 368,
        "qualifier": "Call to io.netty.handler.codec.http.HttpUtil.getMimeType with untrusted data from [msg : Http2StreamFrame](1).\nCall to io.netty.handler.codec.http.HttpUtil.getMimeType with untrusted data from [msg : Object](2).",
        "line_number": 368,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 333
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 333
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java#L420",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.HeaderFilter;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.PathResolver;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.TripleProtocol;\nimport org.apache.dubbo.rpc.protocol.tri.call.ReflectionAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.call.StubAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.TextDataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.Future;\n\nimport static io.netty.handler.codec.http.HttpResponseStatus.OK;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\n\npublic class TripleServerStream extends AbstractStream implements ServerStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleServerStream.class);\n    public final ServerTransportObserver transportObserver = new ServerTransportObserver();\n    private final TripleWriteQueue writeQueue;\n    private final PathResolver pathResolver;\n    private final List<HeaderFilter> filters;\n    private final String acceptEncoding;\n    private boolean headerSent;\n    private boolean trailersSent;\n    private volatile boolean reset;\n    private ServerStream.Listener listener;\n    private final InetSocketAddress remoteAddress;\n    private Deframer deframer;\n    private boolean rst = false;\n    private final Http2StreamChannel http2StreamChannel;\n    private final TripleStreamChannelFuture tripleStreamChannelFuture;\n\n    public TripleServerStream(\n            Http2StreamChannel channel,\n            FrameworkModel frameworkModel,\n            Executor executor,\n            PathResolver pathResolver,\n            String acceptEncoding,\n            List<HeaderFilter> filters,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.pathResolver = pathResolver;\n        this.acceptEncoding = acceptEncoding;\n        this.filters = filters;\n        this.writeQueue = writeQueue;\n        this.remoteAddress = (InetSocketAddress) channel.remoteAddress();\n        this.http2StreamChannel = channel;\n        this.tripleStreamChannelFuture = new TripleStreamChannelFuture(channel);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return remoteAddress;\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    public ChannelFuture reset(Http2Error cause) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        this.rst = true;\n        return writeQueue.enqueue(CancelQueueCommand.createCommand(tripleStreamChannelFuture, cause));\n    }\n\n    @Override\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more headers allowed\"));\n        }\n        if (headerSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Header already sent\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    @Override\n    public Future<?> cancelByLocal(TriRpcStatus status) {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(String.format(\"Cancel stream:%s by local: %s\", http2StreamChannel, status));\n        }\n        return reset(Http2Error.CANCEL);\n    }\n\n    @Override\n    public ChannelFuture complete(\n            TriRpcStatus status, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        Http2Headers trailers =\n                getTrailers(status, attachments, isNeedReturnException, CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS);\n        return sendTrailers(trailers);\n    }\n\n    private ChannelFuture sendTrailers(Http2Headers trailers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more trailers allowed\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        trailersSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, trailers, true))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    private Http2Headers getTrailers(\n            TriRpcStatus rpcStatus, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        if (!headerSent) {\n            headers.status(HttpResponseStatus.OK.codeAsText());\n            headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        }\n        StreamUtils.convertAttachment(headers, attachments, TripleProtocol.CONVERT_NO_LOWER_HEADER);\n        headers.set(TripleHeaderEnum.STATUS_KEY.getHeader(), String.valueOf(rpcStatus.code.code));\n        if (rpcStatus.isOk()) {\n            return headers;\n        }\n        String grpcMessage = getGrpcMessage(rpcStatus);\n        grpcMessage = TriRpcStatus.encodeMessage(TriRpcStatus.limitSizeTo1KB(grpcMessage));\n        headers.set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), grpcMessage);\n        if (!getGrpcStatusDetailEnabled()) {\n            return headers;\n        }\n        Status.Builder builder =\n                Status.newBuilder().setCode(rpcStatus.code.code).setMessage(grpcMessage);\n        Throwable throwable = rpcStatus.cause;\n        if (throwable == null) {\n            Status status = builder.build();\n            headers.set(\n                    TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(),\n                    StreamUtils.encodeBase64ASCII(status.toByteArray()));\n            return headers;\n        }\n        DebugInfo debugInfo = DebugInfo.newBuilder()\n                .addAllStackEntries(ExceptionUtils.getStackFrameList(throwable, 6))\n                // can not use now\n                // .setDetail(throwable.getMessage())\n                .build();\n        builder.addDetails(Any.pack(debugInfo));\n        Status status = builder.build();\n        headers.set(\n                TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(), StreamUtils.encodeBase64ASCII(status.toByteArray()));\n        return headers;\n    }\n\n    private String getGrpcMessage(TriRpcStatus status) {\n        if (StringUtils.isNotEmpty(status.description)) {\n            return status.description;\n        }\n        return Optional.ofNullable(status.cause).map(Throwable::getMessage).orElse(\"unknown\");\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more body allowed\"));\n        }\n        if (!headerSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Headers did not sent before send body\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Trailers already sent, no more body allowed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        return writeQueue.enqueue(DataQueueCommand.create(tripleStreamChannelFuture, message, false, compressFlag));\n    }\n\n    /**\n     * Error before create server stream, http plain text will be returned\n     *\n     * @param code   code of error\n     * @param status status of error\n     */\n    private void responsePlainTextError(int code, TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return;\n        }\n        Http2Headers headers = new DefaultHttp2Headers(true)\n                .status(String.valueOf(code))\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.description)\n                .set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(), TripleConstant.TEXT_PLAIN_UTF8);\n        writeQueue.enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false));\n        writeQueue.enqueue(TextDataQueueCommand.createCommand(tripleStreamChannelFuture, status.description, true));\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error. There is no return value\n     * because stream will be reset if send trailers failed.\n     *\n     * @param status status of error\n     */\n    private void responseErr(TriRpcStatus status) {\n        Http2Headers trailers = new DefaultHttp2Headers()\n                .status(OK.codeAsText())\n                .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.toEncodedMessage());\n        sendTrailers(trailers);\n    }\n\n    private Invoker<?> getInvoker(Http2Headers headers, String serviceName) {\n        final String version = headers.contains(TripleHeaderEnum.SERVICE_VERSION.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_VERSION.getHeader()).toString()\n                : null;\n        final String group = headers.contains(TripleHeaderEnum.SERVICE_GROUP.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_GROUP.getHeader()).toString()\n                : null;\n        final String key = URL.buildKey(serviceName, group, version);\n        Invoker<?> invoker = pathResolver.resolve(key);\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(URL.buildKey(serviceName, group, \"1.0.0\"));\n        }\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(serviceName);\n        }\n        return invoker;\n    }\n\n    private ChannelFuture preCheck() {\n        if (!http2StreamChannel.isActive()) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel is closed\"));\n        }\n        if (rst) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return http2StreamChannel.newSucceededFuture();\n    }\n\n    public class ServerTransportObserver extends AbstractH2TransportListener implements H2TransportListener {\n\n        /**\n         * must starts from application/grpc\n         */\n        private boolean supportContentType(String contentType) {\n            if (contentType == null) {\n                return false;\n            }\n            return contentType.startsWith(TripleConstant.APPLICATION_GRPC);\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> processHeader(headers, endStream));\n        }\n\n        private void processHeader(Http2Headers headers, boolean endStream) {\n            if (!HttpMethod.POST.asciiName().contentEquals(headers.method())) {\n                responsePlainTextError(\n                        HttpResponseStatus.METHOD_NOT_ALLOWED.code(),\n                        TriRpcStatus.INTERNAL.withDescription(\n                                String.format(\"Method '%s' is not supported\", headers.method())));\n                return;\n            }\n\n            if (headers.path() == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(\"Expected path but is missing\"));\n                return;\n            }\n\n            final String path = headers.path().toString();\n            if (path.charAt(0) != '/') {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Expected path to start with /: %s\", path)));\n                return;\n            }\n\n            final CharSequence contentType = HttpUtil.getMimeType(headers.get(HttpHeaderNames.CONTENT_TYPE));\n            if (contentType == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(\"Content-Type is missing from the request\"));\n                return;\n            }\n\n            final String contentString = contentType.toString();\n            if (!supportContentType(contentString)) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(String.format(\"Content-Type '%s' is not supported\", contentString)));\n                return;\n            }\n\n            String[] parts = path.split(\"/\");\n            if (parts.length != 3) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Bad path format:\" + path));\n                return;\n            }\n            String serviceName = parts[1];\n            String originalMethodName = parts[2];\n\n            Invoker<?> invoker = getInvoker(headers, serviceName);\n            if (invoker == null) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n                return;\n            }\n\n            if (endStream) {\n                return;\n            }\n\n            DeCompressor deCompressor = DeCompressor.NONE;\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.MESSAGE_ENCODING.equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        responseErr(TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr)));\n                        return;\n                    }\n                    deCompressor = compressor;\n                }\n            }\n\n            Map<String, Object> requestMetadata = headersToMap(\n                    headers, () -> Optional.ofNullable(headers.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()))\n                            .map(CharSequence::toString)\n                            .orElse(null));\n            boolean hasStub = pathResolver.hasNativeStub(path);\n            if (hasStub) {\n                listener = new StubAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        executor);\n            } else {\n                listener = new ReflectionAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        filters,\n                        executor);\n            }\n            // must before onHeader\n            deframer = new TriDecoder(deCompressor, new ServerDecoderListener(listener));\n            listener.onHeader(requestMetadata);\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_REQUEST, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (deframer == null) {\n                ReferenceCountUtil.release(data);\n                return;\n            }\n            deframer.deframe(data);\n            if (endStream) {\n                deframer.close();\n            }\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            TripleServerStream.this.reset = true;\n            if (!trailersSent) {\n                // send rst if stream not closed\n                reset(Http2Error.valueOf(errorCode));\n            }\n            if (listener == null) {\n                return;\n            }\n            executor.execute(() -> listener.onCancelByRemote(\n                    TriRpcStatus.CANCELLED.withDescription(\"Canceled by client ,errorCode=\" + errorCode)));\n        }\n    }\n\n    private static class ServerDecoderListener implements TriDecoder.Listener {\n\n        private final ServerStream.Listener listener;\n\n        public ServerDecoderListener(ServerStream.Listener listener) {\n            this.listener = listener;\n        }\n\n        @Override\n        public void onRawMessage(byte[] data) {\n            listener.onMessage(data, false);\n        }\n\n        @Override\n        public void close() {\n            listener.onComplete();\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 334,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java",
        "line": 420,
        "sink": "io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get",
        "source": "-",
        "sourceLine": 420,
        "qualifier": "Call to io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get with untrusted data from [msg : Http2StreamFrame](1).\nCall to io.netty.handler.codec.Headers<CharSequence,CharSequence,Http2Headers>.get with untrusted data from [msg : Object](2).",
        "line_number": 420,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 335
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 335
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java#L343",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.HeaderFilter;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.PathResolver;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.TripleProtocol;\nimport org.apache.dubbo.rpc.protocol.tri.call.ReflectionAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.call.StubAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.TextDataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.Future;\n\nimport static io.netty.handler.codec.http.HttpResponseStatus.OK;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\n\npublic class TripleServerStream extends AbstractStream implements ServerStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleServerStream.class);\n    public final ServerTransportObserver transportObserver = new ServerTransportObserver();\n    private final TripleWriteQueue writeQueue;\n    private final PathResolver pathResolver;\n    private final List<HeaderFilter> filters;\n    private final String acceptEncoding;\n    private boolean headerSent;\n    private boolean trailersSent;\n    private volatile boolean reset;\n    private ServerStream.Listener listener;\n    private final InetSocketAddress remoteAddress;\n    private Deframer deframer;\n    private boolean rst = false;\n    private final Http2StreamChannel http2StreamChannel;\n    private final TripleStreamChannelFuture tripleStreamChannelFuture;\n\n    public TripleServerStream(\n            Http2StreamChannel channel,\n            FrameworkModel frameworkModel,\n            Executor executor,\n            PathResolver pathResolver,\n            String acceptEncoding,\n            List<HeaderFilter> filters,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.pathResolver = pathResolver;\n        this.acceptEncoding = acceptEncoding;\n        this.filters = filters;\n        this.writeQueue = writeQueue;\n        this.remoteAddress = (InetSocketAddress) channel.remoteAddress();\n        this.http2StreamChannel = channel;\n        this.tripleStreamChannelFuture = new TripleStreamChannelFuture(channel);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return remoteAddress;\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    public ChannelFuture reset(Http2Error cause) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        this.rst = true;\n        return writeQueue.enqueue(CancelQueueCommand.createCommand(tripleStreamChannelFuture, cause));\n    }\n\n    @Override\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more headers allowed\"));\n        }\n        if (headerSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Header already sent\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    @Override\n    public Future<?> cancelByLocal(TriRpcStatus status) {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(String.format(\"Cancel stream:%s by local: %s\", http2StreamChannel, status));\n        }\n        return reset(Http2Error.CANCEL);\n    }\n\n    @Override\n    public ChannelFuture complete(\n            TriRpcStatus status, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        Http2Headers trailers =\n                getTrailers(status, attachments, isNeedReturnException, CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS);\n        return sendTrailers(trailers);\n    }\n\n    private ChannelFuture sendTrailers(Http2Headers trailers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more trailers allowed\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        trailersSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, trailers, true))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    private Http2Headers getTrailers(\n            TriRpcStatus rpcStatus, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        if (!headerSent) {\n            headers.status(HttpResponseStatus.OK.codeAsText());\n            headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        }\n        StreamUtils.convertAttachment(headers, attachments, TripleProtocol.CONVERT_NO_LOWER_HEADER);\n        headers.set(TripleHeaderEnum.STATUS_KEY.getHeader(), String.valueOf(rpcStatus.code.code));\n        if (rpcStatus.isOk()) {\n            return headers;\n        }\n        String grpcMessage = getGrpcMessage(rpcStatus);\n        grpcMessage = TriRpcStatus.encodeMessage(TriRpcStatus.limitSizeTo1KB(grpcMessage));\n        headers.set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), grpcMessage);\n        if (!getGrpcStatusDetailEnabled()) {\n            return headers;\n        }\n        Status.Builder builder =\n                Status.newBuilder().setCode(rpcStatus.code.code).setMessage(grpcMessage);\n        Throwable throwable = rpcStatus.cause;\n        if (throwable == null) {\n            Status status = builder.build();\n            headers.set(\n                    TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(),\n                    StreamUtils.encodeBase64ASCII(status.toByteArray()));\n            return headers;\n        }\n        DebugInfo debugInfo = DebugInfo.newBuilder()\n                .addAllStackEntries(ExceptionUtils.getStackFrameList(throwable, 6))\n                // can not use now\n                // .setDetail(throwable.getMessage())\n                .build();\n        builder.addDetails(Any.pack(debugInfo));\n        Status status = builder.build();\n        headers.set(\n                TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(), StreamUtils.encodeBase64ASCII(status.toByteArray()));\n        return headers;\n    }\n\n    private String getGrpcMessage(TriRpcStatus status) {\n        if (StringUtils.isNotEmpty(status.description)) {\n            return status.description;\n        }\n        return Optional.ofNullable(status.cause).map(Throwable::getMessage).orElse(\"unknown\");\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more body allowed\"));\n        }\n        if (!headerSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Headers did not sent before send body\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Trailers already sent, no more body allowed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        return writeQueue.enqueue(DataQueueCommand.create(tripleStreamChannelFuture, message, false, compressFlag));\n    }\n\n    /**\n     * Error before create server stream, http plain text will be returned\n     *\n     * @param code   code of error\n     * @param status status of error\n     */\n    private void responsePlainTextError(int code, TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return;\n        }\n        Http2Headers headers = new DefaultHttp2Headers(true)\n                .status(String.valueOf(code))\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.description)\n                .set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(), TripleConstant.TEXT_PLAIN_UTF8);\n        writeQueue.enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false));\n        writeQueue.enqueue(TextDataQueueCommand.createCommand(tripleStreamChannelFuture, status.description, true));\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error. There is no return value\n     * because stream will be reset if send trailers failed.\n     *\n     * @param status status of error\n     */\n    private void responseErr(TriRpcStatus status) {\n        Http2Headers trailers = new DefaultHttp2Headers()\n                .status(OK.codeAsText())\n                .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.toEncodedMessage());\n        sendTrailers(trailers);\n    }\n\n    private Invoker<?> getInvoker(Http2Headers headers, String serviceName) {\n        final String version = headers.contains(TripleHeaderEnum.SERVICE_VERSION.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_VERSION.getHeader()).toString()\n                : null;\n        final String group = headers.contains(TripleHeaderEnum.SERVICE_GROUP.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_GROUP.getHeader()).toString()\n                : null;\n        final String key = URL.buildKey(serviceName, group, version);\n        Invoker<?> invoker = pathResolver.resolve(key);\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(URL.buildKey(serviceName, group, \"1.0.0\"));\n        }\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(serviceName);\n        }\n        return invoker;\n    }\n\n    private ChannelFuture preCheck() {\n        if (!http2StreamChannel.isActive()) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel is closed\"));\n        }\n        if (rst) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return http2StreamChannel.newSucceededFuture();\n    }\n\n    public class ServerTransportObserver extends AbstractH2TransportListener implements H2TransportListener {\n\n        /**\n         * must starts from application/grpc\n         */\n        private boolean supportContentType(String contentType) {\n            if (contentType == null) {\n                return false;\n            }\n            return contentType.startsWith(TripleConstant.APPLICATION_GRPC);\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> processHeader(headers, endStream));\n        }\n\n        private void processHeader(Http2Headers headers, boolean endStream) {\n            if (!HttpMethod.POST.asciiName().contentEquals(headers.method())) {\n                responsePlainTextError(\n                        HttpResponseStatus.METHOD_NOT_ALLOWED.code(),\n                        TriRpcStatus.INTERNAL.withDescription(\n                                String.format(\"Method '%s' is not supported\", headers.method())));\n                return;\n            }\n\n            if (headers.path() == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(\"Expected path but is missing\"));\n                return;\n            }\n\n            final String path = headers.path().toString();\n            if (path.charAt(0) != '/') {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Expected path to start with /: %s\", path)));\n                return;\n            }\n\n            final CharSequence contentType = HttpUtil.getMimeType(headers.get(HttpHeaderNames.CONTENT_TYPE));\n            if (contentType == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(\"Content-Type is missing from the request\"));\n                return;\n            }\n\n            final String contentString = contentType.toString();\n            if (!supportContentType(contentString)) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(String.format(\"Content-Type '%s' is not supported\", contentString)));\n                return;\n            }\n\n            String[] parts = path.split(\"/\");\n            if (parts.length != 3) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Bad path format:\" + path));\n                return;\n            }\n            String serviceName = parts[1];\n            String originalMethodName = parts[2];\n\n            Invoker<?> invoker = getInvoker(headers, serviceName);\n            if (invoker == null) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n                return;\n            }\n\n            if (endStream) {\n                return;\n            }\n\n            DeCompressor deCompressor = DeCompressor.NONE;\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.MESSAGE_ENCODING.equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        responseErr(TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr)));\n                        return;\n                    }\n                    deCompressor = compressor;\n                }\n            }\n\n            Map<String, Object> requestMetadata = headersToMap(\n                    headers, () -> Optional.ofNullable(headers.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()))\n                            .map(CharSequence::toString)\n                            .orElse(null));\n            boolean hasStub = pathResolver.hasNativeStub(path);\n            if (hasStub) {\n                listener = new StubAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        executor);\n            } else {\n                listener = new ReflectionAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        filters,\n                        executor);\n            }\n            // must before onHeader\n            deframer = new TriDecoder(deCompressor, new ServerDecoderListener(listener));\n            listener.onHeader(requestMetadata);\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_REQUEST, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (deframer == null) {\n                ReferenceCountUtil.release(data);\n                return;\n            }\n            deframer.deframe(data);\n            if (endStream) {\n                deframer.close();\n            }\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            TripleServerStream.this.reset = true;\n            if (!trailersSent) {\n                // send rst if stream not closed\n                reset(Http2Error.valueOf(errorCode));\n            }\n            if (listener == null) {\n                return;\n            }\n            executor.execute(() -> listener.onCancelByRemote(\n                    TriRpcStatus.CANCELLED.withDescription(\"Canceled by client ,errorCode=\" + errorCode)));\n        }\n    }\n\n    private static class ServerDecoderListener implements TriDecoder.Listener {\n\n        private final ServerStream.Listener listener;\n\n        public ServerDecoderListener(ServerStream.Listener listener) {\n            this.listener = listener;\n        }\n\n        @Override\n        public void onRawMessage(byte[] data) {\n            listener.onMessage(data, false);\n        }\n\n        @Override\n        public void close() {\n            listener.onComplete();\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 336,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java",
        "line": 343,
        "sink": "io.netty.util.AsciiString.contentEquals",
        "source": "-",
        "sourceLine": 343,
        "qualifier": "Call to io.netty.util.AsciiString.contentEquals with untrusted data from [msg : Http2StreamFrame](1).\nCall to io.netty.util.AsciiString.contentEquals with untrusted data from [msg : Object](2).",
        "line_number": 343,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 337
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 337
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java#L347",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.HeaderFilter;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.PathResolver;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.TripleProtocol;\nimport org.apache.dubbo.rpc.protocol.tri.call.ReflectionAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.call.StubAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.TextDataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.Future;\n\nimport static io.netty.handler.codec.http.HttpResponseStatus.OK;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\n\npublic class TripleServerStream extends AbstractStream implements ServerStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleServerStream.class);\n    public final ServerTransportObserver transportObserver = new ServerTransportObserver();\n    private final TripleWriteQueue writeQueue;\n    private final PathResolver pathResolver;\n    private final List<HeaderFilter> filters;\n    private final String acceptEncoding;\n    private boolean headerSent;\n    private boolean trailersSent;\n    private volatile boolean reset;\n    private ServerStream.Listener listener;\n    private final InetSocketAddress remoteAddress;\n    private Deframer deframer;\n    private boolean rst = false;\n    private final Http2StreamChannel http2StreamChannel;\n    private final TripleStreamChannelFuture tripleStreamChannelFuture;\n\n    public TripleServerStream(\n            Http2StreamChannel channel,\n            FrameworkModel frameworkModel,\n            Executor executor,\n            PathResolver pathResolver,\n            String acceptEncoding,\n            List<HeaderFilter> filters,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.pathResolver = pathResolver;\n        this.acceptEncoding = acceptEncoding;\n        this.filters = filters;\n        this.writeQueue = writeQueue;\n        this.remoteAddress = (InetSocketAddress) channel.remoteAddress();\n        this.http2StreamChannel = channel;\n        this.tripleStreamChannelFuture = new TripleStreamChannelFuture(channel);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return remoteAddress;\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    public ChannelFuture reset(Http2Error cause) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        this.rst = true;\n        return writeQueue.enqueue(CancelQueueCommand.createCommand(tripleStreamChannelFuture, cause));\n    }\n\n    @Override\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more headers allowed\"));\n        }\n        if (headerSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Header already sent\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    @Override\n    public Future<?> cancelByLocal(TriRpcStatus status) {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(String.format(\"Cancel stream:%s by local: %s\", http2StreamChannel, status));\n        }\n        return reset(Http2Error.CANCEL);\n    }\n\n    @Override\n    public ChannelFuture complete(\n            TriRpcStatus status, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        Http2Headers trailers =\n                getTrailers(status, attachments, isNeedReturnException, CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS);\n        return sendTrailers(trailers);\n    }\n\n    private ChannelFuture sendTrailers(Http2Headers trailers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more trailers allowed\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        trailersSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, trailers, true))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    private Http2Headers getTrailers(\n            TriRpcStatus rpcStatus, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        if (!headerSent) {\n            headers.status(HttpResponseStatus.OK.codeAsText());\n            headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        }\n        StreamUtils.convertAttachment(headers, attachments, TripleProtocol.CONVERT_NO_LOWER_HEADER);\n        headers.set(TripleHeaderEnum.STATUS_KEY.getHeader(), String.valueOf(rpcStatus.code.code));\n        if (rpcStatus.isOk()) {\n            return headers;\n        }\n        String grpcMessage = getGrpcMessage(rpcStatus);\n        grpcMessage = TriRpcStatus.encodeMessage(TriRpcStatus.limitSizeTo1KB(grpcMessage));\n        headers.set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), grpcMessage);\n        if (!getGrpcStatusDetailEnabled()) {\n            return headers;\n        }\n        Status.Builder builder =\n                Status.newBuilder().setCode(rpcStatus.code.code).setMessage(grpcMessage);\n        Throwable throwable = rpcStatus.cause;\n        if (throwable == null) {\n            Status status = builder.build();\n            headers.set(\n                    TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(),\n                    StreamUtils.encodeBase64ASCII(status.toByteArray()));\n            return headers;\n        }\n        DebugInfo debugInfo = DebugInfo.newBuilder()\n                .addAllStackEntries(ExceptionUtils.getStackFrameList(throwable, 6))\n                // can not use now\n                // .setDetail(throwable.getMessage())\n                .build();\n        builder.addDetails(Any.pack(debugInfo));\n        Status status = builder.build();\n        headers.set(\n                TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(), StreamUtils.encodeBase64ASCII(status.toByteArray()));\n        return headers;\n    }\n\n    private String getGrpcMessage(TriRpcStatus status) {\n        if (StringUtils.isNotEmpty(status.description)) {\n            return status.description;\n        }\n        return Optional.ofNullable(status.cause).map(Throwable::getMessage).orElse(\"unknown\");\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more body allowed\"));\n        }\n        if (!headerSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Headers did not sent before send body\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Trailers already sent, no more body allowed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        return writeQueue.enqueue(DataQueueCommand.create(tripleStreamChannelFuture, message, false, compressFlag));\n    }\n\n    /**\n     * Error before create server stream, http plain text will be returned\n     *\n     * @param code   code of error\n     * @param status status of error\n     */\n    private void responsePlainTextError(int code, TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return;\n        }\n        Http2Headers headers = new DefaultHttp2Headers(true)\n                .status(String.valueOf(code))\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.description)\n                .set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(), TripleConstant.TEXT_PLAIN_UTF8);\n        writeQueue.enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false));\n        writeQueue.enqueue(TextDataQueueCommand.createCommand(tripleStreamChannelFuture, status.description, true));\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error. There is no return value\n     * because stream will be reset if send trailers failed.\n     *\n     * @param status status of error\n     */\n    private void responseErr(TriRpcStatus status) {\n        Http2Headers trailers = new DefaultHttp2Headers()\n                .status(OK.codeAsText())\n                .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.toEncodedMessage());\n        sendTrailers(trailers);\n    }\n\n    private Invoker<?> getInvoker(Http2Headers headers, String serviceName) {\n        final String version = headers.contains(TripleHeaderEnum.SERVICE_VERSION.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_VERSION.getHeader()).toString()\n                : null;\n        final String group = headers.contains(TripleHeaderEnum.SERVICE_GROUP.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_GROUP.getHeader()).toString()\n                : null;\n        final String key = URL.buildKey(serviceName, group, version);\n        Invoker<?> invoker = pathResolver.resolve(key);\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(URL.buildKey(serviceName, group, \"1.0.0\"));\n        }\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(serviceName);\n        }\n        return invoker;\n    }\n\n    private ChannelFuture preCheck() {\n        if (!http2StreamChannel.isActive()) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel is closed\"));\n        }\n        if (rst) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return http2StreamChannel.newSucceededFuture();\n    }\n\n    public class ServerTransportObserver extends AbstractH2TransportListener implements H2TransportListener {\n\n        /**\n         * must starts from application/grpc\n         */\n        private boolean supportContentType(String contentType) {\n            if (contentType == null) {\n                return false;\n            }\n            return contentType.startsWith(TripleConstant.APPLICATION_GRPC);\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> processHeader(headers, endStream));\n        }\n\n        private void processHeader(Http2Headers headers, boolean endStream) {\n            if (!HttpMethod.POST.asciiName().contentEquals(headers.method())) {\n                responsePlainTextError(\n                        HttpResponseStatus.METHOD_NOT_ALLOWED.code(),\n                        TriRpcStatus.INTERNAL.withDescription(\n                                String.format(\"Method '%s' is not supported\", headers.method())));\n                return;\n            }\n\n            if (headers.path() == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(\"Expected path but is missing\"));\n                return;\n            }\n\n            final String path = headers.path().toString();\n            if (path.charAt(0) != '/') {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Expected path to start with /: %s\", path)));\n                return;\n            }\n\n            final CharSequence contentType = HttpUtil.getMimeType(headers.get(HttpHeaderNames.CONTENT_TYPE));\n            if (contentType == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(\"Content-Type is missing from the request\"));\n                return;\n            }\n\n            final String contentString = contentType.toString();\n            if (!supportContentType(contentString)) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(String.format(\"Content-Type '%s' is not supported\", contentString)));\n                return;\n            }\n\n            String[] parts = path.split(\"/\");\n            if (parts.length != 3) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Bad path format:\" + path));\n                return;\n            }\n            String serviceName = parts[1];\n            String originalMethodName = parts[2];\n\n            Invoker<?> invoker = getInvoker(headers, serviceName);\n            if (invoker == null) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n                return;\n            }\n\n            if (endStream) {\n                return;\n            }\n\n            DeCompressor deCompressor = DeCompressor.NONE;\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.MESSAGE_ENCODING.equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        responseErr(TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr)));\n                        return;\n                    }\n                    deCompressor = compressor;\n                }\n            }\n\n            Map<String, Object> requestMetadata = headersToMap(\n                    headers, () -> Optional.ofNullable(headers.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()))\n                            .map(CharSequence::toString)\n                            .orElse(null));\n            boolean hasStub = pathResolver.hasNativeStub(path);\n            if (hasStub) {\n                listener = new StubAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        executor);\n            } else {\n                listener = new ReflectionAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        filters,\n                        executor);\n            }\n            // must before onHeader\n            deframer = new TriDecoder(deCompressor, new ServerDecoderListener(listener));\n            listener.onHeader(requestMetadata);\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_REQUEST, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (deframer == null) {\n                ReferenceCountUtil.release(data);\n                return;\n            }\n            deframer.deframe(data);\n            if (endStream) {\n                deframer.close();\n            }\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            TripleServerStream.this.reset = true;\n            if (!trailersSent) {\n                // send rst if stream not closed\n                reset(Http2Error.valueOf(errorCode));\n            }\n            if (listener == null) {\n                return;\n            }\n            executor.execute(() -> listener.onCancelByRemote(\n                    TriRpcStatus.CANCELLED.withDescription(\"Canceled by client ,errorCode=\" + errorCode)));\n        }\n    }\n\n    private static class ServerDecoderListener implements TriDecoder.Listener {\n\n        private final ServerStream.Listener listener;\n\n        public ServerDecoderListener(ServerStream.Listener listener) {\n            this.listener = listener;\n        }\n\n        @Override\n        public void onRawMessage(byte[] data) {\n            listener.onMessage(data, false);\n        }\n\n        @Override\n        public void close() {\n            listener.onComplete();\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 338,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java",
        "line": 347,
        "sink": "io.netty.handler.codec.http2.Http2Headers.method",
        "source": "-",
        "sourceLine": 347,
        "qualifier": "Call to io.netty.handler.codec.http2.Http2Headers.method with untrusted data from [msg : Http2StreamFrame](1).\nCall to io.netty.handler.codec.http2.Http2Headers.method with untrusted data from [msg : Object](2).",
        "line_number": 347,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 339
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 339
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java#L457",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.HeaderFilter;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.PathResolver;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.TripleProtocol;\nimport org.apache.dubbo.rpc.protocol.tri.call.ReflectionAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.call.StubAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.TextDataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.Future;\n\nimport static io.netty.handler.codec.http.HttpResponseStatus.OK;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\n\npublic class TripleServerStream extends AbstractStream implements ServerStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleServerStream.class);\n    public final ServerTransportObserver transportObserver = new ServerTransportObserver();\n    private final TripleWriteQueue writeQueue;\n    private final PathResolver pathResolver;\n    private final List<HeaderFilter> filters;\n    private final String acceptEncoding;\n    private boolean headerSent;\n    private boolean trailersSent;\n    private volatile boolean reset;\n    private ServerStream.Listener listener;\n    private final InetSocketAddress remoteAddress;\n    private Deframer deframer;\n    private boolean rst = false;\n    private final Http2StreamChannel http2StreamChannel;\n    private final TripleStreamChannelFuture tripleStreamChannelFuture;\n\n    public TripleServerStream(\n            Http2StreamChannel channel,\n            FrameworkModel frameworkModel,\n            Executor executor,\n            PathResolver pathResolver,\n            String acceptEncoding,\n            List<HeaderFilter> filters,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.pathResolver = pathResolver;\n        this.acceptEncoding = acceptEncoding;\n        this.filters = filters;\n        this.writeQueue = writeQueue;\n        this.remoteAddress = (InetSocketAddress) channel.remoteAddress();\n        this.http2StreamChannel = channel;\n        this.tripleStreamChannelFuture = new TripleStreamChannelFuture(channel);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return remoteAddress;\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    public ChannelFuture reset(Http2Error cause) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        this.rst = true;\n        return writeQueue.enqueue(CancelQueueCommand.createCommand(tripleStreamChannelFuture, cause));\n    }\n\n    @Override\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more headers allowed\"));\n        }\n        if (headerSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Header already sent\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    @Override\n    public Future<?> cancelByLocal(TriRpcStatus status) {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(String.format(\"Cancel stream:%s by local: %s\", http2StreamChannel, status));\n        }\n        return reset(Http2Error.CANCEL);\n    }\n\n    @Override\n    public ChannelFuture complete(\n            TriRpcStatus status, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        Http2Headers trailers =\n                getTrailers(status, attachments, isNeedReturnException, CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS);\n        return sendTrailers(trailers);\n    }\n\n    private ChannelFuture sendTrailers(Http2Headers trailers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more trailers allowed\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        trailersSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, trailers, true))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    private Http2Headers getTrailers(\n            TriRpcStatus rpcStatus, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        if (!headerSent) {\n            headers.status(HttpResponseStatus.OK.codeAsText());\n            headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        }\n        StreamUtils.convertAttachment(headers, attachments, TripleProtocol.CONVERT_NO_LOWER_HEADER);\n        headers.set(TripleHeaderEnum.STATUS_KEY.getHeader(), String.valueOf(rpcStatus.code.code));\n        if (rpcStatus.isOk()) {\n            return headers;\n        }\n        String grpcMessage = getGrpcMessage(rpcStatus);\n        grpcMessage = TriRpcStatus.encodeMessage(TriRpcStatus.limitSizeTo1KB(grpcMessage));\n        headers.set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), grpcMessage);\n        if (!getGrpcStatusDetailEnabled()) {\n            return headers;\n        }\n        Status.Builder builder =\n                Status.newBuilder().setCode(rpcStatus.code.code).setMessage(grpcMessage);\n        Throwable throwable = rpcStatus.cause;\n        if (throwable == null) {\n            Status status = builder.build();\n            headers.set(\n                    TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(),\n                    StreamUtils.encodeBase64ASCII(status.toByteArray()));\n            return headers;\n        }\n        DebugInfo debugInfo = DebugInfo.newBuilder()\n                .addAllStackEntries(ExceptionUtils.getStackFrameList(throwable, 6))\n                // can not use now\n                // .setDetail(throwable.getMessage())\n                .build();\n        builder.addDetails(Any.pack(debugInfo));\n        Status status = builder.build();\n        headers.set(\n                TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(), StreamUtils.encodeBase64ASCII(status.toByteArray()));\n        return headers;\n    }\n\n    private String getGrpcMessage(TriRpcStatus status) {\n        if (StringUtils.isNotEmpty(status.description)) {\n            return status.description;\n        }\n        return Optional.ofNullable(status.cause).map(Throwable::getMessage).orElse(\"unknown\");\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more body allowed\"));\n        }\n        if (!headerSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Headers did not sent before send body\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Trailers already sent, no more body allowed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        return writeQueue.enqueue(DataQueueCommand.create(tripleStreamChannelFuture, message, false, compressFlag));\n    }\n\n    /**\n     * Error before create server stream, http plain text will be returned\n     *\n     * @param code   code of error\n     * @param status status of error\n     */\n    private void responsePlainTextError(int code, TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return;\n        }\n        Http2Headers headers = new DefaultHttp2Headers(true)\n                .status(String.valueOf(code))\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.description)\n                .set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(), TripleConstant.TEXT_PLAIN_UTF8);\n        writeQueue.enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false));\n        writeQueue.enqueue(TextDataQueueCommand.createCommand(tripleStreamChannelFuture, status.description, true));\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error. There is no return value\n     * because stream will be reset if send trailers failed.\n     *\n     * @param status status of error\n     */\n    private void responseErr(TriRpcStatus status) {\n        Http2Headers trailers = new DefaultHttp2Headers()\n                .status(OK.codeAsText())\n                .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.toEncodedMessage());\n        sendTrailers(trailers);\n    }\n\n    private Invoker<?> getInvoker(Http2Headers headers, String serviceName) {\n        final String version = headers.contains(TripleHeaderEnum.SERVICE_VERSION.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_VERSION.getHeader()).toString()\n                : null;\n        final String group = headers.contains(TripleHeaderEnum.SERVICE_GROUP.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_GROUP.getHeader()).toString()\n                : null;\n        final String key = URL.buildKey(serviceName, group, version);\n        Invoker<?> invoker = pathResolver.resolve(key);\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(URL.buildKey(serviceName, group, \"1.0.0\"));\n        }\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(serviceName);\n        }\n        return invoker;\n    }\n\n    private ChannelFuture preCheck() {\n        if (!http2StreamChannel.isActive()) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel is closed\"));\n        }\n        if (rst) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return http2StreamChannel.newSucceededFuture();\n    }\n\n    public class ServerTransportObserver extends AbstractH2TransportListener implements H2TransportListener {\n\n        /**\n         * must starts from application/grpc\n         */\n        private boolean supportContentType(String contentType) {\n            if (contentType == null) {\n                return false;\n            }\n            return contentType.startsWith(TripleConstant.APPLICATION_GRPC);\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> processHeader(headers, endStream));\n        }\n\n        private void processHeader(Http2Headers headers, boolean endStream) {\n            if (!HttpMethod.POST.asciiName().contentEquals(headers.method())) {\n                responsePlainTextError(\n                        HttpResponseStatus.METHOD_NOT_ALLOWED.code(),\n                        TriRpcStatus.INTERNAL.withDescription(\n                                String.format(\"Method '%s' is not supported\", headers.method())));\n                return;\n            }\n\n            if (headers.path() == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(\"Expected path but is missing\"));\n                return;\n            }\n\n            final String path = headers.path().toString();\n            if (path.charAt(0) != '/') {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Expected path to start with /: %s\", path)));\n                return;\n            }\n\n            final CharSequence contentType = HttpUtil.getMimeType(headers.get(HttpHeaderNames.CONTENT_TYPE));\n            if (contentType == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(\"Content-Type is missing from the request\"));\n                return;\n            }\n\n            final String contentString = contentType.toString();\n            if (!supportContentType(contentString)) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(String.format(\"Content-Type '%s' is not supported\", contentString)));\n                return;\n            }\n\n            String[] parts = path.split(\"/\");\n            if (parts.length != 3) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Bad path format:\" + path));\n                return;\n            }\n            String serviceName = parts[1];\n            String originalMethodName = parts[2];\n\n            Invoker<?> invoker = getInvoker(headers, serviceName);\n            if (invoker == null) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n                return;\n            }\n\n            if (endStream) {\n                return;\n            }\n\n            DeCompressor deCompressor = DeCompressor.NONE;\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.MESSAGE_ENCODING.equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        responseErr(TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr)));\n                        return;\n                    }\n                    deCompressor = compressor;\n                }\n            }\n\n            Map<String, Object> requestMetadata = headersToMap(\n                    headers, () -> Optional.ofNullable(headers.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()))\n                            .map(CharSequence::toString)\n                            .orElse(null));\n            boolean hasStub = pathResolver.hasNativeStub(path);\n            if (hasStub) {\n                listener = new StubAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        executor);\n            } else {\n                listener = new ReflectionAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        filters,\n                        executor);\n            }\n            // must before onHeader\n            deframer = new TriDecoder(deCompressor, new ServerDecoderListener(listener));\n            listener.onHeader(requestMetadata);\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_REQUEST, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (deframer == null) {\n                ReferenceCountUtil.release(data);\n                return;\n            }\n            deframer.deframe(data);\n            if (endStream) {\n                deframer.close();\n            }\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            TripleServerStream.this.reset = true;\n            if (!trailersSent) {\n                // send rst if stream not closed\n                reset(Http2Error.valueOf(errorCode));\n            }\n            if (listener == null) {\n                return;\n            }\n            executor.execute(() -> listener.onCancelByRemote(\n                    TriRpcStatus.CANCELLED.withDescription(\"Canceled by client ,errorCode=\" + errorCode)));\n        }\n    }\n\n    private static class ServerDecoderListener implements TriDecoder.Listener {\n\n        private final ServerStream.Listener listener;\n\n        public ServerDecoderListener(ServerStream.Listener listener) {\n            this.listener = listener;\n        }\n\n        @Override\n        public void onRawMessage(byte[] data) {\n            listener.onMessage(data, false);\n        }\n\n        @Override\n        public void close() {\n            listener.onComplete();\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 340,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java",
        "line": 457,
        "sink": "io.netty.util.ReferenceCountUtil.release",
        "source": "-",
        "sourceLine": 457,
        "qualifier": "Call to io.netty.util.ReferenceCountUtil.release with untrusted data from [msg : Http2StreamFrame](1).\nCall to io.netty.util.ReferenceCountUtil.release with untrusted data from [msg : Object](2).",
        "line_number": 457,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 341
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 341
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java#L464",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.rpc.protocol.tri.stream;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.constants.CommonConstants;\nimport org.apache.dubbo.common.logger.ErrorTypeAwareLogger;\nimport org.apache.dubbo.common.logger.LoggerFactory;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.rpc.HeaderFilter;\nimport org.apache.dubbo.rpc.Invoker;\nimport org.apache.dubbo.rpc.PathResolver;\nimport org.apache.dubbo.rpc.TriRpcStatus;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\nimport org.apache.dubbo.rpc.protocol.tri.ExceptionUtils;\nimport org.apache.dubbo.rpc.protocol.tri.TripleConstant;\nimport org.apache.dubbo.rpc.protocol.tri.TripleHeaderEnum;\nimport org.apache.dubbo.rpc.protocol.tri.TripleProtocol;\nimport org.apache.dubbo.rpc.protocol.tri.call.ReflectionAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.call.StubAbstractServerCall;\nimport org.apache.dubbo.rpc.protocol.tri.command.CancelQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.DataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.HeaderQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.command.TextDataQueueCommand;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.DeCompressor;\nimport org.apache.dubbo.rpc.protocol.tri.compressor.Identity;\nimport org.apache.dubbo.rpc.protocol.tri.frame.Deframer;\nimport org.apache.dubbo.rpc.protocol.tri.frame.TriDecoder;\nimport org.apache.dubbo.rpc.protocol.tri.transport.AbstractH2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.H2TransportListener;\nimport org.apache.dubbo.rpc.protocol.tri.transport.TripleWriteQueue;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.Executor;\n\nimport com.google.protobuf.Any;\nimport com.google.rpc.DebugInfo;\nimport com.google.rpc.Status;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpMethod;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http2.DefaultHttp2Headers;\nimport io.netty.handler.codec.http2.Http2Error;\nimport io.netty.handler.codec.http2.Http2Headers;\nimport io.netty.handler.codec.http2.Http2StreamChannel;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.Future;\n\nimport static io.netty.handler.codec.http.HttpResponseStatus.OK;\nimport static org.apache.dubbo.common.constants.LoggerCodeConstants.PROTOCOL_FAILED_REQUEST;\n\npublic class TripleServerStream extends AbstractStream implements ServerStream {\n\n    private static final ErrorTypeAwareLogger LOGGER = LoggerFactory.getErrorTypeAwareLogger(TripleServerStream.class);\n    public final ServerTransportObserver transportObserver = new ServerTransportObserver();\n    private final TripleWriteQueue writeQueue;\n    private final PathResolver pathResolver;\n    private final List<HeaderFilter> filters;\n    private final String acceptEncoding;\n    private boolean headerSent;\n    private boolean trailersSent;\n    private volatile boolean reset;\n    private ServerStream.Listener listener;\n    private final InetSocketAddress remoteAddress;\n    private Deframer deframer;\n    private boolean rst = false;\n    private final Http2StreamChannel http2StreamChannel;\n    private final TripleStreamChannelFuture tripleStreamChannelFuture;\n\n    public TripleServerStream(\n            Http2StreamChannel channel,\n            FrameworkModel frameworkModel,\n            Executor executor,\n            PathResolver pathResolver,\n            String acceptEncoding,\n            List<HeaderFilter> filters,\n            TripleWriteQueue writeQueue) {\n        super(executor, frameworkModel);\n        this.pathResolver = pathResolver;\n        this.acceptEncoding = acceptEncoding;\n        this.filters = filters;\n        this.writeQueue = writeQueue;\n        this.remoteAddress = (InetSocketAddress) channel.remoteAddress();\n        this.http2StreamChannel = channel;\n        this.tripleStreamChannelFuture = new TripleStreamChannelFuture(channel);\n    }\n\n    @Override\n    public SocketAddress remoteAddress() {\n        return remoteAddress;\n    }\n\n    @Override\n    public void request(int n) {\n        deframer.request(n);\n    }\n\n    public ChannelFuture reset(Http2Error cause) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        this.rst = true;\n        return writeQueue.enqueue(CancelQueueCommand.createCommand(tripleStreamChannelFuture, cause));\n    }\n\n    @Override\n    public ChannelFuture sendHeader(Http2Headers headers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more headers allowed\"));\n        }\n        if (headerSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Header already sent\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    @Override\n    public Future<?> cancelByLocal(TriRpcStatus status) {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(String.format(\"Cancel stream:%s by local: %s\", http2StreamChannel, status));\n        }\n        return reset(Http2Error.CANCEL);\n    }\n\n    @Override\n    public ChannelFuture complete(\n            TriRpcStatus status, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        Http2Headers trailers =\n                getTrailers(status, attachments, isNeedReturnException, CommonConstants.TRI_EXCEPTION_CODE_NOT_EXISTS);\n        return sendTrailers(trailers);\n    }\n\n    private ChannelFuture sendTrailers(Http2Headers trailers) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more trailers allowed\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(new IllegalStateException(\"Trailers already sent\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        headerSent = true;\n        trailersSent = true;\n        return writeQueue\n                .enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, trailers, true))\n                .addListener(f -> {\n                    if (!f.isSuccess()) {\n                        reset(Http2Error.INTERNAL_ERROR);\n                    }\n                });\n    }\n\n    private Http2Headers getTrailers(\n            TriRpcStatus rpcStatus, Map<String, Object> attachments, boolean isNeedReturnException, int exceptionCode) {\n        DefaultHttp2Headers headers = new DefaultHttp2Headers();\n        if (!headerSent) {\n            headers.status(HttpResponseStatus.OK.codeAsText());\n            headers.set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO);\n        }\n        StreamUtils.convertAttachment(headers, attachments, TripleProtocol.CONVERT_NO_LOWER_HEADER);\n        headers.set(TripleHeaderEnum.STATUS_KEY.getHeader(), String.valueOf(rpcStatus.code.code));\n        if (rpcStatus.isOk()) {\n            return headers;\n        }\n        String grpcMessage = getGrpcMessage(rpcStatus);\n        grpcMessage = TriRpcStatus.encodeMessage(TriRpcStatus.limitSizeTo1KB(grpcMessage));\n        headers.set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), grpcMessage);\n        if (!getGrpcStatusDetailEnabled()) {\n            return headers;\n        }\n        Status.Builder builder =\n                Status.newBuilder().setCode(rpcStatus.code.code).setMessage(grpcMessage);\n        Throwable throwable = rpcStatus.cause;\n        if (throwable == null) {\n            Status status = builder.build();\n            headers.set(\n                    TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(),\n                    StreamUtils.encodeBase64ASCII(status.toByteArray()));\n            return headers;\n        }\n        DebugInfo debugInfo = DebugInfo.newBuilder()\n                .addAllStackEntries(ExceptionUtils.getStackFrameList(throwable, 6))\n                // can not use now\n                // .setDetail(throwable.getMessage())\n                .build();\n        builder.addDetails(Any.pack(debugInfo));\n        Status status = builder.build();\n        headers.set(\n                TripleHeaderEnum.STATUS_DETAIL_KEY.getHeader(), StreamUtils.encodeBase64ASCII(status.toByteArray()));\n        return headers;\n    }\n\n    private String getGrpcMessage(TriRpcStatus status) {\n        if (StringUtils.isNotEmpty(status.description)) {\n            return status.description;\n        }\n        return Optional.ofNullable(status.cause).map(Throwable::getMessage).orElse(\"unknown\");\n    }\n\n    @Override\n    public ChannelFuture sendMessage(byte[] message, int compressFlag) {\n        if (reset) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Stream already reset, no more body allowed\"));\n        }\n        if (!headerSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Headers did not sent before send body\"));\n        }\n        if (trailersSent) {\n            return http2StreamChannel.newFailedFuture(\n                    new IllegalStateException(\"Trailers already sent, no more body allowed\"));\n        }\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return checkResult;\n        }\n        return writeQueue.enqueue(DataQueueCommand.create(tripleStreamChannelFuture, message, false, compressFlag));\n    }\n\n    /**\n     * Error before create server stream, http plain text will be returned\n     *\n     * @param code   code of error\n     * @param status status of error\n     */\n    private void responsePlainTextError(int code, TriRpcStatus status) {\n        ChannelFuture checkResult = preCheck();\n        if (!checkResult.isSuccess()) {\n            return;\n        }\n        Http2Headers headers = new DefaultHttp2Headers(true)\n                .status(String.valueOf(code))\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.description)\n                .set(TripleHeaderEnum.CONTENT_TYPE_KEY.getHeader(), TripleConstant.TEXT_PLAIN_UTF8);\n        writeQueue.enqueue(HeaderQueueCommand.createHeaders(tripleStreamChannelFuture, headers, false));\n        writeQueue.enqueue(TextDataQueueCommand.createCommand(tripleStreamChannelFuture, status.description, true));\n    }\n\n    /**\n     * Error in create stream, unsupported config or triple protocol error. There is no return value\n     * because stream will be reset if send trailers failed.\n     *\n     * @param status status of error\n     */\n    private void responseErr(TriRpcStatus status) {\n        Http2Headers trailers = new DefaultHttp2Headers()\n                .status(OK.codeAsText())\n                .set(HttpHeaderNames.CONTENT_TYPE, TripleConstant.CONTENT_PROTO)\n                .setInt(TripleHeaderEnum.STATUS_KEY.getHeader(), status.code.code)\n                .set(TripleHeaderEnum.MESSAGE_KEY.getHeader(), status.toEncodedMessage());\n        sendTrailers(trailers);\n    }\n\n    private Invoker<?> getInvoker(Http2Headers headers, String serviceName) {\n        final String version = headers.contains(TripleHeaderEnum.SERVICE_VERSION.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_VERSION.getHeader()).toString()\n                : null;\n        final String group = headers.contains(TripleHeaderEnum.SERVICE_GROUP.getHeader())\n                ? headers.get(TripleHeaderEnum.SERVICE_GROUP.getHeader()).toString()\n                : null;\n        final String key = URL.buildKey(serviceName, group, version);\n        Invoker<?> invoker = pathResolver.resolve(key);\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(URL.buildKey(serviceName, group, \"1.0.0\"));\n        }\n        if (invoker == null && TripleProtocol.RESOLVE_FALLBACK_TO_DEFAULT) {\n            invoker = pathResolver.resolve(serviceName);\n        }\n        return invoker;\n    }\n\n    private ChannelFuture preCheck() {\n        if (!http2StreamChannel.isActive()) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel is closed\"));\n        }\n        if (rst) {\n            return http2StreamChannel.newFailedFuture(new IOException(\"stream channel has reset\"));\n        }\n        return http2StreamChannel.newSucceededFuture();\n    }\n\n    public class ServerTransportObserver extends AbstractH2TransportListener implements H2TransportListener {\n\n        /**\n         * must starts from application/grpc\n         */\n        private boolean supportContentType(String contentType) {\n            if (contentType == null) {\n                return false;\n            }\n            return contentType.startsWith(TripleConstant.APPLICATION_GRPC);\n        }\n\n        @Override\n        public void onHeader(Http2Headers headers, boolean endStream) {\n            executor.execute(() -> processHeader(headers, endStream));\n        }\n\n        private void processHeader(Http2Headers headers, boolean endStream) {\n            if (!HttpMethod.POST.asciiName().contentEquals(headers.method())) {\n                responsePlainTextError(\n                        HttpResponseStatus.METHOD_NOT_ALLOWED.code(),\n                        TriRpcStatus.INTERNAL.withDescription(\n                                String.format(\"Method '%s' is not supported\", headers.method())));\n                return;\n            }\n\n            if (headers.path() == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(\"Expected path but is missing\"));\n                return;\n            }\n\n            final String path = headers.path().toString();\n            if (path.charAt(0) != '/') {\n                responsePlainTextError(\n                        HttpResponseStatus.NOT_FOUND.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Expected path to start with /: %s\", path)));\n                return;\n            }\n\n            final CharSequence contentType = HttpUtil.getMimeType(headers.get(HttpHeaderNames.CONTENT_TYPE));\n            if (contentType == null) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(\"Content-Type is missing from the request\"));\n                return;\n            }\n\n            final String contentString = contentType.toString();\n            if (!supportContentType(contentString)) {\n                responsePlainTextError(\n                        HttpResponseStatus.UNSUPPORTED_MEDIA_TYPE.code(),\n                        TriRpcStatus.fromCode(TriRpcStatus.Code.INTERNAL.code)\n                                .withDescription(String.format(\"Content-Type '%s' is not supported\", contentString)));\n                return;\n            }\n\n            String[] parts = path.split(\"/\");\n            if (parts.length != 3) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Bad path format:\" + path));\n                return;\n            }\n            String serviceName = parts[1];\n            String originalMethodName = parts[2];\n\n            Invoker<?> invoker = getInvoker(headers, serviceName);\n            if (invoker == null) {\n                responseErr(TriRpcStatus.UNIMPLEMENTED.withDescription(\"Service not found:\" + serviceName));\n                return;\n            }\n\n            if (endStream) {\n                return;\n            }\n\n            DeCompressor deCompressor = DeCompressor.NONE;\n            CharSequence messageEncoding = headers.get(TripleHeaderEnum.GRPC_ENCODING.getHeader());\n            if (null != messageEncoding) {\n                String compressorStr = messageEncoding.toString();\n                if (!Identity.MESSAGE_ENCODING.equals(compressorStr)) {\n                    DeCompressor compressor = DeCompressor.getCompressor(frameworkModel, compressorStr);\n                    if (null == compressor) {\n                        responseErr(TriRpcStatus.fromCode(TriRpcStatus.Code.UNIMPLEMENTED.code)\n                                .withDescription(String.format(\"Grpc-encoding '%s' is not supported\", compressorStr)));\n                        return;\n                    }\n                    deCompressor = compressor;\n                }\n            }\n\n            Map<String, Object> requestMetadata = headersToMap(\n                    headers, () -> Optional.ofNullable(headers.get(TripleHeaderEnum.TRI_HEADER_CONVERT.getHeader()))\n                            .map(CharSequence::toString)\n                            .orElse(null));\n            boolean hasStub = pathResolver.hasNativeStub(path);\n            if (hasStub) {\n                listener = new StubAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        executor);\n            } else {\n                listener = new ReflectionAbstractServerCall(\n                        invoker,\n                        TripleServerStream.this,\n                        frameworkModel,\n                        acceptEncoding,\n                        serviceName,\n                        originalMethodName,\n                        filters,\n                        executor);\n            }\n            // must before onHeader\n            deframer = new TriDecoder(deCompressor, new ServerDecoderListener(listener));\n            listener.onHeader(requestMetadata);\n        }\n\n        @Override\n        public void onData(ByteBuf data, boolean endStream) {\n            try {\n                executor.execute(() -> doOnData(data, endStream));\n            } catch (Throwable t) {\n                // Tasks will be rejected when the thread pool is closed or full,\n                // ByteBuf needs to be released to avoid out of heap memory leakage.\n                // For example, ThreadLessExecutor will be shutdown when request timeout {@link AsyncRpcResult}\n                ReferenceCountUtil.release(data);\n                LOGGER.error(PROTOCOL_FAILED_REQUEST, \"\", \"\", \"submit onData task failed\", t);\n            }\n        }\n\n        private void doOnData(ByteBuf data, boolean endStream) {\n            if (deframer == null) {\n                ReferenceCountUtil.release(data);\n                return;\n            }\n            deframer.deframe(data);\n            if (endStream) {\n                deframer.close();\n            }\n        }\n\n        @Override\n        public void cancelByRemote(long errorCode) {\n            TripleServerStream.this.reset = true;\n            if (!trailersSent) {\n                // send rst if stream not closed\n                reset(Http2Error.valueOf(errorCode));\n            }\n            if (listener == null) {\n                return;\n            }\n            executor.execute(() -> listener.onCancelByRemote(\n                    TriRpcStatus.CANCELLED.withDescription(\"Canceled by client ,errorCode=\" + errorCode)));\n        }\n    }\n\n    private static class ServerDecoderListener implements TriDecoder.Listener {\n\n        private final ServerStream.Listener listener;\n\n        public ServerDecoderListener(ServerStream.Listener listener) {\n            this.listener = listener;\n        }\n\n        @Override\n        public void onRawMessage(byte[] data) {\n            listener.onMessage(data, false);\n        }\n\n        @Override\n        public void close() {\n            listener.onComplete();\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 342,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/stream/TripleServerStream.java",
        "line": 464,
        "sink": "io.netty.util.ReferenceCountUtil.release",
        "source": "-",
        "sourceLine": 464,
        "qualifier": "Call to io.netty.util.ReferenceCountUtil.release with untrusted data from [msg : Http2StreamFrame](1).\nCall to io.netty.util.ReferenceCountUtil.release with untrusted data from [msg : Object](2).",
        "line_number": 464,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 343
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 343
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java#L67",
        "rawCode": null,
        "methodName": null,
        "exampleID": 344,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java",
        "line": 67,
        "sink": "com.google.protobuf.MessageLite.toByteArray",
        "source": "-",
        "sourceLine": 67,
        "qualifier": "Call to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Http2StreamFrame](1).\nCall to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Object](2).",
        "line_number": 67,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 345
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 345
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 345
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 345
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java#L67",
        "rawCode": null,
        "methodName": null,
        "exampleID": 346,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java",
        "line": 67,
        "sink": "com.google.protobuf.MessageLite.toByteArray",
        "source": "-",
        "sourceLine": 67,
        "qualifier": "Call to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Http2StreamFrame](1).\nCall to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Object](2).",
        "line_number": 67,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 347
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 347
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 347
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 347
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java#L72",
        "rawCode": null,
        "methodName": null,
        "exampleID": 348,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java",
        "line": 72,
        "sink": "com.google.protobuf.MessageLite.toByteArray",
        "source": "-",
        "sourceLine": 72,
        "qualifier": "Call to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Http2StreamFrame](1).\nCall to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Object](2).",
        "line_number": 72,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 349
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 349
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 349
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 349
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java#L72",
        "rawCode": null,
        "methodName": null,
        "exampleID": 350,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java",
        "line": 72,
        "sink": "com.google.protobuf.MessageLite.toByteArray",
        "source": "-",
        "sourceLine": 72,
        "qualifier": "Call to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Http2StreamFrame](1).\nCall to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Object](2).",
        "line_number": 72,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 351
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 351
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 351
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 351
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java#L77",
        "rawCode": null,
        "methodName": null,
        "exampleID": 352,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java",
        "line": 77,
        "sink": "com.google.protobuf.MessageLite.toByteArray",
        "source": "-",
        "sourceLine": 77,
        "qualifier": "Call to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Http2StreamFrame](1).\nCall to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Object](2).",
        "line_number": 77,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 353
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 353
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 353
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 353
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java#L77",
        "rawCode": null,
        "methodName": null,
        "exampleID": 354,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java",
        "line": 77,
        "sink": "com.google.protobuf.MessageLite.toByteArray",
        "source": "-",
        "sourceLine": 77,
        "qualifier": "Call to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Http2StreamFrame](1).\nCall to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Object](2).",
        "line_number": 77,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 355
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 355
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 355
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 355
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java#L101",
        "rawCode": null,
        "methodName": null,
        "exampleID": 356,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java",
        "line": 101,
        "sink": "com.google.protobuf.MessageLite.toByteArray",
        "source": "-",
        "sourceLine": 101,
        "qualifier": "Call to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Http2StreamFrame](1).\nCall to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Object](2).",
        "line_number": 101,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 357
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 357
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 357
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 357
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java#L101",
        "rawCode": null,
        "methodName": null,
        "exampleID": 358,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/health/v1/DubboHealthTriple.java",
        "line": 101,
        "sink": "com.google.protobuf.MessageLite.toByteArray",
        "source": "-",
        "sourceLine": 101,
        "qualifier": "Call to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Http2StreamFrame](1).\nCall to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Object](2).",
        "line_number": 101,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 359
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 359
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 359
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 359
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/reflection/v1alpha/DubboServerReflectionTriple.java#L76",
        "rawCode": null,
        "methodName": null,
        "exampleID": 360,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/reflection/v1alpha/DubboServerReflectionTriple.java",
        "line": 76,
        "sink": "com.google.protobuf.MessageLite.toByteArray",
        "source": "-",
        "sourceLine": 76,
        "qualifier": "Call to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Http2StreamFrame](1).\nCall to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Object](2).",
        "line_number": 76,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 361
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 361
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 361
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 361
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/reflection/v1alpha/DubboServerReflectionTriple.java#L76",
        "rawCode": null,
        "methodName": null,
        "exampleID": 362,
        "dataset": "codeql",
        "filepath": "dubbo-rpc/dubbo-rpc-triple/target/generated-sources/protobuf/java/io/grpc/reflection/v1alpha/DubboServerReflectionTriple.java",
        "line": 76,
        "sink": "com.google.protobuf.MessageLite.toByteArray",
        "source": "-",
        "sourceLine": 76,
        "qualifier": "Call to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Http2StreamFrame](1).\nCall to com.google.protobuf.MessageLite.toByteArray with untrusted data from [msg : Object](2).",
        "line_number": 76,
        "steps": [
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 363
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 363
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 363
            },
            {
                "line": 69,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2FrameServerHandler.java",
                "methodName": null,
                "exampleID": 363
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2ObjectOutput.java#L108",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.serialize.fastjson2;\n\nimport org.apache.dubbo.common.serialize.ObjectOutput;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.alibaba.fastjson2.JSONB;\nimport com.alibaba.fastjson2.JSONWriter;\n\n/**\n * FastJson object output implementation\n */\npublic class FastJson2ObjectOutput implements ObjectOutput {\n\n    private final Fastjson2CreatorManager fastjson2CreatorManager;\n\n    private final Fastjson2SecurityManager fastjson2SecurityManager;\n\n    private volatile ClassLoader classLoader;\n    private final OutputStream os;\n\n    public FastJson2ObjectOutput(\n            Fastjson2CreatorManager fastjson2CreatorManager,\n            Fastjson2SecurityManager fastjson2SecurityManager,\n            OutputStream out) {\n        this.fastjson2CreatorManager = fastjson2CreatorManager;\n        this.fastjson2SecurityManager = fastjson2SecurityManager;\n        this.classLoader = Thread.currentThread().getContextClassLoader();\n        this.os = out;\n        fastjson2CreatorManager.setCreator(classLoader);\n    }\n\n    @Override\n    public void writeBool(boolean v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeByte(byte v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeShort(short v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeInt(int v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeLong(long v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeFloat(float v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeDouble(double v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeUTF(String v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeBytes(byte[] b) throws IOException {\n        writeLength(b.length);\n        os.write(b);\n    }\n\n    @Override\n    public void writeBytes(byte[] b, int off, int len) throws IOException {\n        writeLength(len);\n        os.write(b, off, len);\n    }\n\n    @Override\n    public void writeObject(Object obj) throws IOException {\n        updateClassLoaderIfNeed();\n        byte[] bytes;\n        if (fastjson2SecurityManager.getSecurityFilter().isCheckSerializable()) {\n            bytes = JSONB.toBytes(\n                    obj,\n                    JSONWriter.Feature.WriteClassName,\n                    JSONWriter.Feature.FieldBased,\n                    JSONWriter.Feature.ErrorOnNoneSerializable,\n                    JSONWriter.Feature.ReferenceDetection,\n                    JSONWriter.Feature.WriteNulls,\n                    JSONWriter.Feature.NotWriteDefaultValue,\n                    JSONWriter.Feature.NotWriteHashMapArrayListClassName,\n                    JSONWriter.Feature.WriteNameAsSymbol);\n        } else {\n            bytes = JSONB.toBytes(\n                    obj,\n                    JSONWriter.Feature.WriteClassName,\n                    JSONWriter.Feature.FieldBased,\n                    JSONWriter.Feature.ReferenceDetection,\n                    JSONWriter.Feature.WriteNulls,\n                    JSONWriter.Feature.NotWriteDefaultValue,\n                    JSONWriter.Feature.NotWriteHashMapArrayListClassName,\n                    JSONWriter.Feature.WriteNameAsSymbol);\n        }\n        writeLength(bytes.length);\n        os.write(bytes);\n        os.flush();\n    }\n\n    private void updateClassLoaderIfNeed() {\n        ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n        if (currentClassLoader != classLoader) {\n            fastjson2CreatorManager.setCreator(currentClassLoader);\n            classLoader = currentClassLoader;\n        }\n    }\n\n    private void writeLength(int value) throws IOException {\n        byte[] bytes = new byte[Integer.BYTES];\n        int length = bytes.length;\n        for (int i = 0; i < length; i++) {\n            bytes[length - i - 1] = (byte) (value & 0xFF);\n            value >>= 8;\n        }\n        os.write(bytes);\n    }\n\n    @Override\n    public void flushBuffer() throws IOException {\n        os.flush();\n    }\n}\n",
        "methodName": null,
        "exampleID": 364,
        "dataset": "codeql",
        "filepath": "dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2ObjectOutput.java",
        "line": 108,
        "sink": "com.alibaba.fastjson2.JSONB.toBytes",
        "source": "-",
        "sourceLine": 108,
        "qualifier": "Call to com.alibaba.fastjson2.JSONB.toBytes with untrusted data from [msg : Object](1).\nCall to com.alibaba.fastjson2.JSONB.toBytes with untrusted data from [msg : Object](2).\nCall to com.alibaba.fastjson2.JSONB.toBytes with untrusted data from [msg : Object](3).\nCall to com.alibaba.fastjson2.JSONB.toBytes with untrusted data from [msg : Http2StreamFrame](4).\nCall to com.alibaba.fastjson2.JSONB.toBytes with untrusted data from [msg : Object](5).",
        "line_number": 108,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 365
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 365
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 365
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 365
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2ObjectOutput.java#L119",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.serialize.fastjson2;\n\nimport org.apache.dubbo.common.serialize.ObjectOutput;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.alibaba.fastjson2.JSONB;\nimport com.alibaba.fastjson2.JSONWriter;\n\n/**\n * FastJson object output implementation\n */\npublic class FastJson2ObjectOutput implements ObjectOutput {\n\n    private final Fastjson2CreatorManager fastjson2CreatorManager;\n\n    private final Fastjson2SecurityManager fastjson2SecurityManager;\n\n    private volatile ClassLoader classLoader;\n    private final OutputStream os;\n\n    public FastJson2ObjectOutput(\n            Fastjson2CreatorManager fastjson2CreatorManager,\n            Fastjson2SecurityManager fastjson2SecurityManager,\n            OutputStream out) {\n        this.fastjson2CreatorManager = fastjson2CreatorManager;\n        this.fastjson2SecurityManager = fastjson2SecurityManager;\n        this.classLoader = Thread.currentThread().getContextClassLoader();\n        this.os = out;\n        fastjson2CreatorManager.setCreator(classLoader);\n    }\n\n    @Override\n    public void writeBool(boolean v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeByte(byte v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeShort(short v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeInt(int v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeLong(long v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeFloat(float v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeDouble(double v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeUTF(String v) throws IOException {\n        writeObject(v);\n    }\n\n    @Override\n    public void writeBytes(byte[] b) throws IOException {\n        writeLength(b.length);\n        os.write(b);\n    }\n\n    @Override\n    public void writeBytes(byte[] b, int off, int len) throws IOException {\n        writeLength(len);\n        os.write(b, off, len);\n    }\n\n    @Override\n    public void writeObject(Object obj) throws IOException {\n        updateClassLoaderIfNeed();\n        byte[] bytes;\n        if (fastjson2SecurityManager.getSecurityFilter().isCheckSerializable()) {\n            bytes = JSONB.toBytes(\n                    obj,\n                    JSONWriter.Feature.WriteClassName,\n                    JSONWriter.Feature.FieldBased,\n                    JSONWriter.Feature.ErrorOnNoneSerializable,\n                    JSONWriter.Feature.ReferenceDetection,\n                    JSONWriter.Feature.WriteNulls,\n                    JSONWriter.Feature.NotWriteDefaultValue,\n                    JSONWriter.Feature.NotWriteHashMapArrayListClassName,\n                    JSONWriter.Feature.WriteNameAsSymbol);\n        } else {\n            bytes = JSONB.toBytes(\n                    obj,\n                    JSONWriter.Feature.WriteClassName,\n                    JSONWriter.Feature.FieldBased,\n                    JSONWriter.Feature.ReferenceDetection,\n                    JSONWriter.Feature.WriteNulls,\n                    JSONWriter.Feature.NotWriteDefaultValue,\n                    JSONWriter.Feature.NotWriteHashMapArrayListClassName,\n                    JSONWriter.Feature.WriteNameAsSymbol);\n        }\n        writeLength(bytes.length);\n        os.write(bytes);\n        os.flush();\n    }\n\n    private void updateClassLoaderIfNeed() {\n        ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();\n        if (currentClassLoader != classLoader) {\n            fastjson2CreatorManager.setCreator(currentClassLoader);\n            classLoader = currentClassLoader;\n        }\n    }\n\n    private void writeLength(int value) throws IOException {\n        byte[] bytes = new byte[Integer.BYTES];\n        int length = bytes.length;\n        for (int i = 0; i < length; i++) {\n            bytes[length - i - 1] = (byte) (value & 0xFF);\n            value >>= 8;\n        }\n        os.write(bytes);\n    }\n\n    @Override\n    public void flushBuffer() throws IOException {\n        os.flush();\n    }\n}\n",
        "methodName": null,
        "exampleID": 366,
        "dataset": "codeql",
        "filepath": "dubbo-serialization/dubbo-serialization-fastjson2/src/main/java/org/apache/dubbo/common/serialize/fastjson2/FastJson2ObjectOutput.java",
        "line": 119,
        "sink": "com.alibaba.fastjson2.JSONB.toBytes",
        "source": "-",
        "sourceLine": 119,
        "qualifier": "Call to com.alibaba.fastjson2.JSONB.toBytes with untrusted data from [msg : Object](1).\nCall to com.alibaba.fastjson2.JSONB.toBytes with untrusted data from [msg : Object](2).\nCall to com.alibaba.fastjson2.JSONB.toBytes with untrusted data from [msg : Object](3).\nCall to com.alibaba.fastjson2.JSONB.toBytes with untrusted data from [msg : Http2StreamFrame](4).\nCall to com.alibaba.fastjson2.JSONB.toBytes with untrusted data from [msg : Object](5).",
        "line_number": 119,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 367
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 367
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 367
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 367
            }
        ]
    },
    {
        "url": "apache/dubbo/blob/main/dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectOutput.java#L102",
        "rawCode": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.common.serialize.hessian2;\n\nimport org.apache.dubbo.common.serialize.Cleanable;\nimport org.apache.dubbo.common.serialize.ObjectOutput;\nimport org.apache.dubbo.rpc.model.FrameworkModel;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.alibaba.com.caucho.hessian.io.Hessian2Output;\n\n/**\n * Hessian2 object output implementation\n */\npublic class Hessian2ObjectOutput implements ObjectOutput, Cleanable {\n\n    private final Hessian2Output mH2o;\n\n    @Deprecated\n    public Hessian2ObjectOutput(OutputStream os) {\n        mH2o = new Hessian2Output(os);\n        Hessian2FactoryManager hessian2FactoryManager =\n                FrameworkModel.defaultModel().getBeanFactory().getOrRegisterBean(Hessian2FactoryManager.class);\n        mH2o.setSerializerFactory(hessian2FactoryManager.getSerializerFactory(\n                Thread.currentThread().getContextClassLoader()));\n    }\n\n    public Hessian2ObjectOutput(OutputStream os, Hessian2FactoryManager hessian2FactoryManager) {\n        mH2o = new Hessian2Output(os);\n        mH2o.setSerializerFactory(hessian2FactoryManager.getSerializerFactory(\n                Thread.currentThread().getContextClassLoader()));\n    }\n\n    @Override\n    public void writeBool(boolean v) throws IOException {\n        mH2o.writeBoolean(v);\n    }\n\n    @Override\n    public void writeByte(byte v) throws IOException {\n        mH2o.writeInt(v);\n    }\n\n    @Override\n    public void writeShort(short v) throws IOException {\n        mH2o.writeInt(v);\n    }\n\n    @Override\n    public void writeInt(int v) throws IOException {\n        mH2o.writeInt(v);\n    }\n\n    @Override\n    public void writeLong(long v) throws IOException {\n        mH2o.writeLong(v);\n    }\n\n    @Override\n    public void writeFloat(float v) throws IOException {\n        mH2o.writeDouble(v);\n    }\n\n    @Override\n    public void writeDouble(double v) throws IOException {\n        mH2o.writeDouble(v);\n    }\n\n    @Override\n    public void writeBytes(byte[] b) throws IOException {\n        mH2o.writeBytes(b);\n    }\n\n    @Override\n    public void writeBytes(byte[] b, int off, int len) throws IOException {\n        mH2o.writeBytes(b, off, len);\n    }\n\n    @Override\n    public void writeUTF(String v) throws IOException {\n        mH2o.writeString(v);\n    }\n\n    @Override\n    public void writeObject(Object obj) throws IOException {\n        mH2o.writeObject(obj);\n    }\n\n    @Override\n    public void flushBuffer() throws IOException {\n        mH2o.flushBuffer();\n    }\n\n    public OutputStream getOutputStream() throws IOException {\n        return mH2o.getBytesOutputStream();\n    }\n\n    @Override\n    public void cleanup() {\n        if (mH2o != null) {\n            mH2o.reset();\n        }\n    }\n}\n",
        "methodName": null,
        "exampleID": 368,
        "dataset": "codeql",
        "filepath": "dubbo-serialization/dubbo-serialization-hessian2/src/main/java/org/apache/dubbo/common/serialize/hessian2/Hessian2ObjectOutput.java",
        "line": 102,
        "sink": "com.alibaba.com.caucho.hessian.io.Hessian2Output.writeObject",
        "source": "-",
        "sourceLine": 102,
        "qualifier": "Call to com.alibaba.com.caucho.hessian.io.Hessian2Output.writeObject with untrusted data from [msg : Object](1).\nCall to com.alibaba.com.caucho.hessian.io.Hessian2Output.writeObject with untrusted data from [msg : Object](2).\nCall to com.alibaba.com.caucho.hessian.io.Hessian2Output.writeObject with untrusted data from [msg : Object](3).\nCall to com.alibaba.com.caucho.hessian.io.Hessian2Output.writeObject with untrusted data from [msg : Http2StreamFrame](4).\nCall to com.alibaba.com.caucho.hessian.io.Hessian2Output.writeObject with untrusted data from [msg : Object](5).",
        "line_number": 102,
        "steps": [
            {
                "line": 81,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyClientHandler.java",
                "methodName": null,
                "exampleID": 369
            },
            {
                "line": 99,
                "source": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "filepath": "dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4/NettyServerHandler.java",
                "methodName": null,
                "exampleID": 369
            },
            {
                "line": 37,
                "source": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-dubbo/src/test/java/org/apache/dubbo/rpc/protocol/dubbo/decode/MockHandler.java",
                "methodName": null,
                "exampleID": 369
            },
            {
                "line": 59,
                "source": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "filepath": "dubbo-rpc/dubbo-rpc-triple/src/main/java/org/apache/dubbo/rpc/protocol/tri/transport/TripleHttp2ClientResponseHandler.java",
                "methodName": null,
                "exampleID": 369
            }
        ]
    }
]