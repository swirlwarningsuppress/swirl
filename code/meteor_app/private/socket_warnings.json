[
    {
        "url": "dummy",
        "rawCode": "private LegacyApacheThriftTesterUtil() {}\n\n    public static List<ToIntFunction<HostAndPort>> legacyApacheThriftTestClients(List<MethodInvocationFilter> filters, Transport transport, Protocol protocol, boolean secure)\n    {\n        return ImmutableList.of(\n                address -> logThrift(address, MESSAGES, filters, transport, protocol, secure));\n    }\n\n    private static int logThrift(HostAndPort address, List<LogEntry> messages, List<MethodInvocationFilter> filters, Transport transportType, Protocol protocolType, boolean secure)\n    {\n        if (!filters.isEmpty()) {\n            return 0;\n        }\n\n        TTransportFactory transportFactory;\n        switch (transportType) {\n            case UNFRAMED:\n                transportFactory = new TTransportFactory();\n                break;\n            case FRAMED:\n                transportFactory = new TFramedTransport.Factory();\n                break;\n            case HEADER:\n                return 0;\n            default:\n                throw new IllegalArgumentException(\"Unsupported transport \" + transportType);\n        }\n\n        try (TSocket socket = createClientSocket(secure, address)) {\n            if (!socket.isOpen()) {\n                socket.open();\n            }\n            TTransport transport = transportFactory.getTransport(socket);\n            TProtocol protocol;\n            switch (protocolType) {\n                case BINARY:\n                    protocol = new TBinaryProtocol(transport);\n                    break;\n                case COMPACT:\n                    protocol = new TCompactProtocol(transport);\n                    break;\n                case FB_COMPACT:\n                    return 0;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported protocol \" + protocolType);\n            }\n\n            assertEquals(new scribe.Client(protocol).Log(messages), ResultCode.OK);\n        }\n        catch (TException e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static TSocket createClientSocket(boolean secure, HostAndPort address)\n            throws TTransportException\n    {\n        if (!secure) {\n            return new TSocket(address.getHost(), address.getPort());\n        }\n\n        try {\n            SSLContext serverSslContext = ClientTestUtils.getClientSslContext();\n            SSLSocket clientSocket = (SSLSocket) serverSslContext.getSocketFactory().createSocket(address.getHost(), address.getPort());\n            //            clientSocket.setSoTimeout(timeout);\n            return new TSocket(clientSocket);\n        }\n        catch (Exception e) {\n            throw new TTransportException(\"Error initializing secure socket\", e);\n        }\n    }\n}",
        "exampleID": 1,
        "dataset": "socket",
        "filepath": "/Users/xxx/repos/suppression_interface//GithubExamples/socket/LegacyApacheThriftTesterUtil.java"
    },
    {
        "url": "dummy",
        "rawCode": "public class ApacheThriftMethodInvoker\n        implements MethodInvoker\n{\n    // This client only sends a single request per connection, so the sequence id can be constant\n    private static final int SEQUENCE_ID = 77;\n\n    private final ListeningExecutorService executorService;\n    private final ListeningScheduledExecutorService delayService;\n    private final TTransportFactory transportFactory;\n    private final TProtocolFactory protocolFactory;\n\n    private final int connectTimeoutMillis;\n    private final int requestTimeoutMillis;\n    private final Optional<HostAndPort> socksProxy;\n    private final Optional<SSLContext> sslContext;\n\n    public ApacheThriftMethodInvoker(\n            ListeningExecutorService executorService,\n            ListeningScheduledExecutorService delayService,\n            TTransportFactory transportFactory,\n            TProtocolFactory protocolFactory,\n            Duration connectTimeout,\n            Duration requestTimeout,\n            Optional<HostAndPort> socksProxy,\n            Optional<SSLContext> sslContext)\n    {\n        this.executorService = requireNonNull(executorService, \"executorService is null\");\n        this.delayService = requireNonNull(delayService, \"delayService is null\");\n        this.transportFactory = requireNonNull(transportFactory, \"transportFactory is null\");\n        this.protocolFactory = requireNonNull(protocolFactory, \"protocolFactory is null\");\n        this.connectTimeoutMillis = Ints.saturatedCast(requireNonNull(connectTimeout, \"connectTimeout is null\").toMillis());\n        this.requestTimeoutMillis = Ints.saturatedCast(requireNonNull(requestTimeout, \"requestTimeout is null\").toMillis());\n        this.socksProxy = requireNonNull(socksProxy, \"socksProxy is null\");\n        this.sslContext = requireNonNull(sslContext, \"sslContext is null\");\n    }\n\n    @Override\n    public ListenableFuture<Object> invoke(InvokeRequest request)\n    {\n        try {\n            return executorService.submit(() -> invokeSynchronous(request));\n        }\n        catch (Exception e) {\n            return immediateFailedFuture(toDriftException(e));\n        }\n    }\n\n    @Override\n    public ListenableFuture<?> delay(Duration duration)\n    {\n        try {\n            return delayService.schedule(() -> null, duration.toMillis(), MILLISECONDS);\n        }\n        catch (Exception e) {\n            return immediateFailedFuture(toDriftException(e));\n        }\n    }\n\n    private Object invokeSynchronous(InvokeRequest request)\n            throws Exception\n    {\n        Address address = request.getAddress();\n\n        TSocket socket = createTSocket(address.getHostAndPort());\n        if (!socket.isOpen()) {\n            try {\n                socket.open();\n            }\n            catch (org.apache.thrift.transport.TTransportException e) {\n                throw new ConnectionFailedException(address, e);\n            }\n        }\n\n        try {\n            TTransport transport = transportFactory.getTransport(socket);\n            TProtocol protocol = protocolFactory.getProtocol(transport);\n\n            writeRequest(request.getMethod(), request.getParameters(), protocol);\n\n            return readResponse(request.getMethod(), protocol);\n        }\n        finally {\n            socket.close();\n        }\n    }\n\n    private TSocket createTSocket(HostAndPort address)\n            throws TTransportException\n    {\n        Proxy proxy = socksProxy\n                .map(socksAddress -> new Proxy(SOCKS, InetSocketAddress.createUnresolved(socksAddress.getHost(), socksAddress.getPort())))\n                .orElse(Proxy.NO_PROXY);\n\n        Socket socket = new Socket(proxy);\n        try {\n            setSocketProperties(socket);\n            socket.connect(new InetSocketAddress(address.getHost(), address.getPort()), Ints.saturatedCast(connectTimeoutMillis));\n\n            if (sslContext.isPresent()) {\n                SSLContext sslContext = this.sslContext.get();\n\n                // SSL connect is to the socks address when present\n                HostAndPort sslConnectAddress = socksProxy.orElse(address);\n\n                socket = sslContext.getSocketFactory().createSocket(socket, sslConnectAddress.getHost(), sslConnectAddress.getPort(), true);\n                setSocketProperties(socket);\n            }\n            return new TSocket(socket);\n        }\n        catch (Throwable t) {\n            // something went wrong, close the socket and rethrow\n            try {\n                socket.close();\n            }\n            catch (IOException e) {\n                t.addSuppressed(e);\n            }\n            // unchecked exceptions are not transport exceptions\n            // (any socket related exception will be a checked exception)\n            throwIfUnchecked(t);\n            throw new TTransportException(t);\n        }\n    }\n\n    private void setSocketProperties(Socket socket)\n            throws SocketException\n    {\n        socket.setSoLinger(false, 0);\n        socket.setTcpNoDelay(true);\n        socket.setKeepAlive(true);\n        socket.setSoTimeout(Ints.saturatedCast(requestTimeoutMillis));\n    }\n\n    private static void writeRequest(MethodMetadata method, List<Object> parameters, TProtocol protocol)\n            throws Exception\n    {\n        TMessage requestMessage = new TMessage(method.getName(), CALL, SEQUENCE_ID);\n        protocol.writeMessageBegin(requestMessage);\n\n        // write the parameters\n        ProtocolWriter writer = new ProtocolWriter(new ThriftToDriftProtocolWriter(protocol));\n        writer.writeStructBegin(method.getName() + \"_args\");\n        for (int i = 0; i < parameters.size(); i++) {\n            Object value = parameters.get(i);\n            ParameterMetadata parameter = method.getParameters().get(i);\n            writer.writeField(parameter.getName(), parameter.getFieldId(), parameter.getCodec(), value);\n        }\n        writer.writeStructEnd();\n\n        protocol.writeMessageEnd();\n        protocol.getTransport().flush();\n    }\n\n    private static Object readResponse(MethodMetadata method, TProtocol responseProtocol)\n            throws TException, org.apache.thrift.TException\n    {\n        // validate response header\n        TMessage message = responseProtocol.readMessageBegin();\n\n        if (message.type == EXCEPTION) {\n            org.apache.thrift.TApplicationException exception = org.apache.thrift.TApplicationException.readFrom(responseProtocol);\n            responseProtocol.readMessageEnd();\n            throw exception;\n        }\n        if (message.type != REPLY) {\n            throw new TApplicationException(INVALID_MESSAGE_TYPE, format(\"Received invalid message type %s from server\", message.type));\n        }\n        if (!message.name.equals(method.getName())) {\n            throw new TApplicationException(WRONG_METHOD_NAME, format(\"Wrong method name in reply: expected %s but received %s\", method.getName(), message.name));\n        }\n        if (message.seqid != SEQUENCE_ID) {\n            throw new TApplicationException(BAD_SEQUENCE_ID, format(\"%s failed: out of sequence response\", method.getName()));\n        }\n\n        // read response struct\n        ProtocolReader reader = new ProtocolReader(new ThriftToDriftProtocolReader(responseProtocol));\n        reader.readStructBegin();\n\n        Object results = null;\n        Exception exception = null;\n        short exceptionId = 0;\n\n        try {\n            while (reader.nextField()) {\n                exceptionId = reader.getFieldId();\n                if (exceptionId == 0) {\n                    results = reader.readField(method.getResultCodec());\n                }\n                else {\n                    ThriftCodec<Object> exceptionCodec = method.getExceptionCodecs().get(exceptionId);\n                    if (exceptionCodec != null) {\n                        exception = (Exception) reader.readField(exceptionCodec);\n                    }\n                    else {\n                        reader.skipFieldData();\n                    }\n                }\n            }\n            reader.readStructEnd();\n            responseProtocol.readMessageEnd();\n        }\n        catch (TException e) {\n            throw e;\n        }\n        catch (Exception e) {\n            throw new TException(e);\n        }\n\n        if (exception != null) {\n            throw new DriftApplicationException(exception, method.isExceptionRetryable(exceptionId));\n        }\n\n        if (method.getResultCodec().getType() == ThriftType.VOID) {\n            return null;\n        }\n\n        if (results == null) {\n            throw new TApplicationException(MISSING_RESULT, format(\"%s failed: unknown result\", method.getName()));\n        }\n        return results;\n    }\n\n    private static Exception toDriftException(Exception e)\n    {\n        if (e instanceof org.apache.thrift.TApplicationException) {\n            org.apache.thrift.TApplicationException tae = (org.apache.thrift.TApplicationException) e;\n            return new TApplicationException(tae.getType(), tae.getMessage());\n        }\n        if (e instanceof org.apache.thrift.transport.TTransportException) {\n            return new TTransportException(e);\n        }\n        if (e instanceof org.apache.thrift.protocol.TProtocolException) {\n            return new TProtocolException(e);\n        }\n        if (e instanceof org.apache.thrift.TException) {\n            return new TException(e);\n        }\n        return e;\n    }\n}",
        "exampleID": 3,
        "dataset": "socket",
        "filepath": "/Users/xxx/repos/suppression_interface//GithubExamples/socket/ApacheThriftMethodInvoker.java"
    },
    {
        "url": "dummy",
        "rawCode": "public final class Transport\n{\n    public static TTransport create(\n            HostAndPort address,\n            Optional<SSLContext> sslContext,\n            Optional<HostAndPort> socksProxy,\n            int timeoutMillis,\n            HiveMetastoreAuthentication authentication,\n            Optional<String> tokenString)\n            throws TTransportException\n    {\n        try {\n            TTransport rawTransport = createRaw(address, sslContext, socksProxy, timeoutMillis);\n            TTransport authenticatedTransport = authentication.authenticate(rawTransport, address.getHost(), tokenString);\n            if (!authenticatedTransport.isOpen()) {\n                authenticatedTransport.open();\n            }\n            return new TTransportWrapper(authenticatedTransport, address);\n        }\n        catch (TTransportException e) {\n            throw rewriteException(e, address);\n        }\n    }\n\n    private Transport() {}\n\n    private static TTransport createRaw(HostAndPort address, Optional<SSLContext> sslContext, Optional<HostAndPort> socksProxy, int timeoutMillis)\n            throws TTransportException\n    {\n        Proxy proxy = socksProxy\n                .map(socksAddress -> new Proxy(SOCKS, InetSocketAddress.createUnresolved(socksAddress.getHost(), socksAddress.getPort())))\n                .orElse(Proxy.NO_PROXY);\n\n        Socket socket = new Socket(proxy);\n        try {\n            socket.connect(new InetSocketAddress(address.getHost(), address.getPort()), timeoutMillis);\n            socket.setSoTimeout(timeoutMillis);\n\n            if (sslContext.isPresent()) {\n                // SSL will connect to the SOCKS address when present\n                HostAndPort sslConnectAddress = socksProxy.orElse(address);\n\n                socket = sslContext.get().getSocketFactory().createSocket(socket, sslConnectAddress.getHost(), sslConnectAddress.getPort(), true);\n            }\n            return new TSocket(socket);\n        }\n        catch (Throwable t) {\n            // something went wrong, close the socket and rethrow\n            try {\n                socket.close();\n            }\n            catch (IOException e) {\n                t.addSuppressed(e);\n            }\n            throw new TTransportException(t);\n        }\n    }\n\n    private static TTransportException rewriteException(TTransportException e, HostAndPort address)\n    {\n        return new TTransportException(e.getType(), String.format(\"%s: %s\", address, e.getMessage()), e);\n    }\n\n    private static class TTransportWrapper\n            extends TTransport\n    {\n        private final TTransport transport;\n        private final HostAndPort address;\n\n        TTransportWrapper(TTransport transport, HostAndPort address)\n        {\n            this.transport = transport;\n            this.address = address;\n        }\n\n        @Override\n        public boolean isOpen()\n        {\n            return transport.isOpen();\n        }\n\n        @Override\n        public boolean peek()\n        {\n            return transport.peek();\n        }\n\n        @Override\n        public byte[] getBuffer()\n        {\n            return transport.getBuffer();\n        }\n\n        @Override\n        public int getBufferPosition()\n        {\n            return transport.getBufferPosition();\n        }\n\n        @Override\n        public int getBytesRemainingInBuffer()\n        {\n            return transport.getBytesRemainingInBuffer();\n        }\n\n        @Override\n        public void consumeBuffer(int len)\n        {\n            transport.consumeBuffer(len);\n        }\n\n        @Override\n        public void close()\n        {\n            transport.close();\n        }\n\n        @Override\n        public void open()\n                throws TTransportException\n        {\n            try {\n                transport.open();\n            }\n            catch (TTransportException e) {\n                throw rewriteException(e, address);\n            }\n        }\n\n        @Override\n        public int readAll(byte[] bytes, int off, int len)\n                throws TTransportException\n        {\n            try {\n                return transport.readAll(bytes, off, len);\n            }\n            catch (TTransportException e) {\n                throw rewriteException(e, address);\n            }\n        }\n\n        @Override\n        public int read(byte[] bytes, int off, int len)\n                throws TTransportException\n        {\n            try {\n                return transport.read(bytes, off, len);\n            }\n            catch (TTransportException e) {\n                throw rewriteException(e, address);\n            }\n        }\n\n        @Override\n        public void write(byte[] bytes)\n                throws TTransportException\n        {\n            try {\n                transport.write(bytes);\n            }\n            catch (TTransportException e) {\n                throw rewriteException(e, address);\n            }\n        }\n\n        @Override\n        public void write(byte[] bytes, int off, int len)\n                throws TTransportException\n        {\n            try {\n                transport.write(bytes, off, len);\n            }\n            catch (TTransportException e) {\n                throw rewriteException(e, address);\n            }\n        }\n\n        @Override\n        public void flush()\n                throws TTransportException\n        {\n            try {\n                transport.flush();\n            }\n            catch (TTransportException e) {\n                throw rewriteException(e, address);\n            }\n        }\n    }\n}",
        "exampleID": 4,
        "dataset": "socket",
        "filepath": "/Users/xxx/repos/suppression_interface//GithubExamples/socket/Transport.java"
    },
    {
        "url": "dummy",
        "rawCode": "public class ByteArrayOutputStream\n        implements ValueOutputStream<ByteArrayStreamCheckpoint>\n{\n    private static final int INSTANCE_SIZE = ClassLayout.parseClass(ByteArrayOutputStream.class).instanceSize();\n    private final OrcOutputBuffer buffer;\n    private final List<ByteArrayStreamCheckpoint> checkpoints = new ArrayList<>();\n    private final StreamKind streamKind;\n\n    private boolean closed;\n\n    public ByteArrayOutputStream(ColumnWriterOptions columnWriterOptions, Optional<DwrfDataEncryptor> dwrfEncryptor)\n    {\n        this(columnWriterOptions, dwrfEncryptor, DATA);\n    }\n\n    public ByteArrayOutputStream(ColumnWriterOptions columnWriterOptions, Optional<DwrfDataEncryptor> dwrfEncryptor, StreamKind streamKind)\n    {\n        this.buffer = new OrcOutputBuffer(columnWriterOptions, dwrfEncryptor);\n        this.streamKind = streamKind;\n    }\n\n    public void writeSlice(Slice value)\n    {\n        checkState(!closed);\n        buffer.writeBytes(value);\n    }\n\n    public void writeSlice(Slice slice, int sourceIndex, int length)\n    {\n        checkState(!closed);\n        buffer.writeBytes(slice, sourceIndex, length);\n    }\n\n    public void writeBlockPosition(Block block, int position, int offset, int length)\n    {\n        checkState(!closed);\n        block.writeBytesTo(position, offset, length, buffer);\n    }\n\n    @Override\n    public void close()\n    {\n        closed = true;\n        buffer.close();\n    }\n\n    @Override\n    public void recordCheckpoint()\n    {\n        checkState(!closed);\n        checkpoints.add(new ByteArrayStreamCheckpoint(buffer.getCheckpoint()));\n    }\n\n    @Override\n    public List<ByteArrayStreamCheckpoint> getCheckpoints()\n    {\n        checkState(closed);\n        return ImmutableList.copyOf(checkpoints);\n    }\n\n    @Override\n    public StreamDataOutput getStreamDataOutput(int column, int sequence)\n    {\n        return new StreamDataOutput(buffer::writeDataTo, new Stream(column, sequence, streamKind, toIntExact(buffer.getOutputDataSize()), false));\n    }\n\n    @Override\n    public long getBufferedBytes()\n    {\n        return buffer.estimateOutputDataSize();\n    }\n\n    @Override\n    public long getRetainedBytes()\n    {\n        // NOTE: we do not include checkpoints because they should be small and it would be annoying to calculate the size\n        return INSTANCE_SIZE + buffer.getRetainedSize();\n    }\n\n    @Override\n    public void reset()\n    {\n        closed = false;\n        buffer.reset();\n        checkpoints.clear();\n    }\n}",
        "exampleID": 2,
        "dataset": "socket",
        "filepath": "/Users/xxx/repos/suppression_interface//GithubExamples/socket/ByteArrayOutputStream.java"
    }
]