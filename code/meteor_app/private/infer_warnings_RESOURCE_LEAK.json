[{"url": "dummy", "rawCode": "/*\n * Copyright (C) 2012 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.airlift.drift.transport.apache;\n\nimport com.google.common.net.HostAndPort;\nimport com.google.common.primitives.Ints;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.ListeningExecutorService;\nimport com.google.common.util.concurrent.ListeningScheduledExecutorService;\nimport io.airlift.drift.TApplicationException;\nimport io.airlift.drift.TException;\nimport io.airlift.drift.codec.ThriftCodec;\nimport io.airlift.drift.codec.internal.ProtocolReader;\nimport io.airlift.drift.codec.internal.ProtocolWriter;\nimport io.airlift.drift.codec.metadata.ThriftType;\nimport io.airlift.drift.protocol.TProtocolException;\nimport io.airlift.drift.protocol.TTransportException;\nimport io.airlift.drift.transport.Address;\nimport io.airlift.drift.transport.ConnectionFailedException;\nimport io.airlift.drift.transport.DriftApplicationException;\nimport io.airlift.drift.transport.InvokeRequest;\nimport io.airlift.drift.transport.MethodInvoker;\nimport io.airlift.drift.transport.MethodMetadata;\nimport io.airlift.drift.transport.ParameterMetadata;\nimport io.airlift.units.Duration;\nimport org.apache.thrift.protocol.TMessage;\nimport org.apache.thrift.protocol.TProtocol;\nimport org.apache.thrift.protocol.TProtocolFactory;\nimport org.apache.thrift.transport.TSocket;\nimport org.apache.thrift.transport.TTransport;\nimport org.apache.thrift.transport.TTransportFactory;\n\nimport javax.net.ssl.SSLContext;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.util.List;\nimport java.util.Optional;\n\nimport static com.google.common.base.Throwables.throwIfUnchecked;\nimport static com.google.common.util.concurrent.Futures.immediateFailedFuture;\nimport static io.airlift.drift.TApplicationException.Type.BAD_SEQUENCE_ID;\nimport static io.airlift.drift.TApplicationException.Type.INTERNAL_ERROR;\nimport static io.airlift.drift.TApplicationException.Type.INVALID_MESSAGE_TYPE;\nimport static io.airlift.drift.TApplicationException.Type.INVALID_PROTOCOL;\nimport static io.airlift.drift.TApplicationException.Type.INVALID_TRANSFORM;\nimport static io.airlift.drift.TApplicationException.Type.MISSING_RESULT;\nimport static io.airlift.drift.TApplicationException.Type.PROTOCOL_ERROR;\nimport static io.airlift.drift.TApplicationException.Type.UNKNOWN;\nimport static io.airlift.drift.TApplicationException.Type.UNKNOWN_METHOD;\nimport static io.airlift.drift.TApplicationException.Type.UNSUPPORTED_CLIENT_TYPE;\nimport static io.airlift.drift.TApplicationException.Type.WRONG_METHOD_NAME;\nimport static java.lang.String.format;\nimport static java.net.Proxy.Type.SOCKS;\nimport static java.util.Objects.requireNonNull;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static org.apache.thrift.protocol.TMessageType.CALL;\nimport static org.apache.thrift.protocol.TMessageType.EXCEPTION;\nimport static org.apache.thrift.protocol.TMessageType.REPLY;\n\npublic class ApacheThriftMethodInvoker\n        implements MethodInvoker\n{\n    // This client only sends a single request per connection, so the sequence id can be constant\n    private static final int SEQUENCE_ID = 77;\n\n    private final ListeningExecutorService executorService;\n    private final ListeningScheduledExecutorService delayService;\n    private final TTransportFactory transportFactory;\n    private final TProtocolFactory protocolFactory;\n\n    private final int connectTimeoutMillis;\n    private final int requestTimeoutMillis;\n    private final Optional<HostAndPort> socksProxy;\n    private final Optional<SSLContext> sslContext;\n\n    public ApacheThriftMethodInvoker(\n            ListeningExecutorService executorService,\n            ListeningScheduledExecutorService delayService,\n            TTransportFactory transportFactory,\n            TProtocolFactory protocolFactory,\n            Duration connectTimeout,\n            Duration requestTimeout,\n            Optional<HostAndPort> socksProxy,\n            Optional<SSLContext> sslContext)\n    {\n        this.executorService = requireNonNull(executorService, \"executorService is null\");\n        this.delayService = requireNonNull(delayService, \"delayService is null\");\n        this.transportFactory = requireNonNull(transportFactory, \"transportFactory is null\");\n        this.protocolFactory = requireNonNull(protocolFactory, \"protocolFactory is null\");\n        this.connectTimeoutMillis = Ints.saturatedCast(requireNonNull(connectTimeout, \"connectTimeout is null\").toMillis());\n        this.requestTimeoutMillis = Ints.saturatedCast(requireNonNull(requestTimeout, \"requestTimeout is null\").toMillis());\n        this.socksProxy = requireNonNull(socksProxy, \"socksProxy is null\");\n        this.sslContext = requireNonNull(sslContext, \"sslContext is null\");\n    }\n\n    @Override\n    public ListenableFuture<Object> invoke(InvokeRequest request)\n    {\n        try {\n            return executorService.submit(() -> invokeSynchronous(request));\n        }\n        catch (Exception e) {\n            return immediateFailedFuture(toDriftException(e));\n        }\n    }\n\n    @Override\n    public ListenableFuture<?> delay(Duration duration)\n    {\n        try {\n            return delayService.schedule(() -> null, duration.toMillis(), MILLISECONDS);\n        }\n        catch (Exception e) {\n            return immediateFailedFuture(toDriftException(e));\n        }\n    }\n\n    private Object invokeSynchronous(InvokeRequest request)\n            throws Exception\n    {\n        Address address = request.getAddress();\n\n        TSocket socket = createTSocket(address.getHostAndPort());\n        if (!socket.isOpen()) {\n            try {\n                socket.open();\n            }\n            catch (org.apache.thrift.transport.TTransportException e) {\n                throw new ConnectionFailedException(address, e);\n            }\n        }\n\n        try {\n            TTransport transport = transportFactory.getTransport(socket);\n            TProtocol protocol = protocolFactory.getProtocol(transport);\n\n            writeRequest(request.getMethod(), request.getParameters(), protocol);\n\n            return readResponse(request.getMethod(), protocol);\n        }\n        finally {\n            socket.close();\n        }\n    }\n\n    private TSocket createTSocket(HostAndPort address)\n            throws TTransportException\n    {\n        Proxy proxy = socksProxy\n                .map(socksAddress -> new Proxy(SOCKS, InetSocketAddress.createUnresolved(socksAddress.getHost(), socksAddress.getPort())))\n                .orElse(Proxy.NO_PROXY);\n\n        Socket socket = new Socket(proxy);\n        try {\n            setSocketProperties(socket);\n            socket.connect(new InetSocketAddress(address.getHost(), address.getPort()), Ints.saturatedCast(connectTimeoutMillis));\n\n            if (sslContext.isPresent()) {\n                SSLContext sslContext = this.sslContext.get();\n\n                // SSL connect is to the socks address when present\n                HostAndPort sslConnectAddress = socksProxy.orElse(address);\n\n                socket = sslContext.getSocketFactory().createSocket(socket, sslConnectAddress.getHost(), sslConnectAddress.getPort(), true);\n                setSocketProperties(socket);\n            }\n            return new TSocket(socket);\n        }\n        catch (Throwable t) {\n            // something went wrong, close the socket and rethrow\n            try {\n                socket.close();\n            }\n            catch (IOException e) {\n                t.addSuppressed(e);\n            }\n            // unchecked exceptions are not transport exceptions\n            // (any socket related exception will be a checked exception)\n            throwIfUnchecked(t);\n            throw new TTransportException(t);\n        }\n    }\n\n    private void setSocketProperties(Socket socket)\n            throws SocketException\n    {\n        socket.setSoLinger(false, 0);\n        socket.setTcpNoDelay(true);\n        socket.setKeepAlive(true);\n        socket.setSoTimeout(Ints.saturatedCast(requestTimeoutMillis));\n    }\n\n    private static void writeRequest(MethodMetadata method, List<Object> parameters, TProtocol protocol)\n            throws Exception\n    {\n        TMessage requestMessage = new TMessage(method.getName(), CALL, SEQUENCE_ID);\n        protocol.writeMessageBegin(requestMessage);\n\n        // write the parameters\n        ProtocolWriter writer = new ProtocolWriter(new ThriftToDriftProtocolWriter(protocol));\n        writer.writeStructBegin(method.getName() + \"_args\");\n        for (int i = 0; i < parameters.size(); i++) {\n            Object value = parameters.get(i);\n            ParameterMetadata parameter = method.getParameters().get(i);\n            writer.writeField(parameter.getName(), parameter.getId(), parameter.getCodec(), value);\n        }\n        writer.writeStructEnd();\n\n        protocol.writeMessageEnd();\n        protocol.getTransport().flush();\n    }\n\n    private static Object readResponse(MethodMetadata method, TProtocol responseProtocol)\n            throws TException, org.apache.thrift.TException\n    {\n        // validate response header\n        TMessage message = responseProtocol.readMessageBegin();\n\n        if (message.type == EXCEPTION) {\n            org.apache.thrift.TApplicationException exception = org.apache.thrift.TApplicationException.read(responseProtocol);\n            responseProtocol.readMessageEnd();\n            throw exception;\n        }\n        if (message.type != REPLY) {\n            throw new TApplicationException(INVALID_MESSAGE_TYPE, format(\"Received invalid message type %s from server\", message.type));\n        }\n        if (!message.name.equals(method.getName())) {\n            throw new TApplicationException(WRONG_METHOD_NAME, format(\"Wrong method name in reply: expected %s but received %s\", method.getName(), message.name));\n        }\n        if (message.seqid != SEQUENCE_ID) {\n            throw new TApplicationException(BAD_SEQUENCE_ID, format(\"%s failed: out of sequence response\", method.getName()));\n        }\n\n        // read response struct\n        ProtocolReader reader = new ProtocolReader(new ThriftToDriftProtocolReader(responseProtocol));\n        reader.readStructBegin();\n\n        Object results = null;\n        Exception exception = null;\n        try {\n            while (reader.nextField()) {\n                if (reader.getFieldId() == 0) {\n                    results = reader.readField(method.getResultCodec());\n                }\n                else {\n                    ThriftCodec<Object> exceptionCodec = method.getExceptionCodecs().get(reader.getFieldId());\n                    if (exceptionCodec != null) {\n                        exception = (Exception) reader.readField(exceptionCodec);\n                    }\n                    else {\n                        reader.skipFieldData();\n                    }\n                }\n            }\n            reader.readStructEnd();\n            responseProtocol.readMessageEnd();\n        }\n        catch (TException e) {\n            throw e;\n        }\n        catch (Exception e) {\n            throw new TException(e);\n        }\n\n        if (exception != null) {\n            throw new DriftApplicationException(exception);\n        }\n\n        if (method.getResultCodec().getType() == ThriftType.VOID) {\n            return null;\n        }\n\n        if (results == null) {\n            throw new TApplicationException(MISSING_RESULT, format(\"%s failed: unknown result\", method.getName()));\n        }\n        return results;\n    }\n\n    private static Exception toDriftException(Exception e)\n    {\n        if (e instanceof org.apache.thrift.TApplicationException) {\n            org.apache.thrift.TApplicationException tae = (org.apache.thrift.TApplicationException) e;\n            return new TApplicationException(toDriftApplicationExceptionType(tae.getType()), tae.getMessage());\n        }\n        if (e instanceof org.apache.thrift.transport.TTransportException) {\n            return new TTransportException(e);\n        }\n        if (e instanceof org.apache.thrift.protocol.TProtocolException) {\n            return new TProtocolException(e);\n        }\n        if (e instanceof org.apache.thrift.TException) {\n            return new TException(e);\n        }\n        return e;\n    }\n\n    private static TApplicationException.Type toDriftApplicationExceptionType(int type)\n    {\n        switch (type) {\n            case org.apache.thrift.TApplicationException.UNKNOWN_METHOD:\n                return UNKNOWN_METHOD;\n            case org.apache.thrift.TApplicationException.INVALID_MESSAGE_TYPE:\n                return INVALID_MESSAGE_TYPE;\n            case org.apache.thrift.TApplicationException.WRONG_METHOD_NAME:\n                return WRONG_METHOD_NAME;\n            case org.apache.thrift.TApplicationException.BAD_SEQUENCE_ID:\n                return BAD_SEQUENCE_ID;\n            case org.apache.thrift.TApplicationException.MISSING_RESULT:\n                return MISSING_RESULT;\n            case org.apache.thrift.TApplicationException.INTERNAL_ERROR:\n                return INTERNAL_ERROR;\n            case org.apache.thrift.TApplicationException.PROTOCOL_ERROR:\n                return PROTOCOL_ERROR;\n            case org.apache.thrift.TApplicationException.INVALID_TRANSFORM:\n                return INVALID_TRANSFORM;\n            case org.apache.thrift.TApplicationException.INVALID_PROTOCOL:\n                return INVALID_PROTOCOL;\n            case org.apache.thrift.TApplicationException.UNSUPPORTED_CLIENT_TYPE:\n                return UNSUPPORTED_CLIENT_TYPE;\n        }\n        return UNKNOWN;\n    }\n}\n", "methodName": "TSocket ApacheThriftMethodInvoker.createTSocket(HostAndPort)", "exampleID": 0, "dataset": "infer", "filepath": "drift-transport-apache/src/main/java/io/airlift/drift/transport/apache/ApacheThriftMethodInvoker.java", "line": 181, "sink": "socket", "steps": [{"line": 170, "source": "java.net.Socket", "filepath": "drift-transport-apache/src/main/java/io/airlift/drift/transport/apache/ApacheThriftMethodInvoker.java", "exampleID": 1}]}]