[{"url": "dummy", "rawCode": "/*\n * Copyright (C) 2012 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.airlift.drift.codec;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.reflect.TypeToken;\nimport com.google.inject.Inject;\nimport io.airlift.drift.codec.internal.EnumThriftCodec;\nimport io.airlift.drift.codec.internal.ThriftCodecFactory;\nimport io.airlift.drift.codec.internal.builtin.BooleanArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.BooleanThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ByteBufferThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ByteThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.DoubleArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.DoubleThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.IntArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.IntegerThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ListThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.LongArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.LongThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.MapThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.SetThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ShortArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ShortThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.StringThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.VoidThriftCodec;\nimport io.airlift.drift.codec.internal.coercion.CoercionThriftCodec;\nimport io.airlift.drift.codec.internal.compiler.CompilerThriftCodecFactory;\nimport io.airlift.drift.codec.metadata.ThriftCatalog;\nimport io.airlift.drift.codec.metadata.ThriftType;\nimport io.airlift.drift.codec.metadata.ThriftTypeReference;\nimport io.airlift.drift.codec.metadata.TypeCoercion;\nimport io.airlift.drift.protocol.TProtocolReader;\nimport io.airlift.drift.protocol.TProtocolWriter;\n\nimport javax.annotation.concurrent.ThreadSafe;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Throwables.throwIfUnchecked;\nimport static java.util.Objects.requireNonNull;\n\n/**\n * ThriftCodecManager contains an index of all known ThriftCodec and can create codecs for\n * unknown types as needed.  Since codec creation can be very expensive only one instance of this\n * class should be created.\n */\n@ThreadSafe\npublic class ThriftCodecManager\n{\n    private final ThriftCatalog catalog;\n    private final LoadingCache<ThriftType, ThriftCodec<?>> typeCodecs;\n\n    /**\n     * This stack tracks the java Types for which building a ThriftCodec is in progress (used to\n     * detect recursion)\n     */\n    private final ThreadLocal<Deque<ThriftType>> stack = ThreadLocal.withInitial(ArrayDeque::new);\n\n    /**\n     * Tracks the Types for which building a ThriftCodec was deferred to allow for recursive type\n     * structures. These will be handled immediately after the originally requested ThriftCodec is\n     * built and cached.\n     */\n    private final ThreadLocal<Deque<ThriftType>> deferredTypesWorkList = ThreadLocal.withInitial(ArrayDeque::new);\n\n    public ThriftCodecManager(ThriftCodec<?>... codecs)\n    {\n        this(new CompilerThriftCodecFactory(ThriftCodecManager.class.getClassLoader()), ImmutableSet.copyOf(codecs));\n    }\n\n    public ThriftCodecManager(ClassLoader parent, ThriftCodec<?>... codecs)\n    {\n        this(new CompilerThriftCodecFactory(parent), ImmutableSet.copyOf(codecs));\n    }\n\n    public ThriftCodecManager(ThriftCodecFactory factory, ThriftCodec<?>... codecs)\n    {\n        this(factory, new ThriftCatalog(), ImmutableSet.copyOf(codecs));\n    }\n\n    public ThriftCodecManager(ThriftCodecFactory factory, Set<ThriftCodec<?>> codecs)\n    {\n        this(factory, new ThriftCatalog(), codecs);\n    }\n\n    @Inject\n    public ThriftCodecManager(ThriftCodecFactory factory, ThriftCatalog catalog, @InternalThriftCodec Set<ThriftCodec<?>> codecs)\n    {\n        requireNonNull(factory, \"factory is null\");\n        this.catalog = requireNonNull(catalog, \"catalog is null\");\n\n        typeCodecs = CacheBuilder.newBuilder().build(new CacheLoader<ThriftType, ThriftCodec<?>>()\n        {\n            @Override\n            public ThriftCodec<?> load(ThriftType type)\n                    throws Exception\n            {\n                try {\n                    // When we need to load a codec for a type the first time, we push it on the\n                    // thread-local stack before starting the load, and pop it off afterwards,\n                    // so that we can detect recursive loads.\n                    stack.get().push(type);\n\n                    switch (type.getProtocolType()) {\n                        case STRUCT:\n                            return factory.generateThriftTypeCodec(ThriftCodecManager.this, type.getStructMetadata());\n                        case MAP:\n                            return new MapThriftCodec<>(type, getElementCodec(type.getKeyTypeReference()), getElementCodec(type.getValueTypeReference()));\n                        case SET:\n                            return new SetThriftCodec<>(type, getElementCodec(type.getValueTypeReference()));\n                        case LIST:\n                            return new ListThriftCodec<>(type, getElementCodec(type.getValueTypeReference()));\n                        case ENUM:\n                            return new EnumThriftCodec<>(type);\n                        default:\n                            if (type.isCoerced()) {\n                                ThriftCodec<?> codec = getCodec(type.getUncoercedType());\n                                TypeCoercion coercion = catalog.getDefaultCoercion(type.getJavaType());\n                                return new CoercionThriftCodec<>(codec, coercion);\n                            }\n                            throw new IllegalArgumentException(\"Unsupported Thrift type \" + type);\n                    }\n                }\n                finally {\n                    ThriftType top = stack.get().pop();\n                    checkState(type.equals(top), \"ThriftCatalog circularity detection stack is corrupt: expected %s, but got %s\", type, top);\n                }\n            }\n        });\n\n        addBuiltinCodec(new BooleanThriftCodec());\n        addBuiltinCodec(new ByteThriftCodec());\n        addBuiltinCodec(new ShortThriftCodec());\n        addBuiltinCodec(new IntegerThriftCodec());\n        addBuiltinCodec(new LongThriftCodec());\n        addBuiltinCodec(new DoubleThriftCodec());\n        addBuiltinCodec(new ByteBufferThriftCodec());\n        addBuiltinCodec(new StringThriftCodec());\n        addBuiltinCodec(new VoidThriftCodec());\n        addBuiltinCodec(new BooleanArrayThriftCodec());\n        addBuiltinCodec(new ShortArrayThriftCodec());\n        addBuiltinCodec(new IntArrayThriftCodec());\n        addBuiltinCodec(new LongArrayThriftCodec());\n        addBuiltinCodec(new DoubleArrayThriftCodec());\n\n        for (ThriftCodec<?> codec : codecs) {\n            addCodec(codec);\n        }\n    }\n\n    public ThriftCodec<?> getElementCodec(ThriftTypeReference thriftTypeReference)\n    {\n        return getCodec(thriftTypeReference.get());\n    }\n\n    public ThriftCodec<?> getCodec(Type javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType);\n        return getCodec(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCodec(Class<T> javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType.getName());\n        return (ThriftCodec<T>) getCodec(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCodec(TypeToken<T> type)\n    {\n        return (ThriftCodec<T>) getCodec(type.getType());\n    }\n\n    public ThriftCodec<?> getCodec(ThriftType type)\n    {\n        // The loading function pushes types before they are loaded and pops them afterwards in\n        // order to detect recursive loading (which will would otherwise fail in the LoadingCache).\n        // In this case, to avoid the cycle, we return a DelegateCodec that points back to this\n        // ThriftCodecManager and references the type. When used, the DelegateCodec will require\n        // that our cache contain an actual ThriftCodec, but this should not be a problem as\n        // it won't be used while we are loading types, and by the time we're done loading the\n        // type at the top of the stack, *all* types on the stack should have been loaded and\n        // cached.\n        if (stack.get().contains(type)) {\n            return new DelegateCodec(this, type.getJavaType());\n        }\n\n        try {\n            ThriftCodec<?> thriftCodec = typeCodecs.get(type);\n\n            while (!deferredTypesWorkList.get().isEmpty()) {\n                getCodec(deferredTypesWorkList.get().pop());\n            }\n\n            return thriftCodec;\n        }\n        catch (ExecutionException e) {\n            throwIfUnchecked(e.getCause());\n            throw new RuntimeException(e.getCause());\n        }\n    }\n\n    public ThriftCodec<?> getCachedCodecIfPresent(Type javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType);\n        return getCachedCodecIfPresent(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCachedCodecIfPresent(Class<T> javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType.getName());\n        return (ThriftCodec<T>) getCachedCodecIfPresent(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCachedCodecIfPresent(TypeToken<T> type)\n    {\n        return (ThriftCodec<T>) getCachedCodecIfPresent(type.getType());\n    }\n\n    public ThriftCodec<?> getCachedCodecIfPresent(ThriftType type)\n    {\n        return typeCodecs.getIfPresent(type);\n    }\n\n    /**\n     * Adds or replaces the codec associated with the type contained in the codec.  This does not\n     * replace any current users of the existing codec associated with the type.\n     */\n    public void addCodec(ThriftCodec<?> codec)\n    {\n        catalog.addThriftType(codec.getType());\n        typeCodecs.put(codec.getType(), codec);\n    }\n\n    /**\n     * Adds a ThriftCodec to the codec map, but does not register it with the catalog since builtins\n     * should already be registered\n     */\n    private void addBuiltinCodec(ThriftCodec<?> codec)\n    {\n        typeCodecs.put(codec.getType(), codec);\n    }\n\n    public ThriftCatalog getCatalog()\n    {\n        return catalog;\n    }\n\n    public <T> T read(Class<T> type, TProtocolReader protocol)\n            throws Exception\n    {\n        return getCodec(type).read(protocol);\n    }\n\n    public Object read(ThriftType type, TProtocolReader protocol)\n            throws Exception\n    {\n        ThriftCodec<?> codec = getCodec(type);\n        return codec.read(protocol);\n    }\n\n    public <T> void write(Class<T> type, T value, TProtocolWriter protocol)\n            throws Exception\n    {\n        getCodec(type).write(value, protocol);\n    }\n\n    public void write(ThriftType type, Object value, TProtocolWriter protocol)\n            throws Exception\n    {\n        ThriftCodec<Object> codec = (ThriftCodec<Object>) getCodec(type);\n        codec.write(value, protocol);\n    }\n}\n", "methodName": "ThriftCodec ThriftCodecManager$1.load(ThriftType)", "exampleID": 0, "dataset": "infer", "filepath": "drift-codec/src/main/java/io/airlift/drift/codec/ThriftCodecManager.java", "line": 131, "sink": "getElementCodec(...)", "steps": [{"line": 131, "source": "type.getKeyTypeReference()", "filepath": "drift-codec/src/main/java/io/airlift/drift/codec/ThriftCodecManager.java", "exampleID": 1}]}, {"url": "dummy", "rawCode": "/*\n * Copyright (C) 2012 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.airlift.drift.codec;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.reflect.TypeToken;\nimport com.google.inject.Inject;\nimport io.airlift.drift.codec.internal.EnumThriftCodec;\nimport io.airlift.drift.codec.internal.ThriftCodecFactory;\nimport io.airlift.drift.codec.internal.builtin.BooleanArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.BooleanThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ByteBufferThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ByteThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.DoubleArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.DoubleThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.IntArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.IntegerThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ListThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.LongArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.LongThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.MapThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.SetThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ShortArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ShortThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.StringThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.VoidThriftCodec;\nimport io.airlift.drift.codec.internal.coercion.CoercionThriftCodec;\nimport io.airlift.drift.codec.internal.compiler.CompilerThriftCodecFactory;\nimport io.airlift.drift.codec.metadata.ThriftCatalog;\nimport io.airlift.drift.codec.metadata.ThriftType;\nimport io.airlift.drift.codec.metadata.ThriftTypeReference;\nimport io.airlift.drift.codec.metadata.TypeCoercion;\nimport io.airlift.drift.protocol.TProtocolReader;\nimport io.airlift.drift.protocol.TProtocolWriter;\n\nimport javax.annotation.concurrent.ThreadSafe;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Throwables.throwIfUnchecked;\nimport static java.util.Objects.requireNonNull;\n\n/**\n * ThriftCodecManager contains an index of all known ThriftCodec and can create codecs for\n * unknown types as needed.  Since codec creation can be very expensive only one instance of this\n * class should be created.\n */\n@ThreadSafe\npublic class ThriftCodecManager\n{\n    private final ThriftCatalog catalog;\n    private final LoadingCache<ThriftType, ThriftCodec<?>> typeCodecs;\n\n    /**\n     * This stack tracks the java Types for which building a ThriftCodec is in progress (used to\n     * detect recursion)\n     */\n    private final ThreadLocal<Deque<ThriftType>> stack = ThreadLocal.withInitial(ArrayDeque::new);\n\n    /**\n     * Tracks the Types for which building a ThriftCodec was deferred to allow for recursive type\n     * structures. These will be handled immediately after the originally requested ThriftCodec is\n     * built and cached.\n     */\n    private final ThreadLocal<Deque<ThriftType>> deferredTypesWorkList = ThreadLocal.withInitial(ArrayDeque::new);\n\n    public ThriftCodecManager(ThriftCodec<?>... codecs)\n    {\n        this(new CompilerThriftCodecFactory(ThriftCodecManager.class.getClassLoader()), ImmutableSet.copyOf(codecs));\n    }\n\n    public ThriftCodecManager(ClassLoader parent, ThriftCodec<?>... codecs)\n    {\n        this(new CompilerThriftCodecFactory(parent), ImmutableSet.copyOf(codecs));\n    }\n\n    public ThriftCodecManager(ThriftCodecFactory factory, ThriftCodec<?>... codecs)\n    {\n        this(factory, new ThriftCatalog(), ImmutableSet.copyOf(codecs));\n    }\n\n    public ThriftCodecManager(ThriftCodecFactory factory, Set<ThriftCodec<?>> codecs)\n    {\n        this(factory, new ThriftCatalog(), codecs);\n    }\n\n    @Inject\n    public ThriftCodecManager(ThriftCodecFactory factory, ThriftCatalog catalog, @InternalThriftCodec Set<ThriftCodec<?>> codecs)\n    {\n        requireNonNull(factory, \"factory is null\");\n        this.catalog = requireNonNull(catalog, \"catalog is null\");\n\n        typeCodecs = CacheBuilder.newBuilder().build(new CacheLoader<ThriftType, ThriftCodec<?>>()\n        {\n            @Override\n            public ThriftCodec<?> load(ThriftType type)\n                    throws Exception\n            {\n                try {\n                    // When we need to load a codec for a type the first time, we push it on the\n                    // thread-local stack before starting the load, and pop it off afterwards,\n                    // so that we can detect recursive loads.\n                    stack.get().push(type);\n\n                    switch (type.getProtocolType()) {\n                        case STRUCT:\n                            return factory.generateThriftTypeCodec(ThriftCodecManager.this, type.getStructMetadata());\n                        case MAP:\n                            return new MapThriftCodec<>(type, getElementCodec(type.getKeyTypeReference()), getElementCodec(type.getValueTypeReference()));\n                        case SET:\n                            return new SetThriftCodec<>(type, getElementCodec(type.getValueTypeReference()));\n                        case LIST:\n                            return new ListThriftCodec<>(type, getElementCodec(type.getValueTypeReference()));\n                        case ENUM:\n                            return new EnumThriftCodec<>(type);\n                        default:\n                            if (type.isCoerced()) {\n                                ThriftCodec<?> codec = getCodec(type.getUncoercedType());\n                                TypeCoercion coercion = catalog.getDefaultCoercion(type.getJavaType());\n                                return new CoercionThriftCodec<>(codec, coercion);\n                            }\n                            throw new IllegalArgumentException(\"Unsupported Thrift type \" + type);\n                    }\n                }\n                finally {\n                    ThriftType top = stack.get().pop();\n                    checkState(type.equals(top), \"ThriftCatalog circularity detection stack is corrupt: expected %s, but got %s\", type, top);\n                }\n            }\n        });\n\n        addBuiltinCodec(new BooleanThriftCodec());\n        addBuiltinCodec(new ByteThriftCodec());\n        addBuiltinCodec(new ShortThriftCodec());\n        addBuiltinCodec(new IntegerThriftCodec());\n        addBuiltinCodec(new LongThriftCodec());\n        addBuiltinCodec(new DoubleThriftCodec());\n        addBuiltinCodec(new ByteBufferThriftCodec());\n        addBuiltinCodec(new StringThriftCodec());\n        addBuiltinCodec(new VoidThriftCodec());\n        addBuiltinCodec(new BooleanArrayThriftCodec());\n        addBuiltinCodec(new ShortArrayThriftCodec());\n        addBuiltinCodec(new IntArrayThriftCodec());\n        addBuiltinCodec(new LongArrayThriftCodec());\n        addBuiltinCodec(new DoubleArrayThriftCodec());\n\n        for (ThriftCodec<?> codec : codecs) {\n            addCodec(codec);\n        }\n    }\n\n    public ThriftCodec<?> getElementCodec(ThriftTypeReference thriftTypeReference)\n    {\n        return getCodec(thriftTypeReference.get());\n    }\n\n    public ThriftCodec<?> getCodec(Type javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType);\n        return getCodec(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCodec(Class<T> javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType.getName());\n        return (ThriftCodec<T>) getCodec(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCodec(TypeToken<T> type)\n    {\n        return (ThriftCodec<T>) getCodec(type.getType());\n    }\n\n    public ThriftCodec<?> getCodec(ThriftType type)\n    {\n        // The loading function pushes types before they are loaded and pops them afterwards in\n        // order to detect recursive loading (which will would otherwise fail in the LoadingCache).\n        // In this case, to avoid the cycle, we return a DelegateCodec that points back to this\n        // ThriftCodecManager and references the type. When used, the DelegateCodec will require\n        // that our cache contain an actual ThriftCodec, but this should not be a problem as\n        // it won't be used while we are loading types, and by the time we're done loading the\n        // type at the top of the stack, *all* types on the stack should have been loaded and\n        // cached.\n        if (stack.get().contains(type)) {\n            return new DelegateCodec(this, type.getJavaType());\n        }\n\n        try {\n            ThriftCodec<?> thriftCodec = typeCodecs.get(type);\n\n            while (!deferredTypesWorkList.get().isEmpty()) {\n                getCodec(deferredTypesWorkList.get().pop());\n            }\n\n            return thriftCodec;\n        }\n        catch (ExecutionException e) {\n            throwIfUnchecked(e.getCause());\n            throw new RuntimeException(e.getCause());\n        }\n    }\n\n    public ThriftCodec<?> getCachedCodecIfPresent(Type javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType);\n        return getCachedCodecIfPresent(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCachedCodecIfPresent(Class<T> javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType.getName());\n        return (ThriftCodec<T>) getCachedCodecIfPresent(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCachedCodecIfPresent(TypeToken<T> type)\n    {\n        return (ThriftCodec<T>) getCachedCodecIfPresent(type.getType());\n    }\n\n    public ThriftCodec<?> getCachedCodecIfPresent(ThriftType type)\n    {\n        return typeCodecs.getIfPresent(type);\n    }\n\n    /**\n     * Adds or replaces the codec associated with the type contained in the codec.  This does not\n     * replace any current users of the existing codec associated with the type.\n     */\n    public void addCodec(ThriftCodec<?> codec)\n    {\n        catalog.addThriftType(codec.getType());\n        typeCodecs.put(codec.getType(), codec);\n    }\n\n    /**\n     * Adds a ThriftCodec to the codec map, but does not register it with the catalog since builtins\n     * should already be registered\n     */\n    private void addBuiltinCodec(ThriftCodec<?> codec)\n    {\n        typeCodecs.put(codec.getType(), codec);\n    }\n\n    public ThriftCatalog getCatalog()\n    {\n        return catalog;\n    }\n\n    public <T> T read(Class<T> type, TProtocolReader protocol)\n            throws Exception\n    {\n        return getCodec(type).read(protocol);\n    }\n\n    public Object read(ThriftType type, TProtocolReader protocol)\n            throws Exception\n    {\n        ThriftCodec<?> codec = getCodec(type);\n        return codec.read(protocol);\n    }\n\n    public <T> void write(Class<T> type, T value, TProtocolWriter protocol)\n            throws Exception\n    {\n        getCodec(type).write(value, protocol);\n    }\n\n    public void write(ThriftType type, Object value, TProtocolWriter protocol)\n            throws Exception\n    {\n        ThriftCodec<Object> codec = (ThriftCodec<Object>) getCodec(type);\n        codec.write(value, protocol);\n    }\n}\n", "methodName": "ThriftCodec ThriftCodecManager$1.load(ThriftType)", "exampleID": 2, "dataset": "infer", "filepath": "drift-codec/src/main/java/io/airlift/drift/codec/ThriftCodecManager.java", "line": 131, "sink": "getElementCodec(...)", "steps": [{"line": 131, "source": "type.getValueTypeReference()", "filepath": "drift-codec/src/main/java/io/airlift/drift/codec/ThriftCodecManager.java", "exampleID": 3}]}, {"url": "dummy", "rawCode": "/*\n * Copyright (C) 2012 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.airlift.drift.codec;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.reflect.TypeToken;\nimport com.google.inject.Inject;\nimport io.airlift.drift.codec.internal.EnumThriftCodec;\nimport io.airlift.drift.codec.internal.ThriftCodecFactory;\nimport io.airlift.drift.codec.internal.builtin.BooleanArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.BooleanThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ByteBufferThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ByteThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.DoubleArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.DoubleThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.IntArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.IntegerThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ListThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.LongArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.LongThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.MapThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.SetThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ShortArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ShortThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.StringThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.VoidThriftCodec;\nimport io.airlift.drift.codec.internal.coercion.CoercionThriftCodec;\nimport io.airlift.drift.codec.internal.compiler.CompilerThriftCodecFactory;\nimport io.airlift.drift.codec.metadata.ThriftCatalog;\nimport io.airlift.drift.codec.metadata.ThriftType;\nimport io.airlift.drift.codec.metadata.ThriftTypeReference;\nimport io.airlift.drift.codec.metadata.TypeCoercion;\nimport io.airlift.drift.protocol.TProtocolReader;\nimport io.airlift.drift.protocol.TProtocolWriter;\n\nimport javax.annotation.concurrent.ThreadSafe;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Throwables.throwIfUnchecked;\nimport static java.util.Objects.requireNonNull;\n\n/**\n * ThriftCodecManager contains an index of all known ThriftCodec and can create codecs for\n * unknown types as needed.  Since codec creation can be very expensive only one instance of this\n * class should be created.\n */\n@ThreadSafe\npublic class ThriftCodecManager\n{\n    private final ThriftCatalog catalog;\n    private final LoadingCache<ThriftType, ThriftCodec<?>> typeCodecs;\n\n    /**\n     * This stack tracks the java Types for which building a ThriftCodec is in progress (used to\n     * detect recursion)\n     */\n    private final ThreadLocal<Deque<ThriftType>> stack = ThreadLocal.withInitial(ArrayDeque::new);\n\n    /**\n     * Tracks the Types for which building a ThriftCodec was deferred to allow for recursive type\n     * structures. These will be handled immediately after the originally requested ThriftCodec is\n     * built and cached.\n     */\n    private final ThreadLocal<Deque<ThriftType>> deferredTypesWorkList = ThreadLocal.withInitial(ArrayDeque::new);\n\n    public ThriftCodecManager(ThriftCodec<?>... codecs)\n    {\n        this(new CompilerThriftCodecFactory(ThriftCodecManager.class.getClassLoader()), ImmutableSet.copyOf(codecs));\n    }\n\n    public ThriftCodecManager(ClassLoader parent, ThriftCodec<?>... codecs)\n    {\n        this(new CompilerThriftCodecFactory(parent), ImmutableSet.copyOf(codecs));\n    }\n\n    public ThriftCodecManager(ThriftCodecFactory factory, ThriftCodec<?>... codecs)\n    {\n        this(factory, new ThriftCatalog(), ImmutableSet.copyOf(codecs));\n    }\n\n    public ThriftCodecManager(ThriftCodecFactory factory, Set<ThriftCodec<?>> codecs)\n    {\n        this(factory, new ThriftCatalog(), codecs);\n    }\n\n    @Inject\n    public ThriftCodecManager(ThriftCodecFactory factory, ThriftCatalog catalog, @InternalThriftCodec Set<ThriftCodec<?>> codecs)\n    {\n        requireNonNull(factory, \"factory is null\");\n        this.catalog = requireNonNull(catalog, \"catalog is null\");\n\n        typeCodecs = CacheBuilder.newBuilder().build(new CacheLoader<ThriftType, ThriftCodec<?>>()\n        {\n            @Override\n            public ThriftCodec<?> load(ThriftType type)\n                    throws Exception\n            {\n                try {\n                    // When we need to load a codec for a type the first time, we push it on the\n                    // thread-local stack before starting the load, and pop it off afterwards,\n                    // so that we can detect recursive loads.\n                    stack.get().push(type);\n\n                    switch (type.getProtocolType()) {\n                        case STRUCT:\n                            return factory.generateThriftTypeCodec(ThriftCodecManager.this, type.getStructMetadata());\n                        case MAP:\n                            return new MapThriftCodec<>(type, getElementCodec(type.getKeyTypeReference()), getElementCodec(type.getValueTypeReference()));\n                        case SET:\n                            return new SetThriftCodec<>(type, getElementCodec(type.getValueTypeReference()));\n                        case LIST:\n                            return new ListThriftCodec<>(type, getElementCodec(type.getValueTypeReference()));\n                        case ENUM:\n                            return new EnumThriftCodec<>(type);\n                        default:\n                            if (type.isCoerced()) {\n                                ThriftCodec<?> codec = getCodec(type.getUncoercedType());\n                                TypeCoercion coercion = catalog.getDefaultCoercion(type.getJavaType());\n                                return new CoercionThriftCodec<>(codec, coercion);\n                            }\n                            throw new IllegalArgumentException(\"Unsupported Thrift type \" + type);\n                    }\n                }\n                finally {\n                    ThriftType top = stack.get().pop();\n                    checkState(type.equals(top), \"ThriftCatalog circularity detection stack is corrupt: expected %s, but got %s\", type, top);\n                }\n            }\n        });\n\n        addBuiltinCodec(new BooleanThriftCodec());\n        addBuiltinCodec(new ByteThriftCodec());\n        addBuiltinCodec(new ShortThriftCodec());\n        addBuiltinCodec(new IntegerThriftCodec());\n        addBuiltinCodec(new LongThriftCodec());\n        addBuiltinCodec(new DoubleThriftCodec());\n        addBuiltinCodec(new ByteBufferThriftCodec());\n        addBuiltinCodec(new StringThriftCodec());\n        addBuiltinCodec(new VoidThriftCodec());\n        addBuiltinCodec(new BooleanArrayThriftCodec());\n        addBuiltinCodec(new ShortArrayThriftCodec());\n        addBuiltinCodec(new IntArrayThriftCodec());\n        addBuiltinCodec(new LongArrayThriftCodec());\n        addBuiltinCodec(new DoubleArrayThriftCodec());\n\n        for (ThriftCodec<?> codec : codecs) {\n            addCodec(codec);\n        }\n    }\n\n    public ThriftCodec<?> getElementCodec(ThriftTypeReference thriftTypeReference)\n    {\n        return getCodec(thriftTypeReference.get());\n    }\n\n    public ThriftCodec<?> getCodec(Type javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType);\n        return getCodec(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCodec(Class<T> javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType.getName());\n        return (ThriftCodec<T>) getCodec(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCodec(TypeToken<T> type)\n    {\n        return (ThriftCodec<T>) getCodec(type.getType());\n    }\n\n    public ThriftCodec<?> getCodec(ThriftType type)\n    {\n        // The loading function pushes types before they are loaded and pops them afterwards in\n        // order to detect recursive loading (which will would otherwise fail in the LoadingCache).\n        // In this case, to avoid the cycle, we return a DelegateCodec that points back to this\n        // ThriftCodecManager and references the type. When used, the DelegateCodec will require\n        // that our cache contain an actual ThriftCodec, but this should not be a problem as\n        // it won't be used while we are loading types, and by the time we're done loading the\n        // type at the top of the stack, *all* types on the stack should have been loaded and\n        // cached.\n        if (stack.get().contains(type)) {\n            return new DelegateCodec(this, type.getJavaType());\n        }\n\n        try {\n            ThriftCodec<?> thriftCodec = typeCodecs.get(type);\n\n            while (!deferredTypesWorkList.get().isEmpty()) {\n                getCodec(deferredTypesWorkList.get().pop());\n            }\n\n            return thriftCodec;\n        }\n        catch (ExecutionException e) {\n            throwIfUnchecked(e.getCause());\n            throw new RuntimeException(e.getCause());\n        }\n    }\n\n    public ThriftCodec<?> getCachedCodecIfPresent(Type javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType);\n        return getCachedCodecIfPresent(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCachedCodecIfPresent(Class<T> javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType.getName());\n        return (ThriftCodec<T>) getCachedCodecIfPresent(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCachedCodecIfPresent(TypeToken<T> type)\n    {\n        return (ThriftCodec<T>) getCachedCodecIfPresent(type.getType());\n    }\n\n    public ThriftCodec<?> getCachedCodecIfPresent(ThriftType type)\n    {\n        return typeCodecs.getIfPresent(type);\n    }\n\n    /**\n     * Adds or replaces the codec associated with the type contained in the codec.  This does not\n     * replace any current users of the existing codec associated with the type.\n     */\n    public void addCodec(ThriftCodec<?> codec)\n    {\n        catalog.addThriftType(codec.getType());\n        typeCodecs.put(codec.getType(), codec);\n    }\n\n    /**\n     * Adds a ThriftCodec to the codec map, but does not register it with the catalog since builtins\n     * should already be registered\n     */\n    private void addBuiltinCodec(ThriftCodec<?> codec)\n    {\n        typeCodecs.put(codec.getType(), codec);\n    }\n\n    public ThriftCatalog getCatalog()\n    {\n        return catalog;\n    }\n\n    public <T> T read(Class<T> type, TProtocolReader protocol)\n            throws Exception\n    {\n        return getCodec(type).read(protocol);\n    }\n\n    public Object read(ThriftType type, TProtocolReader protocol)\n            throws Exception\n    {\n        ThriftCodec<?> codec = getCodec(type);\n        return codec.read(protocol);\n    }\n\n    public <T> void write(Class<T> type, T value, TProtocolWriter protocol)\n            throws Exception\n    {\n        getCodec(type).write(value, protocol);\n    }\n\n    public void write(ThriftType type, Object value, TProtocolWriter protocol)\n            throws Exception\n    {\n        ThriftCodec<Object> codec = (ThriftCodec<Object>) getCodec(type);\n        codec.write(value, protocol);\n    }\n}\n", "methodName": "ThriftCodec ThriftCodecManager$1.load(ThriftType)", "exampleID": 4, "dataset": "infer", "filepath": "drift-codec/src/main/java/io/airlift/drift/codec/ThriftCodecManager.java", "line": 133, "sink": "getElementCodec(...)", "steps": [{"line": 133, "source": "type.getValueTypeReference()", "filepath": "drift-codec/src/main/java/io/airlift/drift/codec/ThriftCodecManager.java", "exampleID": 5}]}, {"url": "dummy", "rawCode": "/*\n * Copyright (C) 2012 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.airlift.drift.codec;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.reflect.TypeToken;\nimport com.google.inject.Inject;\nimport io.airlift.drift.codec.internal.EnumThriftCodec;\nimport io.airlift.drift.codec.internal.ThriftCodecFactory;\nimport io.airlift.drift.codec.internal.builtin.BooleanArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.BooleanThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ByteBufferThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ByteThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.DoubleArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.DoubleThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.IntArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.IntegerThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ListThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.LongArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.LongThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.MapThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.SetThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ShortArrayThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.ShortThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.StringThriftCodec;\nimport io.airlift.drift.codec.internal.builtin.VoidThriftCodec;\nimport io.airlift.drift.codec.internal.coercion.CoercionThriftCodec;\nimport io.airlift.drift.codec.internal.compiler.CompilerThriftCodecFactory;\nimport io.airlift.drift.codec.metadata.ThriftCatalog;\nimport io.airlift.drift.codec.metadata.ThriftType;\nimport io.airlift.drift.codec.metadata.ThriftTypeReference;\nimport io.airlift.drift.codec.metadata.TypeCoercion;\nimport io.airlift.drift.protocol.TProtocolReader;\nimport io.airlift.drift.protocol.TProtocolWriter;\n\nimport javax.annotation.concurrent.ThreadSafe;\n\nimport java.lang.reflect.Type;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Throwables.throwIfUnchecked;\nimport static java.util.Objects.requireNonNull;\n\n/**\n * ThriftCodecManager contains an index of all known ThriftCodec and can create codecs for\n * unknown types as needed.  Since codec creation can be very expensive only one instance of this\n * class should be created.\n */\n@ThreadSafe\npublic class ThriftCodecManager\n{\n    private final ThriftCatalog catalog;\n    private final LoadingCache<ThriftType, ThriftCodec<?>> typeCodecs;\n\n    /**\n     * This stack tracks the java Types for which building a ThriftCodec is in progress (used to\n     * detect recursion)\n     */\n    private final ThreadLocal<Deque<ThriftType>> stack = ThreadLocal.withInitial(ArrayDeque::new);\n\n    /**\n     * Tracks the Types for which building a ThriftCodec was deferred to allow for recursive type\n     * structures. These will be handled immediately after the originally requested ThriftCodec is\n     * built and cached.\n     */\n    private final ThreadLocal<Deque<ThriftType>> deferredTypesWorkList = ThreadLocal.withInitial(ArrayDeque::new);\n\n    public ThriftCodecManager(ThriftCodec<?>... codecs)\n    {\n        this(new CompilerThriftCodecFactory(ThriftCodecManager.class.getClassLoader()), ImmutableSet.copyOf(codecs));\n    }\n\n    public ThriftCodecManager(ClassLoader parent, ThriftCodec<?>... codecs)\n    {\n        this(new CompilerThriftCodecFactory(parent), ImmutableSet.copyOf(codecs));\n    }\n\n    public ThriftCodecManager(ThriftCodecFactory factory, ThriftCodec<?>... codecs)\n    {\n        this(factory, new ThriftCatalog(), ImmutableSet.copyOf(codecs));\n    }\n\n    public ThriftCodecManager(ThriftCodecFactory factory, Set<ThriftCodec<?>> codecs)\n    {\n        this(factory, new ThriftCatalog(), codecs);\n    }\n\n    @Inject\n    public ThriftCodecManager(ThriftCodecFactory factory, ThriftCatalog catalog, @InternalThriftCodec Set<ThriftCodec<?>> codecs)\n    {\n        requireNonNull(factory, \"factory is null\");\n        this.catalog = requireNonNull(catalog, \"catalog is null\");\n\n        typeCodecs = CacheBuilder.newBuilder().build(new CacheLoader<ThriftType, ThriftCodec<?>>()\n        {\n            @Override\n            public ThriftCodec<?> load(ThriftType type)\n                    throws Exception\n            {\n                try {\n                    // When we need to load a codec for a type the first time, we push it on the\n                    // thread-local stack before starting the load, and pop it off afterwards,\n                    // so that we can detect recursive loads.\n                    stack.get().push(type);\n\n                    switch (type.getProtocolType()) {\n                        case STRUCT:\n                            return factory.generateThriftTypeCodec(ThriftCodecManager.this, type.getStructMetadata());\n                        case MAP:\n                            return new MapThriftCodec<>(type, getElementCodec(type.getKeyTypeReference()), getElementCodec(type.getValueTypeReference()));\n                        case SET:\n                            return new SetThriftCodec<>(type, getElementCodec(type.getValueTypeReference()));\n                        case LIST:\n                            return new ListThriftCodec<>(type, getElementCodec(type.getValueTypeReference()));\n                        case ENUM:\n                            return new EnumThriftCodec<>(type);\n                        default:\n                            if (type.isCoerced()) {\n                                ThriftCodec<?> codec = getCodec(type.getUncoercedType());\n                                TypeCoercion coercion = catalog.getDefaultCoercion(type.getJavaType());\n                                return new CoercionThriftCodec<>(codec, coercion);\n                            }\n                            throw new IllegalArgumentException(\"Unsupported Thrift type \" + type);\n                    }\n                }\n                finally {\n                    ThriftType top = stack.get().pop();\n                    checkState(type.equals(top), \"ThriftCatalog circularity detection stack is corrupt: expected %s, but got %s\", type, top);\n                }\n            }\n        });\n\n        addBuiltinCodec(new BooleanThriftCodec());\n        addBuiltinCodec(new ByteThriftCodec());\n        addBuiltinCodec(new ShortThriftCodec());\n        addBuiltinCodec(new IntegerThriftCodec());\n        addBuiltinCodec(new LongThriftCodec());\n        addBuiltinCodec(new DoubleThriftCodec());\n        addBuiltinCodec(new ByteBufferThriftCodec());\n        addBuiltinCodec(new StringThriftCodec());\n        addBuiltinCodec(new VoidThriftCodec());\n        addBuiltinCodec(new BooleanArrayThriftCodec());\n        addBuiltinCodec(new ShortArrayThriftCodec());\n        addBuiltinCodec(new IntArrayThriftCodec());\n        addBuiltinCodec(new LongArrayThriftCodec());\n        addBuiltinCodec(new DoubleArrayThriftCodec());\n\n        for (ThriftCodec<?> codec : codecs) {\n            addCodec(codec);\n        }\n    }\n\n    public ThriftCodec<?> getElementCodec(ThriftTypeReference thriftTypeReference)\n    {\n        return getCodec(thriftTypeReference.get());\n    }\n\n    public ThriftCodec<?> getCodec(Type javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType);\n        return getCodec(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCodec(Class<T> javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType.getName());\n        return (ThriftCodec<T>) getCodec(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCodec(TypeToken<T> type)\n    {\n        return (ThriftCodec<T>) getCodec(type.getType());\n    }\n\n    public ThriftCodec<?> getCodec(ThriftType type)\n    {\n        // The loading function pushes types before they are loaded and pops them afterwards in\n        // order to detect recursive loading (which will would otherwise fail in the LoadingCache).\n        // In this case, to avoid the cycle, we return a DelegateCodec that points back to this\n        // ThriftCodecManager and references the type. When used, the DelegateCodec will require\n        // that our cache contain an actual ThriftCodec, but this should not be a problem as\n        // it won't be used while we are loading types, and by the time we're done loading the\n        // type at the top of the stack, *all* types on the stack should have been loaded and\n        // cached.\n        if (stack.get().contains(type)) {\n            return new DelegateCodec(this, type.getJavaType());\n        }\n\n        try {\n            ThriftCodec<?> thriftCodec = typeCodecs.get(type);\n\n            while (!deferredTypesWorkList.get().isEmpty()) {\n                getCodec(deferredTypesWorkList.get().pop());\n            }\n\n            return thriftCodec;\n        }\n        catch (ExecutionException e) {\n            throwIfUnchecked(e.getCause());\n            throw new RuntimeException(e.getCause());\n        }\n    }\n\n    public ThriftCodec<?> getCachedCodecIfPresent(Type javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType);\n        return getCachedCodecIfPresent(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCachedCodecIfPresent(Class<T> javaType)\n    {\n        ThriftType thriftType = catalog.getThriftType(javaType);\n        checkArgument(thriftType != null, \"Unsupported java type %s\", javaType.getName());\n        return (ThriftCodec<T>) getCachedCodecIfPresent(thriftType);\n    }\n\n    public <T> ThriftCodec<T> getCachedCodecIfPresent(TypeToken<T> type)\n    {\n        return (ThriftCodec<T>) getCachedCodecIfPresent(type.getType());\n    }\n\n    public ThriftCodec<?> getCachedCodecIfPresent(ThriftType type)\n    {\n        return typeCodecs.getIfPresent(type);\n    }\n\n    /**\n     * Adds or replaces the codec associated with the type contained in the codec.  This does not\n     * replace any current users of the existing codec associated with the type.\n     */\n    public void addCodec(ThriftCodec<?> codec)\n    {\n        catalog.addThriftType(codec.getType());\n        typeCodecs.put(codec.getType(), codec);\n    }\n\n    /**\n     * Adds a ThriftCodec to the codec map, but does not register it with the catalog since builtins\n     * should already be registered\n     */\n    private void addBuiltinCodec(ThriftCodec<?> codec)\n    {\n        typeCodecs.put(codec.getType(), codec);\n    }\n\n    public ThriftCatalog getCatalog()\n    {\n        return catalog;\n    }\n\n    public <T> T read(Class<T> type, TProtocolReader protocol)\n            throws Exception\n    {\n        return getCodec(type).read(protocol);\n    }\n\n    public Object read(ThriftType type, TProtocolReader protocol)\n            throws Exception\n    {\n        ThriftCodec<?> codec = getCodec(type);\n        return codec.read(protocol);\n    }\n\n    public <T> void write(Class<T> type, T value, TProtocolWriter protocol)\n            throws Exception\n    {\n        getCodec(type).write(value, protocol);\n    }\n\n    public void write(ThriftType type, Object value, TProtocolWriter protocol)\n            throws Exception\n    {\n        ThriftCodec<Object> codec = (ThriftCodec<Object>) getCodec(type);\n        codec.write(value, protocol);\n    }\n}\n", "methodName": "ThriftCodec ThriftCodecManager$1.load(ThriftType)", "exampleID": 6, "dataset": "infer", "filepath": "drift-codec/src/main/java/io/airlift/drift/codec/ThriftCodecManager.java", "line": 135, "sink": "getElementCodec(...)", "steps": [{"line": 135, "source": "type.getValueTypeReference()", "filepath": "drift-codec/src/main/java/io/airlift/drift/codec/ThriftCodecManager.java", "exampleID": 7}]}, {"url": "dummy", "rawCode": "/*\n * Copyright (C) 2012 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.airlift.drift.codec.metadata;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Iterables;\nimport io.airlift.drift.annotations.ThriftIdlAnnotation;\nimport io.airlift.drift.annotations.ThriftStruct;\nimport io.airlift.drift.codec.metadata.ThriftStructMetadata.MetadataType;\n\nimport javax.annotation.concurrent.NotThreadSafe;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport static io.airlift.drift.annotations.ThriftField.Requiredness;\nimport static io.airlift.drift.codec.metadata.FieldKind.THRIFT_FIELD;\n\n@NotThreadSafe\npublic class ThriftStructMetadataBuilder\n        extends AbstractThriftMetadataBuilder\n{\n    public ThriftStructMetadataBuilder(ThriftCatalog catalog, Type structType)\n    {\n        super(catalog, structType);\n\n        // verify the class is public and has the correct annotations\n        verifyClass(ThriftStruct.class);\n\n        // finally normalize the field metadata using things like\n        normalizeThriftFields(catalog);\n    }\n\n    @Override\n    protected String extractName()\n    {\n        ThriftStruct annotation = getStructClass().getAnnotation(ThriftStruct.class);\n        if (annotation == null) {\n            return getStructClass().getSimpleName();\n        }\n        else if (!annotation.value().isEmpty()) {\n            return annotation.value();\n        }\n        else {\n            return getStructClass().getSimpleName();\n        }\n    }\n\n    @Override\n    protected Map<String, String> extractStructIdlAnnotations()\n    {\n        ThriftStruct annotation = getStructClass().getAnnotation(ThriftStruct.class);\n        if (annotation == null) {\n            return ImmutableMap.of();\n        }\n        else {\n            ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();\n            for (ThriftIdlAnnotation idlAnnotation : annotation.idlAnnotations()) {\n                builder.put(idlAnnotation.key(), idlAnnotation.value());\n            }\n            return builder.build();\n        }\n    }\n\n    @Override\n    protected Class<?> extractBuilderClass()\n    {\n        ThriftStruct annotation = getStructClass().getAnnotation(ThriftStruct.class);\n        if (annotation != null && !annotation.builder().equals(void.class)) {\n            return annotation.builder();\n        }\n        else {\n            return null;\n        }\n    }\n\n    @Override\n    protected void validateConstructors()\n    {\n        if (constructorInjections.size() > 1) {\n            metadataErrors.addError(\"Multiple constructors are annotated with @ThriftConstructor \", constructorInjections);\n        }\n    }\n\n    @Override\n    protected boolean isValidateSetter(Method method)\n    {\n        return method.getParameterTypes().length >= 1;\n    }\n\n    //\n    // Build final metadata\n    //\n    @Override\n    public ThriftStructMetadata build()\n    {\n        // this code assumes that metadata is clean\n        metadataErrors.throwIfHasErrors();\n\n        // builder constructor injection\n        ThriftMethodInjection builderMethodInjection = buildBuilderConstructorInjections();\n\n        // constructor injection (or factory method for builder)\n        ThriftConstructorInjection constructorInjections = buildConstructorInjection();\n\n        // fields injections\n        Iterable<ThriftFieldMetadata> fieldsMetadata = buildFieldInjections();\n\n        // methods injections\n        List<ThriftMethodInjection> methodInjections = buildMethodInjections();\n\n        return new ThriftStructMetadata(\n                structName,\n                extractStructIdlAnnotations(),\n                structType,\n                builderType,\n                MetadataType.STRUCT,\n                Optional.ofNullable(builderMethodInjection),\n                ImmutableList.copyOf(documentation),\n                ImmutableList.copyOf(fieldsMetadata),\n                Optional.of(constructorInjections),\n                methodInjections);\n    }\n\n    private ThriftConstructorInjection buildConstructorInjection()\n    {\n        ConstructorInjection injection = Iterables.getOnlyElement(constructorInjections);\n        return new ThriftConstructorInjection(injection.getConstructor(), buildParameterInjections(injection.getParameters()));\n    }\n\n    @Override\n    protected ThriftFieldMetadata buildField(Collection<FieldMetadata> input)\n    {\n        short id = -1;\n        boolean isLegacyId = false;\n        Map<String, String> idlAnnotations = null;\n        String name = null;\n        Requiredness requiredness = Requiredness.UNSPECIFIED;\n        boolean recursive = false;\n        ThriftTypeReference thriftTypeReference = null;\n\n        // process field injections and extractions\n        ImmutableList.Builder<ThriftInjection> injections = ImmutableList.builder();\n        ThriftExtraction extraction = null;\n        for (FieldMetadata fieldMetadata : input) {\n            id = fieldMetadata.getId();\n            isLegacyId = fieldMetadata.isLegacyId();\n            name = fieldMetadata.getName();\n            recursive = fieldMetadata.isRecursiveReference();\n            requiredness = fieldMetadata.getRequiredness();\n            idlAnnotations = fieldMetadata.getIdlAnnotations();\n            thriftTypeReference = catalog.getFieldThriftTypeReference(fieldMetadata);\n\n            if (fieldMetadata instanceof FieldInjection) {\n                FieldInjection fieldInjection = (FieldInjection) fieldMetadata;\n                injections.add(new ThriftFieldInjection(fieldInjection.getId(), fieldInjection.getName(), fieldInjection.getField(), fieldInjection.getType()));\n            }\n            else if (fieldMetadata instanceof ParameterInjection) {\n                ParameterInjection parameterInjection = (ParameterInjection) fieldMetadata;\n                injections.add(new ThriftParameterInjection(\n                        parameterInjection.getId(),\n                        parameterInjection.getName(),\n                        parameterInjection.getParameterIndex(),\n                        fieldMetadata.getJavaType()));\n            }\n            else if (fieldMetadata instanceof FieldExtractor) {\n                FieldExtractor fieldExtractor = (FieldExtractor) fieldMetadata;\n                extraction = new ThriftFieldExtractor(\n                        fieldExtractor.getId(),\n                        fieldExtractor.getName(),\n                        fieldExtractor.getType(),\n                        fieldExtractor.getField(),\n                        fieldExtractor.getJavaType());\n            }\n            else if (fieldMetadata instanceof MethodExtractor) {\n                MethodExtractor methodExtractor = (MethodExtractor) fieldMetadata;\n                extraction = new ThriftMethodExtractor(\n                        methodExtractor.getId(),\n                        methodExtractor.getName(),\n                        methodExtractor.getType(),\n                        methodExtractor.getMethod(),\n                        methodExtractor.getJavaType());\n            }\n        }\n\n        // add type coercion\n        TypeCoercion coercion = null;\n        if (!thriftTypeReference.isRecursive() && thriftTypeReference.get().isCoerced()) {\n            coercion = catalog.getDefaultCoercion(thriftTypeReference.get().getJavaType());\n        }\n\n        if (recursive && requiredness != Requiredness.OPTIONAL) {\n            metadataErrors.addError(\"Struct '%s' field '%s' is recursive but not marked optional\", structName, name);\n        }\n\n        return new ThriftFieldMetadata(\n                id,\n                isLegacyId,\n                recursive,\n                requiredness,\n                idlAnnotations,\n                thriftTypeReference,\n                name,\n                THRIFT_FIELD,\n                injections.build(),\n                Optional.empty(),\n                Optional.empty(),\n                Optional.ofNullable(extraction),\n                Optional.ofNullable(coercion));\n    }\n}\n", "methodName": "ThriftFieldMetadata ThriftStructMetadataBuilder.buildField(Collection)", "exampleID": 8, "dataset": "infer", "filepath": "drift-codec/src/main/java/io/airlift/drift/codec/metadata/ThriftStructMetadataBuilder.java", "line": 206, "sink": "thriftTypeReference", "steps": [{"line": 158, "source": "thriftTypeReference", "filepath": "drift-codec/src/main/java/io/airlift/drift/codec/metadata/ThriftStructMetadataBuilder.java", "exampleID": 9}]}, {"url": "dummy", "rawCode": "/*\n * Copyright (C) 2012 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.airlift.drift.codec.metadata;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport io.airlift.drift.annotations.ThriftIdlAnnotation;\nimport io.airlift.drift.annotations.ThriftUnion;\nimport io.airlift.drift.annotations.ThriftUnionId;\nimport io.airlift.drift.codec.metadata.ThriftStructMetadata.MetadataType;\n\nimport javax.annotation.concurrent.NotThreadSafe;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport static io.airlift.drift.annotations.ThriftField.Requiredness;\nimport static io.airlift.drift.codec.metadata.FieldKind.THRIFT_UNION_ID;\nimport static io.airlift.drift.codec.metadata.ReflectionHelper.findAnnotatedMethods;\n\n@NotThreadSafe\npublic class ThriftUnionMetadataBuilder\n        extends AbstractThriftMetadataBuilder\n{\n    public ThriftUnionMetadataBuilder(ThriftCatalog catalog, Type structType)\n    {\n        super(catalog, structType);\n\n        // verify the class is public and has the correct annotations\n        verifyClass(ThriftUnion.class);\n\n        // extract the @ThriftUnionId fields\n        extractThriftUnionId();\n\n        // finally normalize the field metadata using things like\n        normalizeThriftFields(catalog);\n    }\n\n    @Override\n    protected String extractName()\n    {\n        ThriftUnion annotation = getStructClass().getAnnotation(ThriftUnion.class);\n        if (annotation == null) {\n            return getStructClass().getSimpleName();\n        }\n        else if (!annotation.value().isEmpty()) {\n            return annotation.value();\n        }\n        else {\n            return getStructClass().getSimpleName();\n        }\n    }\n\n    @Override\n    protected Map<String, String> extractStructIdlAnnotations()\n    {\n        ThriftUnion annotation = getStructClass().getAnnotation(ThriftUnion.class);\n        if (annotation == null) {\n            return ImmutableMap.of();\n        }\n        else {\n            ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();\n            for (ThriftIdlAnnotation idlAnnotation : annotation.idlAnnotations()) {\n                builder.put(idlAnnotation.key(), idlAnnotation.value());\n            }\n            return builder.build();\n        }\n    }\n\n    @Override\n    protected Class<?> extractBuilderClass()\n    {\n        ThriftUnion annotation = getStructClass().getAnnotation(ThriftUnion.class);\n        if (annotation != null && !annotation.builder().equals(void.class)) {\n            return annotation.builder();\n        }\n        else {\n            return null;\n        }\n    }\n\n    private void extractThriftUnionId()\n    {\n        Collection<Field> idFields = ReflectionHelper.findAnnotatedFields(getStructClass(), ThriftUnionId.class);\n        Collection<Method> idMethods = findAnnotatedMethods(getStructClass(), ThriftUnionId.class);\n\n        if (idFields.size() + idMethods.size() != 1) {\n            if (idFields.size() + idMethods.size() == 0) {\n                metadataErrors.addError(\"Neither a field nor a method is annotated with @ThriftUnionId\");\n            }\n            else if (idFields.size() > 1) {\n                metadataErrors.addError(\"More than one @ThriftUnionId field present\");\n            }\n            else if (idMethods.size() > 1) {\n                metadataErrors.addError(\"More than one @ThriftUnionId method present\");\n            }\n            else {\n                metadataErrors.addError(\"Both fields and methods annotated with @ThriftUnionId\");\n            }\n            return;\n        }\n\n        for (Field idField : idFields) {\n            FieldExtractor fieldExtractor = new FieldExtractor(structType, idField, null, THRIFT_UNION_ID);\n            fields.add(fieldExtractor);\n            extractors.add(fieldExtractor);\n\n            FieldInjection fieldInjection = new FieldInjection(structType, idField, null, THRIFT_UNION_ID);\n            fields.add(fieldInjection);\n            fieldInjections.add(fieldInjection);\n        }\n\n        for (Method idMethod : idMethods) {\n            if (!Modifier.isPublic(idMethod.getModifiers())) {\n                metadataErrors.addError(\"@ThriftUnionId method [%s] is not public\", idMethod.toGenericString());\n                continue;\n            }\n            if (Modifier.isStatic(idMethod.getModifiers())) {\n                metadataErrors.addError(\"@ThriftUnionId method [%s] is static\", idMethod.toGenericString());\n                continue;\n            }\n\n            if (isValidateGetter(idMethod)) {\n                MethodExtractor methodExtractor = new MethodExtractor(structType, idMethod, null, THRIFT_UNION_ID);\n                fields.add(methodExtractor);\n                extractors.add(methodExtractor);\n            }\n        }\n    }\n\n    @Override\n    protected void validateConstructors()\n    {\n        for (ConstructorInjection constructorInjection : constructorInjections) {\n            if (constructorInjection.getParameters().size() > 1) {\n                metadataErrors.addError(\n                        \"@ThriftConstructor [%s] takes %d arguments, this is illegal for an union\",\n                        constructorInjection.getConstructor().toGenericString(),\n                        constructorInjection.getParameters().size());\n            }\n        }\n    }\n\n    @Override\n    protected boolean isValidateSetter(Method method)\n    {\n        // Unions only allow setters with exactly one parameters\n        return method.getParameterTypes().length == 1;\n    }\n\n    //\n    // Build final metadata\n    //\n    @Override\n    public ThriftStructMetadata build()\n    {\n        // this code assumes that metadata is clean\n        metadataErrors.throwIfHasErrors();\n\n        // builder constructor injection\n        ThriftMethodInjection builderMethodInjection = buildBuilderConstructorInjections();\n\n        // constructor injection (or factory method for builder)\n        ThriftConstructorInjection constructorInjection = buildConstructorInjection();\n\n        // fields injections\n        Iterable<ThriftFieldMetadata> fieldsMetadata = buildFieldInjections();\n\n        // methods injections\n        List<ThriftMethodInjection> methodInjections = buildMethodInjections();\n\n        return new ThriftStructMetadata(\n                structName,\n                extractStructIdlAnnotations(),\n                structType,\n                builderType,\n                MetadataType.UNION,\n                Optional.ofNullable(builderMethodInjection),\n                ImmutableList.copyOf(documentation),\n                ImmutableList.copyOf(fieldsMetadata),\n                Optional.ofNullable(constructorInjection),\n                methodInjections);\n    }\n\n    private ThriftConstructorInjection buildConstructorInjection()\n    {\n        for (ConstructorInjection constructorInjection : constructorInjections) {\n            if (constructorInjection.getParameters().size() == 0) {\n                return new ThriftConstructorInjection(constructorInjection.getConstructor(), buildParameterInjections(constructorInjection.getParameters()));\n            }\n        }\n\n        // This is actually legal for a ThriftUnion, all c'tors available take arguments and are associated with the FieldMetadata...\n        return null;\n    }\n\n    @Override\n    protected ThriftFieldMetadata buildField(Collection<FieldMetadata> input)\n    {\n        short id = -1;\n        boolean isLegacyId = false;\n        String name = null;\n        boolean recursiveness = false;\n        Requiredness requiredness = Requiredness.UNSPECIFIED;\n        Map<String, String> idlAnnotations = null;\n        FieldKind fieldType = FieldKind.THRIFT_FIELD;\n        ThriftTypeReference thriftTypeReference = null;\n        ThriftConstructorInjection thriftConstructorInjection = null;\n        ThriftMethodInjection thriftMethodInjection = null;\n\n        // process field injections and extractions\n        ImmutableList.Builder<ThriftInjection> injections = ImmutableList.builder();\n        ThriftExtraction extraction = null;\n        for (FieldMetadata fieldMetadata : input) {\n            id = fieldMetadata.getId();\n            isLegacyId = fieldMetadata.isLegacyId();\n            name = fieldMetadata.getName();\n            recursiveness = fieldMetadata.isRecursiveReference();\n            requiredness = fieldMetadata.getRequiredness();\n            idlAnnotations = fieldMetadata.getIdlAnnotations();\n            fieldType = fieldMetadata.getType();\n            thriftTypeReference = catalog.getFieldThriftTypeReference(fieldMetadata);\n\n            switch (requiredness) {\n                case REQUIRED:\n                case OPTIONAL:\n                    metadataErrors.addError(\"Thrift union '%s' field '%s(%s)' should not be marked required or optional\", structName, name, id);\n                    break;\n\n                default:\n                    break;\n            }\n\n            if (fieldMetadata instanceof FieldInjection) {\n                FieldInjection fieldInjection = (FieldInjection) fieldMetadata;\n                injections.add(new ThriftFieldInjection(fieldInjection.getId(), fieldInjection.getName(), fieldInjection.getField(), fieldInjection.getType()));\n            }\n            else if (fieldMetadata instanceof ParameterInjection) {\n                ParameterInjection parameterInjection = (ParameterInjection) fieldMetadata;\n                ThriftParameterInjection thriftParameterInjection = new ThriftParameterInjection(\n                        parameterInjection.getId(),\n                        parameterInjection.getName(),\n                        parameterInjection.getParameterIndex(),\n                        fieldMetadata.getJavaType());\n                injections.add(thriftParameterInjection);\n\n                for (ConstructorInjection constructorInjection : constructorInjections) {\n                    if (constructorInjection.getParameters().size() == 1 && constructorInjection.getParameters().get(0).equals(parameterInjection)) {\n                        thriftConstructorInjection = new ThriftConstructorInjection(constructorInjection.getConstructor(), thriftParameterInjection);\n                        break;\n                    }\n                }\n\n                for (MethodInjection methodInjection : methodInjections) {\n                    if (methodInjection.getParameters().size() == 1 && methodInjection.getParameters().get(0).equals(parameterInjection)) {\n                        thriftMethodInjection = new ThriftMethodInjection(methodInjection.getMethod(), thriftParameterInjection);\n                    }\n                }\n            }\n            else if (fieldMetadata instanceof FieldExtractor) {\n                FieldExtractor fieldExtractor = (FieldExtractor) fieldMetadata;\n                extraction = new ThriftFieldExtractor(\n                        fieldExtractor.getId(),\n                        fieldExtractor.getName(),\n                        fieldExtractor.getType(),\n                        fieldExtractor.getField(),\n                        fieldExtractor.getJavaType());\n            }\n            else if (fieldMetadata instanceof MethodExtractor) {\n                MethodExtractor methodExtractor = (MethodExtractor) fieldMetadata;\n                extraction = new ThriftMethodExtractor(\n                        methodExtractor.getId(),\n                        methodExtractor.getName(),\n                        methodExtractor.getType(),\n                        methodExtractor.getMethod(),\n                        methodExtractor.getJavaType());\n            }\n        }\n\n        // add type coercion\n        TypeCoercion coercion = null;\n        if (!thriftTypeReference.isRecursive() && thriftTypeReference.get().isCoerced()) {\n            coercion = catalog.getDefaultCoercion(thriftTypeReference.get().getJavaType());\n        }\n\n        return new ThriftFieldMetadata(\n                id,\n                isLegacyId,\n                recursiveness,\n                requiredness,\n                idlAnnotations,\n                thriftTypeReference,\n                name,\n                fieldType,\n                injections.build(),\n                Optional.ofNullable(thriftConstructorInjection),\n                Optional.ofNullable(thriftMethodInjection),\n                Optional.ofNullable(extraction),\n                Optional.ofNullable(coercion));\n    }\n}\n", "methodName": "ThriftFieldMetadata ThriftUnionMetadataBuilder.buildField(Collection)", "exampleID": 10, "dataset": "infer", "filepath": "drift-codec/src/main/java/io/airlift/drift/codec/metadata/ThriftUnionMetadataBuilder.java", "line": 301, "sink": "thriftTypeReference", "steps": [{"line": 226, "source": "thriftTypeReference", "filepath": "drift-codec/src/main/java/io/airlift/drift/codec/metadata/ThriftUnionMetadataBuilder.java", "exampleID": 11}]}]