Timestamp,What is your participant ID? ,Which task did you work on?,Which tool did you use? ,How mentally demanding was the task?,How hurried or rushed was the pace of the task?,"How successful were you in accomplishing what
you were asked to do?",How hard did you have to work to accomplish your level of performance?,"How insecure, discouraged, irritated, stressed, and annoyed were you?","From your inspections, list down what do you think were the root causes for false positives (i.e., what caused the static analysis tool to incorrectly report a warning). 

Here is an example answer:

""1. The analyzer doesn't seem to correctly model the String API,
2. The analyzer doesn't realize that some control-flow path is infeasible due to X and Y,
3. FunctionZ can always be assumed to return non-null,
4. ...""

Be clear and list down as many as you can. Provide references to concrete examples/code from the task if you can",Briefly describe the process or workflow you adopted to inspect the warnings,,number of words (root causes),number of sentences 9root causes),number of conrete reasons (root causes),reasons (root causes)
3/12/2024 5:32:12,1,Infer Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),5,5,4,5,6,Same as before - not adequately accounting for if checks further up in the code. Also some variables are being set so that you should be able to reliably conclude that they will not be null later.,"Look for short snÄ±ppets. Once you find a false positive, look for the similar examples. Unfortunately, I did not get to use the tool as much as I'd like. Resorted to doing a local ""mind"" cache of similar examples and marking them all the same. ",,37,5,1,1. not accounting for null checks
3/13/2024 4:51:03,2,Infer Warnings Inspection,WarningInspector,5,4,5,5,6,"Functions that I believed to expect Null cases, don't return Nulls at all, or ones that I expect to handle null cases.

There was a ""group could be null"" that basically called a toString method. Here I just assumed that if the sb StringBuilder object has default variables that were null then the toString would handle that and just give us an empty string.

The one that marked location had a getLocation method that seemed to reference a global variable, which I would assume would work in production, which is an assumption that I made for all the code.","I think the thing I was stressed about the most was probably my rusty Java syntax knowledge, but mostly deciding whether or not to assume if the function call would handle edge cases. So for instance does a certain method just return an empty String or Dictionary instead of Null or not? I think deciding between the two was what caught me up most of the time. I basically just looked at the error, identfied it in the code, and if I've seen it before I mark it as the same decision as I did previously. If not, then I think about the code and decide from there, utilizing my current knowledge on how production level code is supposed to perform and my experience in coding as well.",,97,4,1,"1. not accounting for null checks
2. not accounting for variables set to non-null"
3/14/2024 5:58:06,3,Infer Warnings Inspection,WarningInspector,7,4,3,6,4,"The analyzer does not understand the deep non-null check inside functions. For example, when getting an instance using a library method, it has checks to return a default one when the queried one does not exist.","I manually inspect all the codes and divew deep into github traces to make sure I make the correct decision. However, I feel that this dataset might be easier than the previous one which drives me complete this task faster.",,36,2,1,"1. Functions that I believed to expect Null cases, 
2. don't return Nulls at all, 
3. or ones that I expect to handle null cases.
4. The one that marked location had a getLocation method that seemed to reference a global variable, which I would assume would work in production, which is an assumption that I made for all the code."
3/15/2024 5:46:12,4,Infer Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),3,3,3,5,2,"some null checking operations are done by human or other functions automatically, but static analysis tool are focusing on limited area of the codes. For example, CollectionUtils.isNotEmpty is explicitly introduced in program, which guarantees that it is not null. but only checking on the variables can not give us such a conclusion.",I first check the codes. then i go to the source code to see if there are some assigned initial values or not. at last i make the decisions.,,52,3,2,"1, 2, 3,4"
3/16/2024 1:48:11,5,Infer Warnings Inspection,WarningInspector,6,5,3,5,4,The analyzer doesn't realize that some control-flow path is infeasible due to the previous check,"Try to understand the code logic, and then analysis whether the Null can happen",,15,1,4,1.  checks for non-null checks.
3/16/2024 1:59:03,5,Infer Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),3,2,5,3,3,The analyzer doesn't realize that some control-flow path is infeasible due to the branch condition,"Understand the code logic, and then analysis whether it could be null or not",,15,1,4,1. deep non-null check inside functions
3/16/2024 5:28:13,6,Infer Warnings Inspection,WarningInspector,5,7,5,6,6,"The analyzer didn't realize that the path was infeasible; it seemed to happen in cases where an external function was called and the null check was performed in the external function (e.g. getInstance in CredientialService.java).
The analyzer also seemed to give false positives for functions that returned instance member variables like getPageItems in Page.java which returns pageItems which is alwasy initialized as an ArrayList.","1. Read the null dereference warning message to identify which variable may be null.
2. Identify where the variable is initialized or assigned. In most cases I reviewed, an external function was called to initialize the variable.
3. Open the trace to see the implementation of the function that initializes the variable.
4. Check if that function could possibly realistically return null.",,63,9,1,1. some null checking operations are done by human or other functions automatically
3/17/2024 11:11:07,4000,Infer Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),4,6,4,4,4,"Some methods can always be assumed to return non-null values or behave in a certain way when given null values, e.g. Collections.isNotEmpty. The analyzer does not take this into account.

The analyzer doesn't track relations between variable values across loops. For example there was a task where if success was false, ex had to be non-null, and the analyzer produced a warning in a branch where success had to be false.","I looked at the immediate context, then at the trace, then at some files on GitHub from the trace. If there still wasn't enough info to reach a conclusion, I skipped the warning. If I labelled the warning, I also tried to highlight an expression which I thought was related to the root cause. Some of the inferred rules seemed too coarse-grained (package) or to have reached the wrong generalization (string return type), but I didn't know how to refine or change them. I didn't filter or label by rules as a result, but I would have if I had had more control over the rules.",,70,5,1,1. the static analysis tools are focusing on a limited area.???
3/18/2024 23:25:16,2000,Infer Warnings Inspection,WarningInspector,5,5,4,5,6,The analyzer doesn't consider if the variable was checked previously in an if block before it was dereferenced.,"I checked if there were any conditions that checked the nullness of the object/var being accessed, if it was impossible for the object to be null I marked it as a False Positive else I marked it as a True Warning",,18,1,1,1.  some control-flow path is infeasible due to the previous check
3/19/2024 2:24:43,8,Infer Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),4,4,5,3,2,The called function returned a null value but the caller class had if else checks,"1. Look at the code block and check if the nulls are being checked for
2. If a variable with null value is being used to call class functions without any check then its most likely a positive warning.
3. If there are checks in place and null value is checked for or there is a case that the value can never be null then it aims at false positive
4. Once I am able to find a false positive finding other related warnings became fairly easy with the tool
5. It was difficult to check if the value could ever be null if the called function returns null in specific scenarios and I had to check if the given input had those scenarios which was kind of time consuming
6. Moreover I tried solving warnings at random and if I get true positives as the answer the tool will not help me group the same.",,15,8,1,1. some control-flow path is infeasible due to the branch condition
3/19/2024 5:56:04,9,Infer Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),5,3,4,3,2,"1. Static analysis being unable to comprehend programmers' intention and reason in a analytic fashion, e.g. a pointer deref guarded by null pointer checks is safe","1. Identify common patterns in warnings and cluster them
2. Look at the predicates that guard the statement that triggers warning
3. Try to do constraint solving mentally and understand what the predicates are intended for
4. Check if the intention matches with the correct usage of the statement triggering warning",,26,5,1,"1. The analyzer didn't realize that the path was infeasible; it seemed to happen in cases where an external function was called and the null check was performed in the external function (e.g. getInstance in CredientialService.java).
2. The analyzer also seemed to give false positives for functions that returned instance member variables like getPageItems in Page.java which returns pageItems which is alwasy initialized as an ArrayList."
3/19/2024 7:05:45,10,Infer Warnings Inspection,WarningInspector,6,7,4,6,6,"1. Some functions always return non-null values but the tool does not know that
2. The analyzer cannot reason about the control flow check which makes the value non null all the time when doing dereferencing.",I just inspect them one by one. But sometimes I can find some common patterns between code pieces and in that case I can give answers for similar warnings faster.,,35,2,1,"1. The analyzer didn't recognize that the isDirectory checks acted as a guard for listFiles which only returns null if the File object is not a directory or does not exist.
2. The analyzer also didn't recognize that the close method would typically only be called on an open file/directory, never null."
3/20/2024 4:15:52,11,Infer Warnings Inspection,WarningInspector,3,2,3,2,1,"There were a lot of cases where I assumed a function or method call would not return null, so that made up a lot of the false negatives (not sure if that assumption was correct). That seemed to be the bulk of the false negatives.","I just skimmed the code, looked at the location and tried to decide if there could be a null pointer (or the given error) there.",,45,1,2,1. The analyzer does not seem to know the assumptions taken by the developer and the semantics of the library functions used in the code.
3/20/2024 7:47:13,3000,Infer Warnings Inspection,WarningInspector,5,6,3,5,4,-,"View stack trace, label, inspect similar matches with the tool.",,1,1,2,"1. Some methods can always be assumed to behave in a certain way given the context, e.g. listFiles will return a non-null result if isDirectory has returned true. The analyzer does not use this info."
3/22/2024 2:22:03,7,Infer Warnings Inspection,WarningInspector,5,5,4,3,3,N/A,N/A,,1,1,1,"1. Some methods can always be assumed to return non-null values or 
2.behave in a certain way when given null values, e.g. Collections.isNotEmpty. The analyzer does not take this into account.
3.. The analyzer doesn't track relations between variable values across loops. For example there was a task where if success was false, ex had to be non-null, and the analyzer produced a warning in a branch where success had to be false."
3/12/2024 5:12:59,1,Spotbugs Warnings Inspection,WarningInspector,5,5,5,5,6,"The main issue is not adequately accounting for null checks elsewhere in the program. <<<a number of times, an if statement guaranteed that the variable would not be null. ","Look for the shortest code snippets and do those first. Then it became clear that a lot of the examples were repeating similar lines of code, so I just started looking for those recurring snippets.",,29,2,1,1. The analyzer doesn't consider if the variable was checked previously in an if block before it was dereferenced.
3/13/2024 5:13:32,2,Spotbugs Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),4,5,3,4,3,"I think the reasons stayed similar, with the only change being the consideration of similar warnings that were categorized when I highlighted the statements I thought would result in a similar case. 

For example, for the warnings associated with the file opening, there was a statement in a beginning of them that checks if the file is null in the beginning or not. If this is checked then having a warning about the variable being null is a false positive. If this pattern occured elsewhere with a similar warning then I would know that it would be a false positive as well.","So like the last time, I basically just looked at the error, identfied it in the code, and if I've seen it before I mark it as the same decision as I did previously. If not, then I think about the code and decide from there, utilizing my current knowledge on how production level code is supposed to perform and my experience in coding as well. From here, I identified patterns that I thought would be present in other warnings, and checked the Inspection Progress column to find out if there were indeed warnings that matched the pattern that I selected, clicked the hyperlink, and then proceeded to check if all the ones under the filter were in fact similar to the pattern that I expected.

The idea here was to be able to mark them all as false/true, but upon further looking at all the items in the filter I was unable to do so since some of them deviated from the pattern.",,102,4,3,1. listFiles() could be assumed to return a non-null value.
3/14/2024 5:42:48,3,Spotbugs Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),5,4,3,4,1,The analyzer does not understand the prestage checks for non-null checks.,I regard this tool as a grouping tool to categorize different warnings and then inspect them one by one. I only decide on false positives or true warnings only if I've carefully checked the real code but rather suppress bogus alarms in group.,,11,2,1,1. The called function returned a null value but the caller class had if else checks
3/15/2024 6:02:44,4,Spotbugs Warnings Inspection,WarningInspector,5,4,3,6,5,the static analysis tools are focusing on a limited area. And some of them are very similar. ,"first, i go to the high-lightened codes. and then I read the context to see if they have already checked as  not null by human. since we do not have any help tool here, the second step can be very long. then i make a decision to see if it is false or true.",,17,4,1,1. dir.listFiles().length() would not return null if directory dir is valid. 
3/16/2024 5:48:55,6,Spotbugs Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),6,6,5,6,5,"The analyzer didn't recognize that the isDirectory checks acted as a guard for listFiles which only returns null if the File object is not a directory or does not exist.
The analyzer also didn't recognize that the close method would typically only be called on an open file/directory, never null.","Since SpotBugs doesn't provide a trace, it was much more difficult to determine if the variable could reasonably be null.
When identifying an unlabeled warning not related to any previously labeled warnings I did the following:
1. Select an unlabeled warning
2. Identify the variable that may be null from the warning.
3. Open the github link and search for the variable and where it is initialized.
4. Determine whether it could feasibly be null.
5. If I think its a false positive, then I also try to identify some pattern to select in the context of the original warning.
After identifying a few false positives I would select unlabeled warnings filtered by the patterns. In the case where the warnings have the same pattern, I could select all the unlabeled warnings and go through them quickly to verify that they are the same situation. Otherwise, I would follow the same steps 1-5 above.",,49,13,1,"1. Static analysis being unable to comprehend programmers' intention and reason in a analytic fashion, e.g. a pointer deref guarded by null pointer checks is safe"
3/16/2024 7:15:20,7,Spotbugs Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),6,6,2,5,7,The analyzer does not seem to know the assumptions taken by the developer and the semantics of the library functions used in the code.,"Marking a false positive -> highlighting the root cause (typically assumptions can be guessed from variable names or if-statement conditions) of the false positive -> use the filter to inspect similar examples -> if they are the same structure, then mark them as false positive",,24,1,1,"1. Static analysis being unable to comprehend programmers' intention and reason in a analytic fashion, e.g. a pointer deref guarded by null pointer checks is safe"
3/17/2024 11:11:06,4000,Spotbugs Warnings Inspection,WarningInspector,5,6,3,5,5,"Some methods can always be assumed to behave in a certain way given the context, e.g. listFiles will return a non-null result if isDirectory has returned true. The analyzer does not use this info.","I looked at the immediate context, then at the trace, then at some files on GitHub from the trace. If there still wasn't enough info to reach a conclusion, I skipped the warning.",,34,2,1,"1. Some functions always return non-null values but the tool does not know that
2. The analyzer cannot reason about the control flow check which makes the value non null all the time when doing dereferencing."
3/18/2024 23:51:05,2000,Spotbugs Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),6,6,4,6,5,listFiles() could be assumed to return a non-null value.,"1. I checked if it was impossible for a var to be null before it was used, if it was impossible I marked it as a False Positive else I marked it as a True Warning.
2. If there are warnings grouped under a summary rule, I clicked on the uninspected number and inspect the warnings.
3. For each warning I tried highlight a code expression that I could use to filter similar warnings.
4. If there were other warnings that were filtered that matched the code expression, I would scan through them and mark them all as False Positive/True Warning",,9,8,1,1. Analyzer cannot perform control flow check to determine that some variables are not NULL all the time.
3/19/2024 2:45:47,8,Spotbugs Warnings Inspection,WarningInspector,6,6,4,3,6,dir.listFiles().length() would not return null if directory dir is valid. ,"1. One by one inspect the warning
2. If I find a true warning or a false warning i will scroll to check if there is any similar scenario repeating itself. 
3. If I see a warning as false positive and if I scroll and find another similar warning I am biased to label it as false positive while it may have slight differences which make it false true positive
4.  Not able to group the false warnings added to a lot of frustration",,10,6,2,"1. There seemed to be conditional branches that would resolve the null ptr that weren't detected, or 
2. there seemed to be some functions that might never be null that were being caught as maybe being null."
3/19/2024 5:41:24,9,Spotbugs Warnings Inspection,WarningInspector,7,7,4,5,5,"1. Static analysis being unable to comprehend programmers' intention and reason in a analytic fashion, e.g. a pointer deref guarded by null pointer checks is safe","1. Identify common patterns in the warnings
2. Mentally group warnings
3. Inductively reason the correct label",,26,4,1,"1. There were a lot of cases where I assumed a function or method call would not return null, so that made up a lot of the false negatives (not sure if that assumption was correct). That seemed to be the bulk of the false negatives."
3/19/2024 7:22:39,10,Spotbugs Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),5,6,5,6,5,"Analyzer cannot perform control flow check to determine that some variables are not NULL all the time. For example, some code pieces checked the path to make sure it is a directory, but the analyzer does not know that so it may regard the listDir function could return NULL values.","Firstly I inspect them one by one, and then one rule is generated and I seleted one function isDirectory() as additional rule. And then I use filters to inspect warnings that match this rule. After inspecting all the warnings that match this rule, I start to inspect other warnings one by one by clicking on the view all uninspected warnings.",,50,3,2,1. generalize too much
3/20/2024 4:04:48,11,Spotbugs Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),5,4,2,5,5,"There seemed to be conditional branches that would resolve the null ptr that weren't detected, or there seemed to be some functions that might never be null that were being caught as maybe being null.","I don't know if I really adopted a workflow. I preferred just looking at the code. Without context of the functions being used or that much experience with the interface, it was easier to just read each independently.",,35,3,0,
3/20/2024 7:34:35,3000,Spotbugs Warnings Inspection,SWIRL (which derives the summary rules for grouping warnings),6,6,2,6,4,Analyzer seems to generalize too much and picks up more code than needed.,"Label a few, then incepect similar warnings picked up by rules",,0,0,0,